// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metamoto/types/enumerations.proto

#ifndef PROTOBUF_INCLUDED_metamoto_2ftypes_2fenumerations_2eproto
#define PROTOBUF_INCLUDED_metamoto_2ftypes_2fenumerations_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_metamoto_2ftypes_2fenumerations_2eproto 

namespace protobuf_metamoto_2ftypes_2fenumerations_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_metamoto_2ftypes_2fenumerations_2eproto
namespace metamoto {
namespace types {
}  // namespace types
}  // namespace metamoto
namespace metamoto {
namespace types {

enum ObjectType {
  OBJECT_UNKNOWN = 0,
  OBJECT_OTHER = 1,
  OBJECT_CAR = 2,
  OBJECT_TRUCK = 3,
  OBJECT_BUS = 4,
  OBJECT_MOTORCYCLE = 5,
  OBJECT_BICYCLE = 6,
  OBJECT_TRAIN = 7,
  OBJECT_PEDESTRIAN = 8,
  OBJECT_ANIMAL = 9,
  OBJECT_TRAFFIC_LIGHT = 10,
  OBJECT_TRAFFIC_SIGN = 11,
  OBJECT_TRAFFIC_BARRIER = 12,
  OBJECT_TRAFFIC_CONE = 13,
  OBJECT_GROUND = 14,
  OBJECT_ROAD = 15,
  OBJECT_RAIL_TRACK = 16,
  OBJECT_SIDEWALK = 17,
  OBJECT_CURB = 18,
  OBJECT_STATIC_OBJECT = 19,
  OBJECT_SIGN = 20,
  OBJECT_POLE = 21,
  OBJECT_BUILDING = 22,
  OBJECT_WALL = 23,
  OBJECT_FENCE = 24,
  OBJECT_TREE = 25,
  OBJECT_VEGETATION = 26,
  ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = OBJECT_UNKNOWN;
const ObjectType ObjectType_MAX = OBJECT_VEGETATION;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum MaterialType {
  MATERIAL_UNKNOWN = 0,
  MATERIAL_OTHER = 1,
  MATERIAL_ASPHALT = 2,
  MATERIAL_GRAVEL = 3,
  MATERIAL_ROCK = 4,
  MATERIAL_SOIL = 5,
  MATERIAL_SAND = 6,
  MATERIAL_GRASS = 7,
  MATERIAL_WATER = 8,
  MATERIAL_SNOW = 9,
  MATERIAL_CONCRETE = 10,
  MATERIAL_STUCCO = 11,
  MATERIAL_STONE = 12,
  MATERIAL_BRICK = 13,
  MATERIAL_WOOD = 14,
  MATERIAL_GLASS = 15,
  MATERIAL_MIRROR = 16,
  MATERIAL_CERAMIC = 17,
  MATERIAL_METAL = 18,
  MATERIAL_CARBON_FIBER = 19,
  MATERIAL_LEATHER = 20,
  MATERIAL_PLASTIC = 21,
  MATERIAL_RUBBER = 22,
  MATERIAL_PAPER = 23,
  MATERIAL_LEAF = 24,
  MATERIAL_SKIN = 25,
  MATERIAL_FABRIC = 26,
  MATERIAL_RETROREFLECTOR = 27,
  MATERIAL_TAR = 28,
  MATERIAL_RETROREFLECTIVE_PAINT = 29,
  MATERIAL_FIBERGLASS = 30,
  MATERIAL_CHROME = 31,
  MaterialType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MaterialType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MaterialType_IsValid(int value);
const MaterialType MaterialType_MIN = MATERIAL_UNKNOWN;
const MaterialType MaterialType_MAX = MATERIAL_CHROME;
const int MaterialType_ARRAYSIZE = MaterialType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaterialType_descriptor();
inline const ::std::string& MaterialType_Name(MaterialType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaterialType_descriptor(), value);
}
inline bool MaterialType_Parse(
    const ::std::string& name, MaterialType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaterialType>(
    MaterialType_descriptor(), name, value);
}
enum ReferenceFrame {
  REFERENCE_FRAME_UNKNOWN = 0,
  REFERENCE_FRAME_OTHER = 1,
  REFERENCE_FRAME_WORLD = 2,
  REFERENCE_FRAME_VEHICLE = 3,
  REFERENCE_FRAME_SENSOR = 4,
  ReferenceFrame_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReferenceFrame_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReferenceFrame_IsValid(int value);
const ReferenceFrame ReferenceFrame_MIN = REFERENCE_FRAME_UNKNOWN;
const ReferenceFrame ReferenceFrame_MAX = REFERENCE_FRAME_SENSOR;
const int ReferenceFrame_ARRAYSIZE = ReferenceFrame_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReferenceFrame_descriptor();
inline const ::std::string& ReferenceFrame_Name(ReferenceFrame value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReferenceFrame_descriptor(), value);
}
inline bool ReferenceFrame_Parse(
    const ::std::string& name, ReferenceFrame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReferenceFrame>(
    ReferenceFrame_descriptor(), name, value);
}
enum Action {
  ACTION_UNKNOWN = 0,
  ACTION_PASS = 1,
  ACTION_WARN = 2,
  ACTION_FAIL = 3,
  ACTION_STOP = 4,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Action_IsValid(int value);
const Action Action_MIN = ACTION_UNKNOWN;
const Action Action_MAX = ACTION_STOP;
const int Action_ARRAYSIZE = Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_descriptor();
inline const ::std::string& Action_Name(Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_descriptor(), value);
}
inline bool Action_Parse(
    const ::std::string& name, Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace metamoto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::metamoto::types::ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::ObjectType>() {
  return ::metamoto::types::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::MaterialType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::MaterialType>() {
  return ::metamoto::types::MaterialType_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::ReferenceFrame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::ReferenceFrame>() {
  return ::metamoto::types::ReferenceFrame_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Action>() {
  return ::metamoto::types::Action_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_metamoto_2ftypes_2fenumerations_2eproto
