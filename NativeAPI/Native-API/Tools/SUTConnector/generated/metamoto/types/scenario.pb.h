// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metamoto/types/scenario.proto

#ifndef PROTOBUF_INCLUDED_metamoto_2ftypes_2fscenario_2eproto
#define PROTOBUF_INCLUDED_metamoto_2ftypes_2fscenario_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "metamoto/types/asset.pb.h"
#include "metamoto/types/environment.pb.h"
#include "metamoto/types/normal_distribution.pb.h"
#include "metamoto/types/pedestrian.pb.h"
#include "metamoto/types/pose.pb.h"
#include "metamoto/types/range.pb.h"
#include "metamoto/types/roads.pb.h"
#include "metamoto/types/vector3.pb.h"
#include "metamoto/types/vehicle_instance.pb.h"
#include "metamoto/types/version.pb.h"
#include "metamoto/types/waypoint.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_metamoto_2ftypes_2fscenario_2eproto 

namespace protobuf_metamoto_2ftypes_2fscenario_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[39];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_metamoto_2ftypes_2fscenario_2eproto
namespace metamoto {
namespace types {
class DriverModel;
class DriverModelDefaultTypeInternal;
extern DriverModelDefaultTypeInternal _DriverModel_default_instance_;
class DriverModel_BrakingBehavior;
class DriverModel_BrakingBehaviorDefaultTypeInternal;
extern DriverModel_BrakingBehaviorDefaultTypeInternal _DriverModel_BrakingBehavior_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_ProximityTrigger;
class Event_ProximityTriggerDefaultTypeInternal;
extern Event_ProximityTriggerDefaultTypeInternal _Event_ProximityTrigger_default_instance_;
class Infraction;
class InfractionDefaultTypeInternal;
extern InfractionDefaultTypeInternal _Infraction_default_instance_;
class ParkedVehicle;
class ParkedVehicleDefaultTypeInternal;
extern ParkedVehicleDefaultTypeInternal _ParkedVehicle_default_instance_;
class PedestrianConfiguration;
class PedestrianConfigurationDefaultTypeInternal;
extern PedestrianConfigurationDefaultTypeInternal _PedestrianConfiguration_default_instance_;
class PedestrianConfiguration_PathPoint;
class PedestrianConfiguration_PathPointDefaultTypeInternal;
extern PedestrianConfiguration_PathPointDefaultTypeInternal _PedestrianConfiguration_PathPoint_default_instance_;
class Scenario;
class ScenarioDefaultTypeInternal;
extern ScenarioDefaultTypeInternal _Scenario_default_instance_;
class Scenario_EgoVehicle;
class Scenario_EgoVehicleDefaultTypeInternal;
extern Scenario_EgoVehicleDefaultTypeInternal _Scenario_EgoVehicle_default_instance_;
class Scenario_Intersection;
class Scenario_IntersectionDefaultTypeInternal;
extern Scenario_IntersectionDefaultTypeInternal _Scenario_Intersection_default_instance_;
class Scenario_Intersection_IntersectionState;
class Scenario_Intersection_IntersectionStateDefaultTypeInternal;
extern Scenario_Intersection_IntersectionStateDefaultTypeInternal _Scenario_Intersection_IntersectionState_default_instance_;
class Scenario_Intersection_Phase;
class Scenario_Intersection_PhaseDefaultTypeInternal;
extern Scenario_Intersection_PhaseDefaultTypeInternal _Scenario_Intersection_Phase_default_instance_;
class Scenario_Intersection_SignalState;
class Scenario_Intersection_SignalStateDefaultTypeInternal;
extern Scenario_Intersection_SignalStateDefaultTypeInternal _Scenario_Intersection_SignalState_default_instance_;
class Scenario_IntersectionsEntry_DoNotUse;
class Scenario_IntersectionsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_IntersectionsEntry_DoNotUseDefaultTypeInternal _Scenario_IntersectionsEntry_DoNotUse_default_instance_;
class Scenario_Objectives;
class Scenario_ObjectivesDefaultTypeInternal;
extern Scenario_ObjectivesDefaultTypeInternal _Scenario_Objectives_default_instance_;
class Scenario_Pedestrians;
class Scenario_PedestriansDefaultTypeInternal;
extern Scenario_PedestriansDefaultTypeInternal _Scenario_Pedestrians_default_instance_;
class Scenario_Pedestrians_Distribution;
class Scenario_Pedestrians_DistributionDefaultTypeInternal;
extern Scenario_Pedestrians_DistributionDefaultTypeInternal _Scenario_Pedestrians_Distribution_default_instance_;
class Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse;
class Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse_default_instance_;
class Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse;
class Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse_default_instance_;
class Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse;
class Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse_default_instance_;
class Scenario_RangesEntry_DoNotUse;
class Scenario_RangesEntry_DoNotUseDefaultTypeInternal;
extern Scenario_RangesEntry_DoNotUseDefaultTypeInternal _Scenario_RangesEntry_DoNotUse_default_instance_;
class Scenario_System;
class Scenario_SystemDefaultTypeInternal;
extern Scenario_SystemDefaultTypeInternal _Scenario_System_default_instance_;
class Scenario_System_Encoder;
class Scenario_System_EncoderDefaultTypeInternal;
extern Scenario_System_EncoderDefaultTypeInternal _Scenario_System_Encoder_default_instance_;
class Scenario_System_Logger;
class Scenario_System_LoggerDefaultTypeInternal;
extern Scenario_System_LoggerDefaultTypeInternal _Scenario_System_Logger_default_instance_;
class Scenario_System_RayTracer;
class Scenario_System_RayTracerDefaultTypeInternal;
extern Scenario_System_RayTracerDefaultTypeInternal _Scenario_System_RayTracer_default_instance_;
class Scenario_System_Service;
class Scenario_System_ServiceDefaultTypeInternal;
extern Scenario_System_ServiceDefaultTypeInternal _Scenario_System_Service_default_instance_;
class Scenario_System_ServicesEntry_DoNotUse;
class Scenario_System_ServicesEntry_DoNotUseDefaultTypeInternal;
extern Scenario_System_ServicesEntry_DoNotUseDefaultTypeInternal _Scenario_System_ServicesEntry_DoNotUse_default_instance_;
class Scenario_Traffic;
class Scenario_TrafficDefaultTypeInternal;
extern Scenario_TrafficDefaultTypeInternal _Scenario_Traffic_default_instance_;
class Scenario_TrafficLight;
class Scenario_TrafficLightDefaultTypeInternal;
extern Scenario_TrafficLightDefaultTypeInternal _Scenario_TrafficLight_default_instance_;
class Scenario_TrafficLight_Direction;
class Scenario_TrafficLight_DirectionDefaultTypeInternal;
extern Scenario_TrafficLight_DirectionDefaultTypeInternal _Scenario_TrafficLight_Direction_default_instance_;
class Scenario_TrafficLightsEntry_DoNotUse;
class Scenario_TrafficLightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_TrafficLightsEntry_DoNotUseDefaultTypeInternal _Scenario_TrafficLightsEntry_DoNotUse_default_instance_;
class Scenario_Traffic_Distribution;
class Scenario_Traffic_DistributionDefaultTypeInternal;
extern Scenario_Traffic_DistributionDefaultTypeInternal _Scenario_Traffic_Distribution_default_instance_;
class Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse;
class Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse_default_instance_;
class Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse;
class Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse_default_instance_;
class Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse;
class Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUseDefaultTypeInternal;
extern Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUseDefaultTypeInternal _Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse_default_instance_;
class TrafficFlow;
class TrafficFlowDefaultTypeInternal;
extern TrafficFlowDefaultTypeInternal _TrafficFlow_default_instance_;
class TrafficFlow_LaneSpan;
class TrafficFlow_LaneSpanDefaultTypeInternal;
extern TrafficFlow_LaneSpanDefaultTypeInternal _TrafficFlow_LaneSpan_default_instance_;
class TrafficVehicle;
class TrafficVehicleDefaultTypeInternal;
extern TrafficVehicleDefaultTypeInternal _TrafficVehicle_default_instance_;
}  // namespace types
}  // namespace metamoto
namespace google {
namespace protobuf {
template<> ::metamoto::types::DriverModel* Arena::CreateMaybeMessage<::metamoto::types::DriverModel>(Arena*);
template<> ::metamoto::types::DriverModel_BrakingBehavior* Arena::CreateMaybeMessage<::metamoto::types::DriverModel_BrakingBehavior>(Arena*);
template<> ::metamoto::types::Event* Arena::CreateMaybeMessage<::metamoto::types::Event>(Arena*);
template<> ::metamoto::types::Event_ProximityTrigger* Arena::CreateMaybeMessage<::metamoto::types::Event_ProximityTrigger>(Arena*);
template<> ::metamoto::types::Infraction* Arena::CreateMaybeMessage<::metamoto::types::Infraction>(Arena*);
template<> ::metamoto::types::ParkedVehicle* Arena::CreateMaybeMessage<::metamoto::types::ParkedVehicle>(Arena*);
template<> ::metamoto::types::PedestrianConfiguration* Arena::CreateMaybeMessage<::metamoto::types::PedestrianConfiguration>(Arena*);
template<> ::metamoto::types::PedestrianConfiguration_PathPoint* Arena::CreateMaybeMessage<::metamoto::types::PedestrianConfiguration_PathPoint>(Arena*);
template<> ::metamoto::types::Scenario* Arena::CreateMaybeMessage<::metamoto::types::Scenario>(Arena*);
template<> ::metamoto::types::Scenario_EgoVehicle* Arena::CreateMaybeMessage<::metamoto::types::Scenario_EgoVehicle>(Arena*);
template<> ::metamoto::types::Scenario_Intersection* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Intersection>(Arena*);
template<> ::metamoto::types::Scenario_Intersection_IntersectionState* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Intersection_IntersectionState>(Arena*);
template<> ::metamoto::types::Scenario_Intersection_Phase* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Intersection_Phase>(Arena*);
template<> ::metamoto::types::Scenario_Intersection_SignalState* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Intersection_SignalState>(Arena*);
template<> ::metamoto::types::Scenario_IntersectionsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_IntersectionsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Objectives* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Objectives>(Arena*);
template<> ::metamoto::types::Scenario_Pedestrians* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians>(Arena*);
template<> ::metamoto::types::Scenario_Pedestrians_Distribution* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians_Distribution>(Arena*);
template<> ::metamoto::types::Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_RangesEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_RangesEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_System* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System>(Arena*);
template<> ::metamoto::types::Scenario_System_Encoder* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System_Encoder>(Arena*);
template<> ::metamoto::types::Scenario_System_Logger* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System_Logger>(Arena*);
template<> ::metamoto::types::Scenario_System_RayTracer* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System_RayTracer>(Arena*);
template<> ::metamoto::types::Scenario_System_Service* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System_Service>(Arena*);
template<> ::metamoto::types::Scenario_System_ServicesEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_System_ServicesEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Traffic* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Traffic>(Arena*);
template<> ::metamoto::types::Scenario_TrafficLight* Arena::CreateMaybeMessage<::metamoto::types::Scenario_TrafficLight>(Arena*);
template<> ::metamoto::types::Scenario_TrafficLight_Direction* Arena::CreateMaybeMessage<::metamoto::types::Scenario_TrafficLight_Direction>(Arena*);
template<> ::metamoto::types::Scenario_TrafficLightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_TrafficLightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Traffic_Distribution* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution>(Arena*);
template<> ::metamoto::types::Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse>(Arena*);
template<> ::metamoto::types::TrafficFlow* Arena::CreateMaybeMessage<::metamoto::types::TrafficFlow>(Arena*);
template<> ::metamoto::types::TrafficFlow_LaneSpan* Arena::CreateMaybeMessage<::metamoto::types::TrafficFlow_LaneSpan>(Arena*);
template<> ::metamoto::types::TrafficVehicle* Arena::CreateMaybeMessage<::metamoto::types::TrafficVehicle>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace metamoto {
namespace types {

enum Scenario_System_LevelOfDetail {
  Scenario_System_LevelOfDetail_DYNAMIC = 0,
  Scenario_System_LevelOfDetail_HIGH = 1,
  Scenario_System_LevelOfDetail_MEDIUM = 2,
  Scenario_System_LevelOfDetail_LOW = 3,
  Scenario_System_LevelOfDetail_Scenario_System_LevelOfDetail_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Scenario_System_LevelOfDetail_Scenario_System_LevelOfDetail_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Scenario_System_LevelOfDetail_IsValid(int value);
const Scenario_System_LevelOfDetail Scenario_System_LevelOfDetail_LevelOfDetail_MIN = Scenario_System_LevelOfDetail_DYNAMIC;
const Scenario_System_LevelOfDetail Scenario_System_LevelOfDetail_LevelOfDetail_MAX = Scenario_System_LevelOfDetail_LOW;
const int Scenario_System_LevelOfDetail_LevelOfDetail_ARRAYSIZE = Scenario_System_LevelOfDetail_LevelOfDetail_MAX + 1;

const ::google::protobuf::EnumDescriptor* Scenario_System_LevelOfDetail_descriptor();
inline const ::std::string& Scenario_System_LevelOfDetail_Name(Scenario_System_LevelOfDetail value) {
  return ::google::protobuf::internal::NameOfEnum(
    Scenario_System_LevelOfDetail_descriptor(), value);
}
inline bool Scenario_System_LevelOfDetail_Parse(
    const ::std::string& name, Scenario_System_LevelOfDetail* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scenario_System_LevelOfDetail>(
    Scenario_System_LevelOfDetail_descriptor(), name, value);
}
enum Infraction_Type {
  Infraction_Type_UNKNOWN = 0,
  Infraction_Type_OTHER = 1,
  Infraction_Type_VEHICLE_COLLISION = 2,
  Infraction_Type_PEDESTRIAN_COLLISION = 3,
  Infraction_Type_ENVIRONMENT_COLLISION = 4,
  Infraction_Type_OBSTACLE_COLLISION = 5,
  Infraction_Type_TRAFFIC_LIGHT = 6,
  Infraction_Type_STOP_SIGN = 7,
  Infraction_Type_SPEED_LIMIT = 8,
  Infraction_Type_HARD_BRAKE = 9,
  Infraction_Type_WRONG_WAY = 10,
  Infraction_Type_OFF_ROAD = 11,
  Infraction_Type_EXTERNAL_WARNING = 12,
  Infraction_Type_EXTERNAL_FAILURE = 13,
  Infraction_Type_EXTERNAL_PASS = 14,
  Infraction_Type_EXTERNAL_STOP = 15,
  Infraction_Type_Infraction_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Infraction_Type_Infraction_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Infraction_Type_IsValid(int value);
const Infraction_Type Infraction_Type_Type_MIN = Infraction_Type_UNKNOWN;
const Infraction_Type Infraction_Type_Type_MAX = Infraction_Type_EXTERNAL_STOP;
const int Infraction_Type_Type_ARRAYSIZE = Infraction_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Infraction_Type_descriptor();
inline const ::std::string& Infraction_Type_Name(Infraction_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Infraction_Type_descriptor(), value);
}
inline bool Infraction_Type_Parse(
    const ::std::string& name, Infraction_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Infraction_Type>(
    Infraction_Type_descriptor(), name, value);
}
enum PedestrianConfiguration_State {
  PedestrianConfiguration_State_STATE_UNKNOWN = 0,
  PedestrianConfiguration_State_STATE_OTHER = 1,
  PedestrianConfiguration_State_IDLE = 2,
  PedestrianConfiguration_State_WALK = 3,
  PedestrianConfiguration_State_RUN = 4,
  PedestrianConfiguration_State_RUN_IN_PLACE = 5,
  PedestrianConfiguration_State_PedestrianConfiguration_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PedestrianConfiguration_State_PedestrianConfiguration_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PedestrianConfiguration_State_IsValid(int value);
const PedestrianConfiguration_State PedestrianConfiguration_State_State_MIN = PedestrianConfiguration_State_STATE_UNKNOWN;
const PedestrianConfiguration_State PedestrianConfiguration_State_State_MAX = PedestrianConfiguration_State_RUN_IN_PLACE;
const int PedestrianConfiguration_State_State_ARRAYSIZE = PedestrianConfiguration_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* PedestrianConfiguration_State_descriptor();
inline const ::std::string& PedestrianConfiguration_State_Name(PedestrianConfiguration_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    PedestrianConfiguration_State_descriptor(), value);
}
inline bool PedestrianConfiguration_State_Parse(
    const ::std::string& name, PedestrianConfiguration_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PedestrianConfiguration_State>(
    PedestrianConfiguration_State_descriptor(), name, value);
}
enum PedestrianConfiguration_PathingBehaviour {
  PedestrianConfiguration_PathingBehaviour_STANDARD = 0,
  PedestrianConfiguration_PathingBehaviour_UNCONSTRAINED = 1,
  PedestrianConfiguration_PathingBehaviour_PedestrianConfiguration_PathingBehaviour_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PedestrianConfiguration_PathingBehaviour_PedestrianConfiguration_PathingBehaviour_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PedestrianConfiguration_PathingBehaviour_IsValid(int value);
const PedestrianConfiguration_PathingBehaviour PedestrianConfiguration_PathingBehaviour_PathingBehaviour_MIN = PedestrianConfiguration_PathingBehaviour_STANDARD;
const PedestrianConfiguration_PathingBehaviour PedestrianConfiguration_PathingBehaviour_PathingBehaviour_MAX = PedestrianConfiguration_PathingBehaviour_UNCONSTRAINED;
const int PedestrianConfiguration_PathingBehaviour_PathingBehaviour_ARRAYSIZE = PedestrianConfiguration_PathingBehaviour_PathingBehaviour_MAX + 1;

const ::google::protobuf::EnumDescriptor* PedestrianConfiguration_PathingBehaviour_descriptor();
inline const ::std::string& PedestrianConfiguration_PathingBehaviour_Name(PedestrianConfiguration_PathingBehaviour value) {
  return ::google::protobuf::internal::NameOfEnum(
    PedestrianConfiguration_PathingBehaviour_descriptor(), value);
}
inline bool PedestrianConfiguration_PathingBehaviour_Parse(
    const ::std::string& name, PedestrianConfiguration_PathingBehaviour* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PedestrianConfiguration_PathingBehaviour>(
    PedestrianConfiguration_PathingBehaviour_descriptor(), name, value);
}
enum Event_ObjectType {
  Event_ObjectType_OBJECT_OTHER = 0,
  Event_ObjectType_SENSOR = 1,
  Event_ObjectType_CONTROLLER = 2,
  Event_ObjectType_EGO_VEHICLE = 3,
  Event_ObjectType_TRAFFIC_VEHICLE = 4,
  Event_ObjectType_TRAFFIC_FLOW = 5,
  Event_ObjectType_PEDESTRIAN = 6,
  Event_ObjectType_TRAFFIC_LIGHT = 7,
  Event_ObjectType_ENVIRONMENT = 8,
  Event_ObjectType_Event_ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Event_ObjectType_Event_ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Event_ObjectType_IsValid(int value);
const Event_ObjectType Event_ObjectType_ObjectType_MIN = Event_ObjectType_OBJECT_OTHER;
const Event_ObjectType Event_ObjectType_ObjectType_MAX = Event_ObjectType_ENVIRONMENT;
const int Event_ObjectType_ObjectType_ARRAYSIZE = Event_ObjectType_ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_ObjectType_descriptor();
inline const ::std::string& Event_ObjectType_Name(Event_ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_ObjectType_descriptor(), value);
}
inline bool Event_ObjectType_Parse(
    const ::std::string& name, Event_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_ObjectType>(
    Event_ObjectType_descriptor(), name, value);
}
enum Event_Action {
  Event_Action_ACTION_OTHER = 0,
  Event_Action_ACTIVATE = 1,
  Event_Action_DEACTIVATE = 2,
  Event_Action_CREATE = 3,
  Event_Action_REMOVE = 4,
  Event_Action_MODIFY = 5,
  Event_Action_SEND = 6,
  Event_Action_Event_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Event_Action_Event_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Event_Action_IsValid(int value);
const Event_Action Event_Action_Action_MIN = Event_Action_ACTION_OTHER;
const Event_Action Event_Action_Action_MAX = Event_Action_SEND;
const int Event_Action_Action_ARRAYSIZE = Event_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Action_descriptor();
inline const ::std::string& Event_Action_Name(Event_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Action_descriptor(), value);
}
inline bool Event_Action_Parse(
    const ::std::string& name, Event_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Action>(
    Event_Action_descriptor(), name, value);
}
// ===================================================================

class Scenario_System_Encoder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.System.Encoder) */ {
 public:
  Scenario_System_Encoder();
  virtual ~Scenario_System_Encoder();

  Scenario_System_Encoder(const Scenario_System_Encoder& from);

  inline Scenario_System_Encoder& operator=(const Scenario_System_Encoder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_System_Encoder(Scenario_System_Encoder&& from) noexcept
    : Scenario_System_Encoder() {
    *this = ::std::move(from);
  }

  inline Scenario_System_Encoder& operator=(Scenario_System_Encoder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_System_Encoder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_System_Encoder* internal_default_instance() {
    return reinterpret_cast<const Scenario_System_Encoder*>(
               &_Scenario_System_Encoder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Scenario_System_Encoder* other);
  friend void swap(Scenario_System_Encoder& a, Scenario_System_Encoder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_System_Encoder* New() const final {
    return CreateMaybeMessage<Scenario_System_Encoder>(NULL);
  }

  Scenario_System_Encoder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_System_Encoder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_System_Encoder& from);
  void MergeFrom(const Scenario_System_Encoder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_System_Encoder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ffmpeg_exe = 1;
  void clear_ffmpeg_exe();
  static const int kFfmpegExeFieldNumber = 1;
  const ::std::string& ffmpeg_exe() const;
  void set_ffmpeg_exe(const ::std::string& value);
  #if LANG_CXX11
  void set_ffmpeg_exe(::std::string&& value);
  #endif
  void set_ffmpeg_exe(const char* value);
  void set_ffmpeg_exe(const char* value, size_t size);
  ::std::string* mutable_ffmpeg_exe();
  ::std::string* release_ffmpeg_exe();
  void set_allocated_ffmpeg_exe(::std::string* ffmpeg_exe);

  // string ffmpeg_codec = 2;
  void clear_ffmpeg_codec();
  static const int kFfmpegCodecFieldNumber = 2;
  const ::std::string& ffmpeg_codec() const;
  void set_ffmpeg_codec(const ::std::string& value);
  #if LANG_CXX11
  void set_ffmpeg_codec(::std::string&& value);
  #endif
  void set_ffmpeg_codec(const char* value);
  void set_ffmpeg_codec(const char* value, size_t size);
  ::std::string* mutable_ffmpeg_codec();
  ::std::string* release_ffmpeg_codec();
  void set_allocated_ffmpeg_codec(::std::string* ffmpeg_codec);

  // string ffmpeg_codec_options = 3;
  void clear_ffmpeg_codec_options();
  static const int kFfmpegCodecOptionsFieldNumber = 3;
  const ::std::string& ffmpeg_codec_options() const;
  void set_ffmpeg_codec_options(const ::std::string& value);
  #if LANG_CXX11
  void set_ffmpeg_codec_options(::std::string&& value);
  #endif
  void set_ffmpeg_codec_options(const char* value);
  void set_ffmpeg_codec_options(const char* value, size_t size);
  ::std::string* mutable_ffmpeg_codec_options();
  ::std::string* release_ffmpeg_codec_options();
  void set_allocated_ffmpeg_codec_options(::std::string* ffmpeg_codec_options);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.System.Encoder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ffmpeg_exe_;
  ::google::protobuf::internal::ArenaStringPtr ffmpeg_codec_;
  ::google::protobuf::internal::ArenaStringPtr ffmpeg_codec_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_System_Logger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.System.Logger) */ {
 public:
  Scenario_System_Logger();
  virtual ~Scenario_System_Logger();

  Scenario_System_Logger(const Scenario_System_Logger& from);

  inline Scenario_System_Logger& operator=(const Scenario_System_Logger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_System_Logger(Scenario_System_Logger&& from) noexcept
    : Scenario_System_Logger() {
    *this = ::std::move(from);
  }

  inline Scenario_System_Logger& operator=(Scenario_System_Logger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_System_Logger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_System_Logger* internal_default_instance() {
    return reinterpret_cast<const Scenario_System_Logger*>(
               &_Scenario_System_Logger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Scenario_System_Logger* other);
  friend void swap(Scenario_System_Logger& a, Scenario_System_Logger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_System_Logger* New() const final {
    return CreateMaybeMessage<Scenario_System_Logger>(NULL);
  }

  Scenario_System_Logger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_System_Logger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_System_Logger& from);
  void MergeFrom(const Scenario_System_Logger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_System_Logger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // string filename = 2;
  void clear_filename();
  static const int kFilenameFieldNumber = 2;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string address = 3;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // int32 port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.System.Logger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_System_RayTracer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.System.RayTracer) */ {
 public:
  Scenario_System_RayTracer();
  virtual ~Scenario_System_RayTracer();

  Scenario_System_RayTracer(const Scenario_System_RayTracer& from);

  inline Scenario_System_RayTracer& operator=(const Scenario_System_RayTracer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_System_RayTracer(Scenario_System_RayTracer&& from) noexcept
    : Scenario_System_RayTracer() {
    *this = ::std::move(from);
  }

  inline Scenario_System_RayTracer& operator=(Scenario_System_RayTracer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_System_RayTracer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_System_RayTracer* internal_default_instance() {
    return reinterpret_cast<const Scenario_System_RayTracer*>(
               &_Scenario_System_RayTracer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Scenario_System_RayTracer* other);
  friend void swap(Scenario_System_RayTracer& a, Scenario_System_RayTracer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_System_RayTracer* New() const final {
    return CreateMaybeMessage<Scenario_System_RayTracer>(NULL);
  }

  Scenario_System_RayTracer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_System_RayTracer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_System_RayTracer& from);
  void MergeFrom(const Scenario_System_RayTracer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_System_RayTracer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // bool file_mode = 2;
  void clear_file_mode();
  static const int kFileModeFieldNumber = 2;
  bool file_mode() const;
  void set_file_mode(bool value);

  // int32 file_threshold = 3;
  void clear_file_threshold();
  static const int kFileThresholdFieldNumber = 3;
  ::google::protobuf::int32 file_threshold() const;
  void set_file_threshold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.System.RayTracer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  bool file_mode_;
  ::google::protobuf::int32 file_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_System_Service : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.System.Service) */ {
 public:
  Scenario_System_Service();
  virtual ~Scenario_System_Service();

  Scenario_System_Service(const Scenario_System_Service& from);

  inline Scenario_System_Service& operator=(const Scenario_System_Service& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_System_Service(Scenario_System_Service&& from) noexcept
    : Scenario_System_Service() {
    *this = ::std::move(from);
  }

  inline Scenario_System_Service& operator=(Scenario_System_Service&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_System_Service& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_System_Service* internal_default_instance() {
    return reinterpret_cast<const Scenario_System_Service*>(
               &_Scenario_System_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Scenario_System_Service* other);
  friend void swap(Scenario_System_Service& a, Scenario_System_Service& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_System_Service* New() const final {
    return CreateMaybeMessage<Scenario_System_Service>(NULL);
  }

  Scenario_System_Service* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_System_Service>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_System_Service& from);
  void MergeFrom(const Scenario_System_Service& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_System_Service* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 port = 1;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // int32 external_port = 2;
  void clear_external_port();
  static const int kExternalPortFieldNumber = 2;
  ::google::protobuf::int32 external_port() const;
  void set_external_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.System.Service)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 external_port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_System_ServicesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_System_ServicesEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_System_Service,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_System_ServicesEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_System_Service,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Scenario_System_ServicesEntry_DoNotUse();
  Scenario_System_ServicesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_System_ServicesEntry_DoNotUse& other);
  static const Scenario_System_ServicesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_System_ServicesEntry_DoNotUse*>(&_Scenario_System_ServicesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_System : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.System) */ {
 public:
  Scenario_System();
  virtual ~Scenario_System();

  Scenario_System(const Scenario_System& from);

  inline Scenario_System& operator=(const Scenario_System& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_System(Scenario_System&& from) noexcept
    : Scenario_System() {
    *this = ::std::move(from);
  }

  inline Scenario_System& operator=(Scenario_System&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_System* internal_default_instance() {
    return reinterpret_cast<const Scenario_System*>(
               &_Scenario_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Scenario_System* other);
  friend void swap(Scenario_System& a, Scenario_System& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_System* New() const final {
    return CreateMaybeMessage<Scenario_System>(NULL);
  }

  Scenario_System* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_System>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_System& from);
  void MergeFrom(const Scenario_System& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_System* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_System_Encoder Encoder;
  typedef Scenario_System_Logger Logger;
  typedef Scenario_System_RayTracer RayTracer;
  typedef Scenario_System_Service Service;

  typedef Scenario_System_LevelOfDetail LevelOfDetail;
  static const LevelOfDetail DYNAMIC =
    Scenario_System_LevelOfDetail_DYNAMIC;
  static const LevelOfDetail HIGH =
    Scenario_System_LevelOfDetail_HIGH;
  static const LevelOfDetail MEDIUM =
    Scenario_System_LevelOfDetail_MEDIUM;
  static const LevelOfDetail LOW =
    Scenario_System_LevelOfDetail_LOW;
  static inline bool LevelOfDetail_IsValid(int value) {
    return Scenario_System_LevelOfDetail_IsValid(value);
  }
  static const LevelOfDetail LevelOfDetail_MIN =
    Scenario_System_LevelOfDetail_LevelOfDetail_MIN;
  static const LevelOfDetail LevelOfDetail_MAX =
    Scenario_System_LevelOfDetail_LevelOfDetail_MAX;
  static const int LevelOfDetail_ARRAYSIZE =
    Scenario_System_LevelOfDetail_LevelOfDetail_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LevelOfDetail_descriptor() {
    return Scenario_System_LevelOfDetail_descriptor();
  }
  static inline const ::std::string& LevelOfDetail_Name(LevelOfDetail value) {
    return Scenario_System_LevelOfDetail_Name(value);
  }
  static inline bool LevelOfDetail_Parse(const ::std::string& name,
      LevelOfDetail* value) {
    return Scenario_System_LevelOfDetail_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<string, .metamoto.types.Scenario.System.Service> services = 9;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 9;
  const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_System_Service >&
      services() const;
  ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_System_Service >*
      mutable_services();

  // string host = 2;
  void clear_host();
  static const int kHostFieldNumber = 2;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // .metamoto.types.Scenario.System.Encoder encoder = 6;
  bool has_encoder() const;
  void clear_encoder();
  static const int kEncoderFieldNumber = 6;
  private:
  const ::metamoto::types::Scenario_System_Encoder& _internal_encoder() const;
  public:
  const ::metamoto::types::Scenario_System_Encoder& encoder() const;
  ::metamoto::types::Scenario_System_Encoder* release_encoder();
  ::metamoto::types::Scenario_System_Encoder* mutable_encoder();
  void set_allocated_encoder(::metamoto::types::Scenario_System_Encoder* encoder);

  // .metamoto.types.Scenario.System.Logger logger = 7;
  bool has_logger() const;
  void clear_logger();
  static const int kLoggerFieldNumber = 7;
  private:
  const ::metamoto::types::Scenario_System_Logger& _internal_logger() const;
  public:
  const ::metamoto::types::Scenario_System_Logger& logger() const;
  ::metamoto::types::Scenario_System_Logger* release_logger();
  ::metamoto::types::Scenario_System_Logger* mutable_logger();
  void set_allocated_logger(::metamoto::types::Scenario_System_Logger* logger);

  // .metamoto.types.Scenario.System.RayTracer ray_tracer = 8;
  bool has_ray_tracer() const;
  void clear_ray_tracer();
  static const int kRayTracerFieldNumber = 8;
  private:
  const ::metamoto::types::Scenario_System_RayTracer& _internal_ray_tracer() const;
  public:
  const ::metamoto::types::Scenario_System_RayTracer& ray_tracer() const;
  ::metamoto::types::Scenario_System_RayTracer* release_ray_tracer();
  ::metamoto::types::Scenario_System_RayTracer* mutable_ray_tracer();
  void set_allocated_ray_tracer(::metamoto::types::Scenario_System_RayTracer* ray_tracer);

  // int32 random_seed = 1;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 1;
  ::google::protobuf::int32 random_seed() const;
  void set_random_seed(::google::protobuf::int32 value);

  // bool record_ground_truth = 3;
  void clear_record_ground_truth();
  static const int kRecordGroundTruthFieldNumber = 3;
  bool record_ground_truth() const;
  void set_record_ground_truth(bool value);

  // bool profile = 4;
  void clear_profile();
  static const int kProfileFieldNumber = 4;
  bool profile() const;
  void set_profile(bool value);

  // float physics_rate = 5;
  void clear_physics_rate();
  static const int kPhysicsRateFieldNumber = 5;
  float physics_rate() const;
  void set_physics_rate(float value);

  // .metamoto.types.Scenario.System.LevelOfDetail camera_lod = 10;
  void clear_camera_lod();
  static const int kCameraLodFieldNumber = 10;
  ::metamoto::types::Scenario_System_LevelOfDetail camera_lod() const;
  void set_camera_lod(::metamoto::types::Scenario_System_LevelOfDetail value);

  // .metamoto.types.Scenario.System.LevelOfDetail ray_tracer_lod = 11;
  void clear_ray_tracer_lod();
  static const int kRayTracerLodFieldNumber = 11;
  ::metamoto::types::Scenario_System_LevelOfDetail ray_tracer_lod() const;
  void set_ray_tracer_lod(::metamoto::types::Scenario_System_LevelOfDetail value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.System)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Scenario_System_ServicesEntry_DoNotUse,
      ::std::string, ::metamoto::types::Scenario_System_Service,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > services_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::metamoto::types::Scenario_System_Encoder* encoder_;
  ::metamoto::types::Scenario_System_Logger* logger_;
  ::metamoto::types::Scenario_System_RayTracer* ray_tracer_;
  ::google::protobuf::int32 random_seed_;
  bool record_ground_truth_;
  bool profile_;
  float physics_rate_;
  int camera_lod_;
  int ray_tracer_lod_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Objectives : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Objectives) */ {
 public:
  Scenario_Objectives();
  virtual ~Scenario_Objectives();

  Scenario_Objectives(const Scenario_Objectives& from);

  inline Scenario_Objectives& operator=(const Scenario_Objectives& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Objectives(Scenario_Objectives&& from) noexcept
    : Scenario_Objectives() {
    *this = ::std::move(from);
  }

  inline Scenario_Objectives& operator=(Scenario_Objectives&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Objectives& default_instance();

  enum DestinationOneofCase {
    kDestinationWorldPoint = 2,
    kDestinationRoadPoint = 3,
    DESTINATION_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Objectives* internal_default_instance() {
    return reinterpret_cast<const Scenario_Objectives*>(
               &_Scenario_Objectives_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Scenario_Objectives* other);
  friend void swap(Scenario_Objectives& a, Scenario_Objectives& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Objectives* New() const final {
    return CreateMaybeMessage<Scenario_Objectives>(NULL);
  }

  Scenario_Objectives* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Objectives>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Objectives& from);
  void MergeFrom(const Scenario_Objectives& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Objectives* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Infraction infractions = 5;
  int infractions_size() const;
  void clear_infractions();
  static const int kInfractionsFieldNumber = 5;
  ::metamoto::types::Infraction* mutable_infractions(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Infraction >*
      mutable_infractions();
  const ::metamoto::types::Infraction& infractions(int index) const;
  ::metamoto::types::Infraction* add_infractions();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Infraction >&
      infractions() const;

  // float duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  float duration() const;
  void set_duration(float value);

  // float destination_radius = 4;
  void clear_destination_radius();
  static const int kDestinationRadiusFieldNumber = 4;
  float destination_radius() const;
  void set_destination_radius(float value);

  // float random_failure_probability = 6;
  void clear_random_failure_probability();
  static const int kRandomFailureProbabilityFieldNumber = 6;
  float random_failure_probability() const;
  void set_random_failure_probability(float value);

  // bool monitor_all_vehicles = 7;
  void clear_monitor_all_vehicles();
  static const int kMonitorAllVehiclesFieldNumber = 7;
  bool monitor_all_vehicles() const;
  void set_monitor_all_vehicles(bool value);

  // .metamoto.types.Vector3 destination_world_point = 2;
  bool has_destination_world_point() const;
  void clear_destination_world_point();
  static const int kDestinationWorldPointFieldNumber = 2;
  private:
  const ::metamoto::types::Vector3& _internal_destination_world_point() const;
  public:
  const ::metamoto::types::Vector3& destination_world_point() const;
  ::metamoto::types::Vector3* release_destination_world_point();
  ::metamoto::types::Vector3* mutable_destination_world_point();
  void set_allocated_destination_world_point(::metamoto::types::Vector3* destination_world_point);

  // .metamoto.types.RoadPoint destination_road_point = 3;
  bool has_destination_road_point() const;
  void clear_destination_road_point();
  static const int kDestinationRoadPointFieldNumber = 3;
  private:
  const ::metamoto::types::RoadPoint& _internal_destination_road_point() const;
  public:
  const ::metamoto::types::RoadPoint& destination_road_point() const;
  ::metamoto::types::RoadPoint* release_destination_road_point();
  ::metamoto::types::RoadPoint* mutable_destination_road_point();
  void set_allocated_destination_road_point(::metamoto::types::RoadPoint* destination_road_point);

  void clear_destination_oneof();
  DestinationOneofCase destination_oneof_case() const;
  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Objectives)
 private:
  void set_has_destination_world_point();
  void set_has_destination_road_point();

  inline bool has_destination_oneof() const;
  inline void clear_has_destination_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Infraction > infractions_;
  float duration_;
  float destination_radius_;
  float random_failure_probability_;
  bool monitor_all_vehicles_;
  union DestinationOneofUnion {
    DestinationOneofUnion() {}
    ::metamoto::types::Vector3* destination_world_point_;
    ::metamoto::types::RoadPoint* destination_road_point_;
  } destination_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_EgoVehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.EgoVehicle) */ {
 public:
  Scenario_EgoVehicle();
  virtual ~Scenario_EgoVehicle();

  Scenario_EgoVehicle(const Scenario_EgoVehicle& from);

  inline Scenario_EgoVehicle& operator=(const Scenario_EgoVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_EgoVehicle(Scenario_EgoVehicle&& from) noexcept
    : Scenario_EgoVehicle() {
    *this = ::std::move(from);
  }

  inline Scenario_EgoVehicle& operator=(Scenario_EgoVehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_EgoVehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_EgoVehicle* internal_default_instance() {
    return reinterpret_cast<const Scenario_EgoVehicle*>(
               &_Scenario_EgoVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Scenario_EgoVehicle* other);
  friend void swap(Scenario_EgoVehicle& a, Scenario_EgoVehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_EgoVehicle* New() const final {
    return CreateMaybeMessage<Scenario_EgoVehicle>(NULL);
  }

  Scenario_EgoVehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_EgoVehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_EgoVehicle& from);
  void MergeFrom(const Scenario_EgoVehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_EgoVehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Waypoint path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  ::metamoto::types::Waypoint* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
      mutable_path();
  const ::metamoto::types::Waypoint& path(int index) const;
  ::metamoto::types::Waypoint* add_path();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
      path() const;

  // .metamoto.types.DriverModel driver_model = 2;
  bool has_driver_model() const;
  void clear_driver_model();
  static const int kDriverModelFieldNumber = 2;
  private:
  const ::metamoto::types::DriverModel& _internal_driver_model() const;
  public:
  const ::metamoto::types::DriverModel& driver_model() const;
  ::metamoto::types::DriverModel* release_driver_model();
  ::metamoto::types::DriverModel* mutable_driver_model();
  void set_allocated_driver_model(::metamoto::types::DriverModel* driver_model);

  // bool random_spawn_point = 3;
  void clear_random_spawn_point();
  static const int kRandomSpawnPointFieldNumber = 3;
  bool random_spawn_point() const;
  void set_random_spawn_point(bool value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.EgoVehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint > path_;
  ::metamoto::types::DriverModel* driver_model_;
  bool random_spawn_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse();
  Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse& other);
  static const Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse*>(&_Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse();
  Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse& other);
  static const Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse*>(&_Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse();
  Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse& other);
  static const Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse*>(&_Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Traffic_Distribution : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Traffic.Distribution) */ {
 public:
  Scenario_Traffic_Distribution();
  virtual ~Scenario_Traffic_Distribution();

  Scenario_Traffic_Distribution(const Scenario_Traffic_Distribution& from);

  inline Scenario_Traffic_Distribution& operator=(const Scenario_Traffic_Distribution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Traffic_Distribution(Scenario_Traffic_Distribution&& from) noexcept
    : Scenario_Traffic_Distribution() {
    *this = ::std::move(from);
  }

  inline Scenario_Traffic_Distribution& operator=(Scenario_Traffic_Distribution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Traffic_Distribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Traffic_Distribution* internal_default_instance() {
    return reinterpret_cast<const Scenario_Traffic_Distribution*>(
               &_Scenario_Traffic_Distribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Scenario_Traffic_Distribution* other);
  friend void swap(Scenario_Traffic_Distribution& a, Scenario_Traffic_Distribution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Traffic_Distribution* New() const final {
    return CreateMaybeMessage<Scenario_Traffic_Distribution>(NULL);
  }

  Scenario_Traffic_Distribution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Traffic_Distribution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Traffic_Distribution& from);
  void MergeFrom(const Scenario_Traffic_Distribution& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Traffic_Distribution* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, float> model_weights = 1;
  int model_weights_size() const;
  void clear_model_weights();
  static const int kModelWeightsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, float >&
      model_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_model_weights();

  // map<string, float> type_weights = 2;
  int type_weights_size() const;
  void clear_type_weights();
  static const int kTypeWeightsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, float >&
      type_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_type_weights();

  // map<string, float> paint_weights = 3;
  int paint_weights_size() const;
  void clear_paint_weights();
  static const int kPaintWeightsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, float >&
      paint_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_paint_weights();

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Traffic.Distribution)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Scenario_Traffic_Distribution_ModelWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > model_weights_;
  ::google::protobuf::internal::MapField<
      Scenario_Traffic_Distribution_TypeWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > type_weights_;
  ::google::protobuf::internal::MapField<
      Scenario_Traffic_Distribution_PaintWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > paint_weights_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Traffic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Traffic) */ {
 public:
  Scenario_Traffic();
  virtual ~Scenario_Traffic();

  Scenario_Traffic(const Scenario_Traffic& from);

  inline Scenario_Traffic& operator=(const Scenario_Traffic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Traffic(Scenario_Traffic&& from) noexcept
    : Scenario_Traffic() {
    *this = ::std::move(from);
  }

  inline Scenario_Traffic& operator=(Scenario_Traffic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Traffic& default_instance();

  enum RandomOneofCase {
    kNumRandomVehicles = 3,
    kCongestion = 4,
    RANDOM_ONEOF_NOT_SET = 0,
  };

  enum RandomParkedOneofCase {
    kNumRandomParkedVehicles = 8,
    kParkingFullness = 9,
    RANDOM_PARKED_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Traffic* internal_default_instance() {
    return reinterpret_cast<const Scenario_Traffic*>(
               &_Scenario_Traffic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Scenario_Traffic* other);
  friend void swap(Scenario_Traffic& a, Scenario_Traffic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Traffic* New() const final {
    return CreateMaybeMessage<Scenario_Traffic>(NULL);
  }

  Scenario_Traffic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Traffic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Traffic& from);
  void MergeFrom(const Scenario_Traffic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Traffic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_Traffic_Distribution Distribution;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Vector3 region = 1;
  int region_size() const;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  ::metamoto::types::Vector3* mutable_region(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
      mutable_region();
  const ::metamoto::types::Vector3& region(int index) const;
  ::metamoto::types::Vector3* add_region();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
      region() const;

  // repeated .metamoto.types.TrafficFlow flows = 5;
  int flows_size() const;
  void clear_flows();
  static const int kFlowsFieldNumber = 5;
  ::metamoto::types::TrafficFlow* mutable_flows(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow >*
      mutable_flows();
  const ::metamoto::types::TrafficFlow& flows(int index) const;
  ::metamoto::types::TrafficFlow* add_flows();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow >&
      flows() const;

  // repeated .metamoto.types.TrafficVehicle vehicles = 6;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 6;
  ::metamoto::types::TrafficVehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficVehicle >*
      mutable_vehicles();
  const ::metamoto::types::TrafficVehicle& vehicles(int index) const;
  ::metamoto::types::TrafficVehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficVehicle >&
      vehicles() const;

  // repeated .metamoto.types.ParkedVehicle parked_vehicles = 10;
  int parked_vehicles_size() const;
  void clear_parked_vehicles();
  static const int kParkedVehiclesFieldNumber = 10;
  ::metamoto::types::ParkedVehicle* mutable_parked_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::ParkedVehicle >*
      mutable_parked_vehicles();
  const ::metamoto::types::ParkedVehicle& parked_vehicles(int index) const;
  ::metamoto::types::ParkedVehicle* add_parked_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::ParkedVehicle >&
      parked_vehicles() const;

  // .metamoto.types.Scenario.Traffic.Distribution distribution = 2;
  bool has_distribution() const;
  void clear_distribution();
  static const int kDistributionFieldNumber = 2;
  private:
  const ::metamoto::types::Scenario_Traffic_Distribution& _internal_distribution() const;
  public:
  const ::metamoto::types::Scenario_Traffic_Distribution& distribution() const;
  ::metamoto::types::Scenario_Traffic_Distribution* release_distribution();
  ::metamoto::types::Scenario_Traffic_Distribution* mutable_distribution();
  void set_allocated_distribution(::metamoto::types::Scenario_Traffic_Distribution* distribution);

  // .metamoto.types.Scenario.Traffic.Distribution parked_distribution = 7;
  bool has_parked_distribution() const;
  void clear_parked_distribution();
  static const int kParkedDistributionFieldNumber = 7;
  private:
  const ::metamoto::types::Scenario_Traffic_Distribution& _internal_parked_distribution() const;
  public:
  const ::metamoto::types::Scenario_Traffic_Distribution& parked_distribution() const;
  ::metamoto::types::Scenario_Traffic_Distribution* release_parked_distribution();
  ::metamoto::types::Scenario_Traffic_Distribution* mutable_parked_distribution();
  void set_allocated_parked_distribution(::metamoto::types::Scenario_Traffic_Distribution* parked_distribution);

  // int32 num_random_vehicles = 3;
  private:
  bool has_num_random_vehicles() const;
  public:
  void clear_num_random_vehicles();
  static const int kNumRandomVehiclesFieldNumber = 3;
  ::google::protobuf::int32 num_random_vehicles() const;
  void set_num_random_vehicles(::google::protobuf::int32 value);

  // float congestion = 4;
  private:
  bool has_congestion() const;
  public:
  void clear_congestion();
  static const int kCongestionFieldNumber = 4;
  float congestion() const;
  void set_congestion(float value);

  // int32 num_random_parked_vehicles = 8;
  private:
  bool has_num_random_parked_vehicles() const;
  public:
  void clear_num_random_parked_vehicles();
  static const int kNumRandomParkedVehiclesFieldNumber = 8;
  ::google::protobuf::int32 num_random_parked_vehicles() const;
  void set_num_random_parked_vehicles(::google::protobuf::int32 value);

  // float parking_fullness = 9;
  private:
  bool has_parking_fullness() const;
  public:
  void clear_parking_fullness();
  static const int kParkingFullnessFieldNumber = 9;
  float parking_fullness() const;
  void set_parking_fullness(float value);

  void clear_random_oneof();
  RandomOneofCase random_oneof_case() const;
  void clear_random_parked_oneof();
  RandomParkedOneofCase random_parked_oneof_case() const;
  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Traffic)
 private:
  void set_has_num_random_vehicles();
  void set_has_congestion();
  void set_has_num_random_parked_vehicles();
  void set_has_parking_fullness();

  inline bool has_random_oneof() const;
  inline void clear_has_random_oneof();

  inline bool has_random_parked_oneof() const;
  inline void clear_has_random_parked_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 > region_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow > flows_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficVehicle > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::ParkedVehicle > parked_vehicles_;
  ::metamoto::types::Scenario_Traffic_Distribution* distribution_;
  ::metamoto::types::Scenario_Traffic_Distribution* parked_distribution_;
  union RandomOneofUnion {
    RandomOneofUnion() {}
    ::google::protobuf::int32 num_random_vehicles_;
    float congestion_;
  } random_oneof_;
  union RandomParkedOneofUnion {
    RandomParkedOneofUnion() {}
    ::google::protobuf::int32 num_random_parked_vehicles_;
    float parking_fullness_;
  } random_parked_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse();
  Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse& other);
  static const Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse*>(&_Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse();
  Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse& other);
  static const Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse*>(&_Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse, 
    ::std::string, float,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse();
  Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse& other);
  static const Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse*>(&_Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Pedestrians_Distribution : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Pedestrians.Distribution) */ {
 public:
  Scenario_Pedestrians_Distribution();
  virtual ~Scenario_Pedestrians_Distribution();

  Scenario_Pedestrians_Distribution(const Scenario_Pedestrians_Distribution& from);

  inline Scenario_Pedestrians_Distribution& operator=(const Scenario_Pedestrians_Distribution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Pedestrians_Distribution(Scenario_Pedestrians_Distribution&& from) noexcept
    : Scenario_Pedestrians_Distribution() {
    *this = ::std::move(from);
  }

  inline Scenario_Pedestrians_Distribution& operator=(Scenario_Pedestrians_Distribution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Pedestrians_Distribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Pedestrians_Distribution* internal_default_instance() {
    return reinterpret_cast<const Scenario_Pedestrians_Distribution*>(
               &_Scenario_Pedestrians_Distribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Scenario_Pedestrians_Distribution* other);
  friend void swap(Scenario_Pedestrians_Distribution& a, Scenario_Pedestrians_Distribution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Pedestrians_Distribution* New() const final {
    return CreateMaybeMessage<Scenario_Pedestrians_Distribution>(NULL);
  }

  Scenario_Pedestrians_Distribution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Pedestrians_Distribution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Pedestrians_Distribution& from);
  void MergeFrom(const Scenario_Pedestrians_Distribution& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Pedestrians_Distribution* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, float> name_weights = 1;
  int name_weights_size() const;
  void clear_name_weights();
  static const int kNameWeightsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, float >&
      name_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_name_weights();

  // map<string, float> type_weights = 2;
  int type_weights_size() const;
  void clear_type_weights();
  static const int kTypeWeightsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, float >&
      type_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_type_weights();

  // map<string, float> state_weights = 3;
  int state_weights_size() const;
  void clear_state_weights();
  static const int kStateWeightsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, float >&
      state_weights() const;
  ::google::protobuf::Map< ::std::string, float >*
      mutable_state_weights();

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Pedestrians.Distribution)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Scenario_Pedestrians_Distribution_NameWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > name_weights_;
  ::google::protobuf::internal::MapField<
      Scenario_Pedestrians_Distribution_TypeWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > type_weights_;
  ::google::protobuf::internal::MapField<
      Scenario_Pedestrians_Distribution_StateWeightsEntry_DoNotUse,
      ::std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT,
      0 > state_weights_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Pedestrians : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Pedestrians) */ {
 public:
  Scenario_Pedestrians();
  virtual ~Scenario_Pedestrians();

  Scenario_Pedestrians(const Scenario_Pedestrians& from);

  inline Scenario_Pedestrians& operator=(const Scenario_Pedestrians& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Pedestrians(Scenario_Pedestrians&& from) noexcept
    : Scenario_Pedestrians() {
    *this = ::std::move(from);
  }

  inline Scenario_Pedestrians& operator=(Scenario_Pedestrians&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Pedestrians& default_instance();

  enum RandomOneofCase {
    kNumRandomPedestrians = 4,
    kPedestrianTraffic = 5,
    RANDOM_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Pedestrians* internal_default_instance() {
    return reinterpret_cast<const Scenario_Pedestrians*>(
               &_Scenario_Pedestrians_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Scenario_Pedestrians* other);
  friend void swap(Scenario_Pedestrians& a, Scenario_Pedestrians& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Pedestrians* New() const final {
    return CreateMaybeMessage<Scenario_Pedestrians>(NULL);
  }

  Scenario_Pedestrians* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Pedestrians>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Pedestrians& from);
  void MergeFrom(const Scenario_Pedestrians& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Pedestrians* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_Pedestrians_Distribution Distribution;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Vector3 region = 1;
  int region_size() const;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  ::metamoto::types::Vector3* mutable_region(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
      mutable_region();
  const ::metamoto::types::Vector3& region(int index) const;
  ::metamoto::types::Vector3* add_region();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
      region() const;

  // repeated .metamoto.types.PedestrianConfiguration pedestrians = 3;
  int pedestrians_size() const;
  void clear_pedestrians();
  static const int kPedestriansFieldNumber = 3;
  ::metamoto::types::PedestrianConfiguration* mutable_pedestrians(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration >*
      mutable_pedestrians();
  const ::metamoto::types::PedestrianConfiguration& pedestrians(int index) const;
  ::metamoto::types::PedestrianConfiguration* add_pedestrians();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration >&
      pedestrians() const;

  // .metamoto.types.Scenario.Pedestrians.Distribution distribution = 2;
  bool has_distribution() const;
  void clear_distribution();
  static const int kDistributionFieldNumber = 2;
  private:
  const ::metamoto::types::Scenario_Pedestrians_Distribution& _internal_distribution() const;
  public:
  const ::metamoto::types::Scenario_Pedestrians_Distribution& distribution() const;
  ::metamoto::types::Scenario_Pedestrians_Distribution* release_distribution();
  ::metamoto::types::Scenario_Pedestrians_Distribution* mutable_distribution();
  void set_allocated_distribution(::metamoto::types::Scenario_Pedestrians_Distribution* distribution);

  // int32 num_random_pedestrians = 4;
  private:
  bool has_num_random_pedestrians() const;
  public:
  void clear_num_random_pedestrians();
  static const int kNumRandomPedestriansFieldNumber = 4;
  ::google::protobuf::int32 num_random_pedestrians() const;
  void set_num_random_pedestrians(::google::protobuf::int32 value);

  // float pedestrian_traffic = 5;
  private:
  bool has_pedestrian_traffic() const;
  public:
  void clear_pedestrian_traffic();
  static const int kPedestrianTrafficFieldNumber = 5;
  float pedestrian_traffic() const;
  void set_pedestrian_traffic(float value);

  void clear_random_oneof();
  RandomOneofCase random_oneof_case() const;
  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Pedestrians)
 private:
  void set_has_num_random_pedestrians();
  void set_has_pedestrian_traffic();

  inline bool has_random_oneof() const;
  inline void clear_has_random_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 > region_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration > pedestrians_;
  ::metamoto::types::Scenario_Pedestrians_Distribution* distribution_;
  union RandomOneofUnion {
    RandomOneofUnion() {}
    ::google::protobuf::int32 num_random_pedestrians_;
    float pedestrian_traffic_;
  } random_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_TrafficLight_Direction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.TrafficLight.Direction) */ {
 public:
  Scenario_TrafficLight_Direction();
  virtual ~Scenario_TrafficLight_Direction();

  Scenario_TrafficLight_Direction(const Scenario_TrafficLight_Direction& from);

  inline Scenario_TrafficLight_Direction& operator=(const Scenario_TrafficLight_Direction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_TrafficLight_Direction(Scenario_TrafficLight_Direction&& from) noexcept
    : Scenario_TrafficLight_Direction() {
    *this = ::std::move(from);
  }

  inline Scenario_TrafficLight_Direction& operator=(Scenario_TrafficLight_Direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_TrafficLight_Direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_TrafficLight_Direction* internal_default_instance() {
    return reinterpret_cast<const Scenario_TrafficLight_Direction*>(
               &_Scenario_TrafficLight_Direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Scenario_TrafficLight_Direction* other);
  friend void swap(Scenario_TrafficLight_Direction& a, Scenario_TrafficLight_Direction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_TrafficLight_Direction* New() const final {
    return CreateMaybeMessage<Scenario_TrafficLight_Direction>(NULL);
  }

  Scenario_TrafficLight_Direction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_TrafficLight_Direction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_TrafficLight_Direction& from);
  void MergeFrom(const Scenario_TrafficLight_Direction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_TrafficLight_Direction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string synchronize_with_direction_id = 5;
  void clear_synchronize_with_direction_id();
  static const int kSynchronizeWithDirectionIdFieldNumber = 5;
  const ::std::string& synchronize_with_direction_id() const;
  void set_synchronize_with_direction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_synchronize_with_direction_id(::std::string&& value);
  #endif
  void set_synchronize_with_direction_id(const char* value);
  void set_synchronize_with_direction_id(const char* value, size_t size);
  ::std::string* mutable_synchronize_with_direction_id();
  ::std::string* release_synchronize_with_direction_id();
  void set_allocated_synchronize_with_direction_id(::std::string* synchronize_with_direction_id);

  // .google.protobuf.FloatValue green_time = 2;
  bool has_green_time() const;
  void clear_green_time();
  static const int kGreenTimeFieldNumber = 2;
  private:
  const ::google::protobuf::FloatValue& _internal_green_time() const;
  public:
  const ::google::protobuf::FloatValue& green_time() const;
  ::google::protobuf::FloatValue* release_green_time();
  ::google::protobuf::FloatValue* mutable_green_time();
  void set_allocated_green_time(::google::protobuf::FloatValue* green_time);

  // .google.protobuf.FloatValue yellow_time = 3;
  bool has_yellow_time() const;
  void clear_yellow_time();
  static const int kYellowTimeFieldNumber = 3;
  private:
  const ::google::protobuf::FloatValue& _internal_yellow_time() const;
  public:
  const ::google::protobuf::FloatValue& yellow_time() const;
  ::google::protobuf::FloatValue* release_yellow_time();
  ::google::protobuf::FloatValue* mutable_yellow_time();
  void set_allocated_yellow_time(::google::protobuf::FloatValue* yellow_time);

  // .google.protobuf.FloatValue crosswalk_walk_time = 4;
  bool has_crosswalk_walk_time() const;
  void clear_crosswalk_walk_time();
  static const int kCrosswalkWalkTimeFieldNumber = 4;
  private:
  const ::google::protobuf::FloatValue& _internal_crosswalk_walk_time() const;
  public:
  const ::google::protobuf::FloatValue& crosswalk_walk_time() const;
  ::google::protobuf::FloatValue* release_crosswalk_walk_time();
  ::google::protobuf::FloatValue* mutable_crosswalk_walk_time();
  void set_allocated_crosswalk_walk_time(::google::protobuf::FloatValue* crosswalk_walk_time);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.TrafficLight.Direction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr synchronize_with_direction_id_;
  ::google::protobuf::FloatValue* green_time_;
  ::google::protobuf::FloatValue* yellow_time_;
  ::google::protobuf::FloatValue* crosswalk_walk_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.TrafficLight) */ {
 public:
  Scenario_TrafficLight();
  virtual ~Scenario_TrafficLight();

  Scenario_TrafficLight(const Scenario_TrafficLight& from);

  inline Scenario_TrafficLight& operator=(const Scenario_TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_TrafficLight(Scenario_TrafficLight&& from) noexcept
    : Scenario_TrafficLight() {
    *this = ::std::move(from);
  }

  inline Scenario_TrafficLight& operator=(Scenario_TrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_TrafficLight* internal_default_instance() {
    return reinterpret_cast<const Scenario_TrafficLight*>(
               &_Scenario_TrafficLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Scenario_TrafficLight* other);
  friend void swap(Scenario_TrafficLight& a, Scenario_TrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_TrafficLight* New() const final {
    return CreateMaybeMessage<Scenario_TrafficLight>(NULL);
  }

  Scenario_TrafficLight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_TrafficLight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_TrafficLight& from);
  void MergeFrom(const Scenario_TrafficLight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_TrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_TrafficLight_Direction Direction;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Scenario.TrafficLight.Direction directions = 1;
  int directions_size() const;
  void clear_directions();
  static const int kDirectionsFieldNumber = 1;
  ::metamoto::types::Scenario_TrafficLight_Direction* mutable_directions(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_TrafficLight_Direction >*
      mutable_directions();
  const ::metamoto::types::Scenario_TrafficLight_Direction& directions(int index) const;
  ::metamoto::types::Scenario_TrafficLight_Direction* add_directions();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_TrafficLight_Direction >&
      directions() const;

  // string start_green_direction = 3;
  void clear_start_green_direction();
  static const int kStartGreenDirectionFieldNumber = 3;
  const ::std::string& start_green_direction() const;
  void set_start_green_direction(const ::std::string& value);
  #if LANG_CXX11
  void set_start_green_direction(::std::string&& value);
  #endif
  void set_start_green_direction(const char* value);
  void set_start_green_direction(const char* value, size_t size);
  ::std::string* mutable_start_green_direction();
  ::std::string* release_start_green_direction();
  void set_allocated_start_green_direction(::std::string* start_green_direction);

  // float all_red_time = 2;
  void clear_all_red_time();
  static const int kAllRedTimeFieldNumber = 2;
  float all_red_time() const;
  void set_all_red_time(float value);

  // float start_cycle_offset = 4;
  void clear_start_cycle_offset();
  static const int kStartCycleOffsetFieldNumber = 4;
  float start_cycle_offset() const;
  void set_start_cycle_offset(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.TrafficLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_TrafficLight_Direction > directions_;
  ::google::protobuf::internal::ArenaStringPtr start_green_direction_;
  float all_red_time_;
  float start_cycle_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_TrafficLightsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_TrafficLightsEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_TrafficLight,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_TrafficLightsEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_TrafficLight,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Scenario_TrafficLightsEntry_DoNotUse();
  Scenario_TrafficLightsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_TrafficLightsEntry_DoNotUse& other);
  static const Scenario_TrafficLightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_TrafficLightsEntry_DoNotUse*>(&_Scenario_TrafficLightsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_Intersection_SignalState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Intersection.SignalState) */ {
 public:
  Scenario_Intersection_SignalState();
  virtual ~Scenario_Intersection_SignalState();

  Scenario_Intersection_SignalState(const Scenario_Intersection_SignalState& from);

  inline Scenario_Intersection_SignalState& operator=(const Scenario_Intersection_SignalState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Intersection_SignalState(Scenario_Intersection_SignalState&& from) noexcept
    : Scenario_Intersection_SignalState() {
    *this = ::std::move(from);
  }

  inline Scenario_Intersection_SignalState& operator=(Scenario_Intersection_SignalState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Intersection_SignalState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Intersection_SignalState* internal_default_instance() {
    return reinterpret_cast<const Scenario_Intersection_SignalState*>(
               &_Scenario_Intersection_SignalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Scenario_Intersection_SignalState* other);
  friend void swap(Scenario_Intersection_SignalState& a, Scenario_Intersection_SignalState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Intersection_SignalState* New() const final {
    return CreateMaybeMessage<Scenario_Intersection_SignalState>(NULL);
  }

  Scenario_Intersection_SignalState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Intersection_SignalState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Intersection_SignalState& from);
  void MergeFrom(const Scenario_Intersection_SignalState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Intersection_SignalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string signal_id = 1;
  void clear_signal_id();
  static const int kSignalIdFieldNumber = 1;
  const ::std::string& signal_id() const;
  void set_signal_id(const ::std::string& value);
  #if LANG_CXX11
  void set_signal_id(::std::string&& value);
  #endif
  void set_signal_id(const char* value);
  void set_signal_id(const char* value, size_t size);
  ::std::string* mutable_signal_id();
  ::std::string* release_signal_id();
  void set_allocated_signal_id(::std::string* signal_id);

  // string state_name = 2;
  void clear_state_name();
  static const int kStateNameFieldNumber = 2;
  const ::std::string& state_name() const;
  void set_state_name(const ::std::string& value);
  #if LANG_CXX11
  void set_state_name(::std::string&& value);
  #endif
  void set_state_name(const char* value);
  void set_state_name(const char* value, size_t size);
  ::std::string* mutable_state_name();
  ::std::string* release_state_name();
  void set_allocated_state_name(::std::string* state_name);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Intersection.SignalState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signal_id_;
  ::google::protobuf::internal::ArenaStringPtr state_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Intersection_IntersectionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Intersection.IntersectionState) */ {
 public:
  Scenario_Intersection_IntersectionState();
  virtual ~Scenario_Intersection_IntersectionState();

  Scenario_Intersection_IntersectionState(const Scenario_Intersection_IntersectionState& from);

  inline Scenario_Intersection_IntersectionState& operator=(const Scenario_Intersection_IntersectionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Intersection_IntersectionState(Scenario_Intersection_IntersectionState&& from) noexcept
    : Scenario_Intersection_IntersectionState() {
    *this = ::std::move(from);
  }

  inline Scenario_Intersection_IntersectionState& operator=(Scenario_Intersection_IntersectionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Intersection_IntersectionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Intersection_IntersectionState* internal_default_instance() {
    return reinterpret_cast<const Scenario_Intersection_IntersectionState*>(
               &_Scenario_Intersection_IntersectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Scenario_Intersection_IntersectionState* other);
  friend void swap(Scenario_Intersection_IntersectionState& a, Scenario_Intersection_IntersectionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Intersection_IntersectionState* New() const final {
    return CreateMaybeMessage<Scenario_Intersection_IntersectionState>(NULL);
  }

  Scenario_Intersection_IntersectionState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Intersection_IntersectionState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Intersection_IntersectionState& from);
  void MergeFrom(const Scenario_Intersection_IntersectionState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Intersection_IntersectionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Scenario.Intersection.SignalState signal_states = 2;
  int signal_states_size() const;
  void clear_signal_states();
  static const int kSignalStatesFieldNumber = 2;
  ::metamoto::types::Scenario_Intersection_SignalState* mutable_signal_states(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_SignalState >*
      mutable_signal_states();
  const ::metamoto::types::Scenario_Intersection_SignalState& signal_states(int index) const;
  ::metamoto::types::Scenario_Intersection_SignalState* add_signal_states();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_SignalState >&
      signal_states() const;

  // float duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Intersection.IntersectionState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_SignalState > signal_states_;
  float duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Intersection_Phase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Intersection.Phase) */ {
 public:
  Scenario_Intersection_Phase();
  virtual ~Scenario_Intersection_Phase();

  Scenario_Intersection_Phase(const Scenario_Intersection_Phase& from);

  inline Scenario_Intersection_Phase& operator=(const Scenario_Intersection_Phase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Intersection_Phase(Scenario_Intersection_Phase&& from) noexcept
    : Scenario_Intersection_Phase() {
    *this = ::std::move(from);
  }

  inline Scenario_Intersection_Phase& operator=(Scenario_Intersection_Phase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Intersection_Phase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Intersection_Phase* internal_default_instance() {
    return reinterpret_cast<const Scenario_Intersection_Phase*>(
               &_Scenario_Intersection_Phase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Scenario_Intersection_Phase* other);
  friend void swap(Scenario_Intersection_Phase& a, Scenario_Intersection_Phase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Intersection_Phase* New() const final {
    return CreateMaybeMessage<Scenario_Intersection_Phase>(NULL);
  }

  Scenario_Intersection_Phase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Intersection_Phase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Intersection_Phase& from);
  void MergeFrom(const Scenario_Intersection_Phase& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Intersection_Phase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Scenario.Intersection.IntersectionState intersection_states = 1;
  int intersection_states_size() const;
  void clear_intersection_states();
  static const int kIntersectionStatesFieldNumber = 1;
  ::metamoto::types::Scenario_Intersection_IntersectionState* mutable_intersection_states(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_IntersectionState >*
      mutable_intersection_states();
  const ::metamoto::types::Scenario_Intersection_IntersectionState& intersection_states(int index) const;
  ::metamoto::types::Scenario_Intersection_IntersectionState* add_intersection_states();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_IntersectionState >&
      intersection_states() const;

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Intersection.Phase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_IntersectionState > intersection_states_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_Intersection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario.Intersection) */ {
 public:
  Scenario_Intersection();
  virtual ~Scenario_Intersection();

  Scenario_Intersection(const Scenario_Intersection& from);

  inline Scenario_Intersection& operator=(const Scenario_Intersection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario_Intersection(Scenario_Intersection&& from) noexcept
    : Scenario_Intersection() {
    *this = ::std::move(from);
  }

  inline Scenario_Intersection& operator=(Scenario_Intersection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario_Intersection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario_Intersection* internal_default_instance() {
    return reinterpret_cast<const Scenario_Intersection*>(
               &_Scenario_Intersection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Scenario_Intersection* other);
  friend void swap(Scenario_Intersection& a, Scenario_Intersection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario_Intersection* New() const final {
    return CreateMaybeMessage<Scenario_Intersection>(NULL);
  }

  Scenario_Intersection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario_Intersection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario_Intersection& from);
  void MergeFrom(const Scenario_Intersection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario_Intersection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_Intersection_SignalState SignalState;
  typedef Scenario_Intersection_IntersectionState IntersectionState;
  typedef Scenario_Intersection_Phase Phase;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Scenario.Intersection.Phase phases = 1;
  int phases_size() const;
  void clear_phases();
  static const int kPhasesFieldNumber = 1;
  ::metamoto::types::Scenario_Intersection_Phase* mutable_phases(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_Phase >*
      mutable_phases();
  const ::metamoto::types::Scenario_Intersection_Phase& phases(int index) const;
  ::metamoto::types::Scenario_Intersection_Phase* add_phases();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_Phase >&
      phases() const;

  // string vector_id = 5;
  void clear_vector_id();
  static const int kVectorIdFieldNumber = 5;
  const ::std::string& vector_id() const;
  void set_vector_id(const ::std::string& value);
  #if LANG_CXX11
  void set_vector_id(::std::string&& value);
  #endif
  void set_vector_id(const char* value);
  void set_vector_id(const char* value, size_t size);
  ::std::string* mutable_vector_id();
  ::std::string* release_vector_id();
  void set_allocated_vector_id(::std::string* vector_id);

  // .metamoto.types.Vector3 position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  private:
  const ::metamoto::types::Vector3& _internal_position() const;
  public:
  const ::metamoto::types::Vector3& position() const;
  ::metamoto::types::Vector3* release_position();
  ::metamoto::types::Vector3* mutable_position();
  void set_allocated_position(::metamoto::types::Vector3* position);

  // int32 starting_phase_index = 2;
  void clear_starting_phase_index();
  static const int kStartingPhaseIndexFieldNumber = 2;
  ::google::protobuf::int32 starting_phase_index() const;
  void set_starting_phase_index(::google::protobuf::int32 value);

  // float starting_duration_offset = 3;
  void clear_starting_duration_offset();
  static const int kStartingDurationOffsetFieldNumber = 3;
  float starting_duration_offset() const;
  void set_starting_duration_offset(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario.Intersection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_Phase > phases_;
  ::google::protobuf::internal::ArenaStringPtr vector_id_;
  ::metamoto::types::Vector3* position_;
  ::google::protobuf::int32 starting_phase_index_;
  float starting_duration_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scenario_IntersectionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_IntersectionsEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_Intersection,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_IntersectionsEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Scenario_Intersection,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Scenario_IntersectionsEntry_DoNotUse();
  Scenario_IntersectionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_IntersectionsEntry_DoNotUse& other);
  static const Scenario_IntersectionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_IntersectionsEntry_DoNotUse*>(&_Scenario_IntersectionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario_RangesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Scenario_RangesEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Range,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Scenario_RangesEntry_DoNotUse, 
    ::std::string, ::metamoto::types::Range,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Scenario_RangesEntry_DoNotUse();
  Scenario_RangesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Scenario_RangesEntry_DoNotUse& other);
  static const Scenario_RangesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scenario_RangesEntry_DoNotUse*>(&_Scenario_RangesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Scenario : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Scenario) */ {
 public:
  Scenario();
  virtual ~Scenario();

  Scenario(const Scenario& from);

  inline Scenario& operator=(const Scenario& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario(Scenario&& from) noexcept
    : Scenario() {
    *this = ::std::move(from);
  }

  inline Scenario& operator=(Scenario&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario* internal_default_instance() {
    return reinterpret_cast<const Scenario*>(
               &_Scenario_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Scenario* other);
  friend void swap(Scenario& a, Scenario& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario* New() const final {
    return CreateMaybeMessage<Scenario>(NULL);
  }

  Scenario* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scenario>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scenario& from);
  void MergeFrom(const Scenario& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scenario* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scenario_System System;
  typedef Scenario_Objectives Objectives;
  typedef Scenario_EgoVehicle EgoVehicle;
  typedef Scenario_Traffic Traffic;
  typedef Scenario_Pedestrians Pedestrians;
  typedef Scenario_TrafficLight TrafficLight;
  typedef Scenario_Intersection Intersection;

  // accessors -------------------------------------------------------

  // map<string, .metamoto.types.Scenario.TrafficLight> traffic_lights = 12;
  int traffic_lights_size() const;
  void clear_traffic_lights();
  static const int kTrafficLightsFieldNumber = 12;
  const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_TrafficLight >&
      traffic_lights() const;
  ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_TrafficLight >*
      mutable_traffic_lights();

  // repeated .metamoto.types.Event events = 13;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 13;
  ::metamoto::types::Event* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Event >*
      mutable_events();
  const ::metamoto::types::Event& events(int index) const;
  ::metamoto::types::Event* add_events();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Event >&
      events() const;

  // repeated .metamoto.types.Asset assets = 14;
  int assets_size() const;
  void clear_assets();
  static const int kAssetsFieldNumber = 14;
  ::metamoto::types::Asset* mutable_assets(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Asset >*
      mutable_assets();
  const ::metamoto::types::Asset& assets(int index) const;
  ::metamoto::types::Asset* add_assets();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Asset >&
      assets() const;

  // repeated .metamoto.types.Scenario.EgoVehicle ego_vehicles = 15;
  int ego_vehicles_size() const;
  void clear_ego_vehicles();
  static const int kEgoVehiclesFieldNumber = 15;
  ::metamoto::types::Scenario_EgoVehicle* mutable_ego_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_EgoVehicle >*
      mutable_ego_vehicles();
  const ::metamoto::types::Scenario_EgoVehicle& ego_vehicles(int index) const;
  ::metamoto::types::Scenario_EgoVehicle* add_ego_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_EgoVehicle >&
      ego_vehicles() const;

  // map<string, .metamoto.types.Scenario.Intersection> intersections = 16;
  int intersections_size() const;
  void clear_intersections();
  static const int kIntersectionsFieldNumber = 16;
  const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_Intersection >&
      intersections() const;
  ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_Intersection >*
      mutable_intersections();

  // map<string, .metamoto.types.Range> ranges = 100;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 100;
  const ::google::protobuf::Map< ::std::string, ::metamoto::types::Range >&
      ranges() const;
  ::google::protobuf::Map< ::std::string, ::metamoto::types::Range >*
      mutable_ranges();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string scene = 3;
  void clear_scene();
  static const int kSceneFieldNumber = 3;
  const ::std::string& scene() const;
  void set_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_scene(::std::string&& value);
  #endif
  void set_scene(const char* value);
  void set_scene(const char* value, size_t size);
  ::std::string* mutable_scene();
  ::std::string* release_scene();
  void set_allocated_scene(::std::string* scene);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .metamoto.types.Scenario.System system = 6;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 6;
  private:
  const ::metamoto::types::Scenario_System& _internal_system() const;
  public:
  const ::metamoto::types::Scenario_System& system() const;
  ::metamoto::types::Scenario_System* release_system();
  ::metamoto::types::Scenario_System* mutable_system();
  void set_allocated_system(::metamoto::types::Scenario_System* system);

  // .metamoto.types.Scenario.Objectives objectives = 7;
  bool has_objectives() const;
  void clear_objectives();
  static const int kObjectivesFieldNumber = 7;
  private:
  const ::metamoto::types::Scenario_Objectives& _internal_objectives() const;
  public:
  const ::metamoto::types::Scenario_Objectives& objectives() const;
  ::metamoto::types::Scenario_Objectives* release_objectives();
  ::metamoto::types::Scenario_Objectives* mutable_objectives();
  void set_allocated_objectives(::metamoto::types::Scenario_Objectives* objectives);

  // .metamoto.types.Environment environment = 8;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 8;
  private:
  const ::metamoto::types::Environment& _internal_environment() const;
  public:
  const ::metamoto::types::Environment& environment() const;
  ::metamoto::types::Environment* release_environment();
  ::metamoto::types::Environment* mutable_environment();
  void set_allocated_environment(::metamoto::types::Environment* environment);

  // .metamoto.types.Scenario.EgoVehicle ego_vehicle = 9;
  bool has_ego_vehicle() const;
  void clear_ego_vehicle();
  static const int kEgoVehicleFieldNumber = 9;
  private:
  const ::metamoto::types::Scenario_EgoVehicle& _internal_ego_vehicle() const;
  public:
  const ::metamoto::types::Scenario_EgoVehicle& ego_vehicle() const;
  ::metamoto::types::Scenario_EgoVehicle* release_ego_vehicle();
  ::metamoto::types::Scenario_EgoVehicle* mutable_ego_vehicle();
  void set_allocated_ego_vehicle(::metamoto::types::Scenario_EgoVehicle* ego_vehicle);

  // .metamoto.types.Scenario.Traffic traffic = 10;
  bool has_traffic() const;
  void clear_traffic();
  static const int kTrafficFieldNumber = 10;
  private:
  const ::metamoto::types::Scenario_Traffic& _internal_traffic() const;
  public:
  const ::metamoto::types::Scenario_Traffic& traffic() const;
  ::metamoto::types::Scenario_Traffic* release_traffic();
  ::metamoto::types::Scenario_Traffic* mutable_traffic();
  void set_allocated_traffic(::metamoto::types::Scenario_Traffic* traffic);

  // .metamoto.types.Scenario.Pedestrians pedestrians = 11;
  bool has_pedestrians() const;
  void clear_pedestrians();
  static const int kPedestriansFieldNumber = 11;
  private:
  const ::metamoto::types::Scenario_Pedestrians& _internal_pedestrians() const;
  public:
  const ::metamoto::types::Scenario_Pedestrians& pedestrians() const;
  ::metamoto::types::Scenario_Pedestrians* release_pedestrians();
  ::metamoto::types::Scenario_Pedestrians* mutable_pedestrians();
  void set_allocated_pedestrians(::metamoto::types::Scenario_Pedestrians* pedestrians);

  // .metamoto.types.Version version = 17;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 17;
  private:
  const ::metamoto::types::Version& _internal_version() const;
  public:
  const ::metamoto::types::Version& version() const;
  ::metamoto::types::Version* release_version();
  ::metamoto::types::Version* mutable_version();
  void set_allocated_version(::metamoto::types::Version* version);

  // bool read_only = 5;
  void clear_read_only();
  static const int kReadOnlyFieldNumber = 5;
  bool read_only() const;
  void set_read_only(bool value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Scenario)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Scenario_TrafficLightsEntry_DoNotUse,
      ::std::string, ::metamoto::types::Scenario_TrafficLight,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > traffic_lights_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Event > events_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Asset > assets_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_EgoVehicle > ego_vehicles_;
  ::google::protobuf::internal::MapField<
      Scenario_IntersectionsEntry_DoNotUse,
      ::std::string, ::metamoto::types::Scenario_Intersection,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > intersections_;
  ::google::protobuf::internal::MapField<
      Scenario_RangesEntry_DoNotUse,
      ::std::string, ::metamoto::types::Range,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > ranges_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr scene_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::metamoto::types::Scenario_System* system_;
  ::metamoto::types::Scenario_Objectives* objectives_;
  ::metamoto::types::Environment* environment_;
  ::metamoto::types::Scenario_EgoVehicle* ego_vehicle_;
  ::metamoto::types::Scenario_Traffic* traffic_;
  ::metamoto::types::Scenario_Pedestrians* pedestrians_;
  ::metamoto::types::Version* version_;
  bool read_only_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Infraction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Infraction) */ {
 public:
  Infraction();
  virtual ~Infraction();

  Infraction(const Infraction& from);

  inline Infraction& operator=(const Infraction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Infraction(Infraction&& from) noexcept
    : Infraction() {
    *this = ::std::move(from);
  }

  inline Infraction& operator=(Infraction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Infraction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Infraction* internal_default_instance() {
    return reinterpret_cast<const Infraction*>(
               &_Infraction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Infraction* other);
  friend void swap(Infraction& a, Infraction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Infraction* New() const final {
    return CreateMaybeMessage<Infraction>(NULL);
  }

  Infraction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Infraction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Infraction& from);
  void MergeFrom(const Infraction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Infraction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Infraction_Type Type;
  static const Type UNKNOWN =
    Infraction_Type_UNKNOWN;
  static const Type OTHER =
    Infraction_Type_OTHER;
  static const Type VEHICLE_COLLISION =
    Infraction_Type_VEHICLE_COLLISION;
  static const Type PEDESTRIAN_COLLISION =
    Infraction_Type_PEDESTRIAN_COLLISION;
  static const Type ENVIRONMENT_COLLISION =
    Infraction_Type_ENVIRONMENT_COLLISION;
  static const Type OBSTACLE_COLLISION =
    Infraction_Type_OBSTACLE_COLLISION;
  static const Type TRAFFIC_LIGHT =
    Infraction_Type_TRAFFIC_LIGHT;
  static const Type STOP_SIGN =
    Infraction_Type_STOP_SIGN;
  static const Type SPEED_LIMIT =
    Infraction_Type_SPEED_LIMIT;
  static const Type HARD_BRAKE =
    Infraction_Type_HARD_BRAKE;
  static const Type WRONG_WAY =
    Infraction_Type_WRONG_WAY;
  static const Type OFF_ROAD =
    Infraction_Type_OFF_ROAD;
  static const Type EXTERNAL_WARNING =
    Infraction_Type_EXTERNAL_WARNING;
  static const Type EXTERNAL_FAILURE =
    Infraction_Type_EXTERNAL_FAILURE;
  static const Type EXTERNAL_PASS =
    Infraction_Type_EXTERNAL_PASS;
  static const Type EXTERNAL_STOP =
    Infraction_Type_EXTERNAL_STOP;
  static inline bool Type_IsValid(int value) {
    return Infraction_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Infraction_Type_Type_MIN;
  static const Type Type_MAX =
    Infraction_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Infraction_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Infraction_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Infraction_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Infraction_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.FloatValue other_values = 4;
  int other_values_size() const;
  void clear_other_values();
  static const int kOtherValuesFieldNumber = 4;
  ::google::protobuf::FloatValue* mutable_other_values(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::FloatValue >*
      mutable_other_values();
  const ::google::protobuf::FloatValue& other_values(int index) const;
  ::google::protobuf::FloatValue* add_other_values();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::FloatValue >&
      other_values() const;

  // .google.protobuf.FloatValue fail_value = 2;
  bool has_fail_value() const;
  void clear_fail_value();
  static const int kFailValueFieldNumber = 2;
  private:
  const ::google::protobuf::FloatValue& _internal_fail_value() const;
  public:
  const ::google::protobuf::FloatValue& fail_value() const;
  ::google::protobuf::FloatValue* release_fail_value();
  ::google::protobuf::FloatValue* mutable_fail_value();
  void set_allocated_fail_value(::google::protobuf::FloatValue* fail_value);

  // .google.protobuf.FloatValue stop_value = 3;
  bool has_stop_value() const;
  void clear_stop_value();
  static const int kStopValueFieldNumber = 3;
  private:
  const ::google::protobuf::FloatValue& _internal_stop_value() const;
  public:
  const ::google::protobuf::FloatValue& stop_value() const;
  ::google::protobuf::FloatValue* release_stop_value();
  ::google::protobuf::FloatValue* mutable_stop_value();
  void set_allocated_stop_value(::google::protobuf::FloatValue* stop_value);

  // .metamoto.types.Infraction.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::metamoto::types::Infraction_Type type() const;
  void set_type(::metamoto::types::Infraction_Type value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Infraction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::FloatValue > other_values_;
  ::google::protobuf::FloatValue* fail_value_;
  ::google::protobuf::FloatValue* stop_value_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DriverModel_BrakingBehavior : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.DriverModel.BrakingBehavior) */ {
 public:
  DriverModel_BrakingBehavior();
  virtual ~DriverModel_BrakingBehavior();

  DriverModel_BrakingBehavior(const DriverModel_BrakingBehavior& from);

  inline DriverModel_BrakingBehavior& operator=(const DriverModel_BrakingBehavior& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DriverModel_BrakingBehavior(DriverModel_BrakingBehavior&& from) noexcept
    : DriverModel_BrakingBehavior() {
    *this = ::std::move(from);
  }

  inline DriverModel_BrakingBehavior& operator=(DriverModel_BrakingBehavior&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DriverModel_BrakingBehavior& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DriverModel_BrakingBehavior* internal_default_instance() {
    return reinterpret_cast<const DriverModel_BrakingBehavior*>(
               &_DriverModel_BrakingBehavior_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(DriverModel_BrakingBehavior* other);
  friend void swap(DriverModel_BrakingBehavior& a, DriverModel_BrakingBehavior& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DriverModel_BrakingBehavior* New() const final {
    return CreateMaybeMessage<DriverModel_BrakingBehavior>(NULL);
  }

  DriverModel_BrakingBehavior* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DriverModel_BrakingBehavior>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DriverModel_BrakingBehavior& from);
  void MergeFrom(const DriverModel_BrakingBehavior& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DriverModel_BrakingBehavior* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float coast_speed_threshold = 1;
  void clear_coast_speed_threshold();
  static const int kCoastSpeedThresholdFieldNumber = 1;
  float coast_speed_threshold() const;
  void set_coast_speed_threshold(float value);

  // float min_brake = 2;
  void clear_min_brake();
  static const int kMinBrakeFieldNumber = 2;
  float min_brake() const;
  void set_min_brake(float value);

  // float coast_deceleration_threshold = 7;
  void clear_coast_deceleration_threshold();
  static const int kCoastDecelerationThresholdFieldNumber = 7;
  float coast_deceleration_threshold() const;
  void set_coast_deceleration_threshold(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.DriverModel.BrakingBehavior)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float coast_speed_threshold_;
  float min_brake_;
  float coast_deceleration_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DriverModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.DriverModel) */ {
 public:
  DriverModel();
  virtual ~DriverModel();

  DriverModel(const DriverModel& from);

  inline DriverModel& operator=(const DriverModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DriverModel(DriverModel&& from) noexcept
    : DriverModel() {
    *this = ::std::move(from);
  }

  inline DriverModel& operator=(DriverModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DriverModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DriverModel* internal_default_instance() {
    return reinterpret_cast<const DriverModel*>(
               &_DriverModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(DriverModel* other);
  friend void swap(DriverModel& a, DriverModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DriverModel* New() const final {
    return CreateMaybeMessage<DriverModel>(NULL);
  }

  DriverModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DriverModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DriverModel& from);
  void MergeFrom(const DriverModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DriverModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DriverModel_BrakingBehavior BrakingBehavior;

  // accessors -------------------------------------------------------

  // .metamoto.types.DriverModel.BrakingBehavior braking_behavior = 9;
  bool has_braking_behavior() const;
  void clear_braking_behavior();
  static const int kBrakingBehaviorFieldNumber = 9;
  private:
  const ::metamoto::types::DriverModel_BrakingBehavior& _internal_braking_behavior() const;
  public:
  const ::metamoto::types::DriverModel_BrakingBehavior& braking_behavior() const;
  ::metamoto::types::DriverModel_BrakingBehavior* release_braking_behavior();
  ::metamoto::types::DriverModel_BrakingBehavior* mutable_braking_behavior();
  void set_allocated_braking_behavior(::metamoto::types::DriverModel_BrakingBehavior* braking_behavior);

  // float collision_avoidance = 1;
  void clear_collision_avoidance();
  static const int kCollisionAvoidanceFieldNumber = 1;
  float collision_avoidance() const;
  void set_collision_avoidance(float value);

  // float speed_coefficient = 2;
  void clear_speed_coefficient();
  static const int kSpeedCoefficientFieldNumber = 2;
  float speed_coefficient() const;
  void set_speed_coefficient(float value);

  // bool obeys_lights = 3;
  void clear_obeys_lights();
  static const int kObeysLightsFieldNumber = 3;
  bool obeys_lights() const;
  void set_obeys_lights(bool value);

  // bool random_path = 4;
  void clear_random_path();
  static const int kRandomPathFieldNumber = 4;
  bool random_path() const;
  void set_random_path(bool value);

  // float lane_change_optimization = 5;
  void clear_lane_change_optimization();
  static const int kLaneChangeOptimizationFieldNumber = 5;
  float lane_change_optimization() const;
  void set_lane_change_optimization(float value);

  // float lane_center_deviation = 6;
  void clear_lane_center_deviation();
  static const int kLaneCenterDeviationFieldNumber = 6;
  float lane_center_deviation() const;
  void set_lane_center_deviation(float value);

  // float timegap_multiplier = 7;
  void clear_timegap_multiplier();
  static const int kTimegapMultiplierFieldNumber = 7;
  float timegap_multiplier() const;
  void set_timegap_multiplier(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.DriverModel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::DriverModel_BrakingBehavior* braking_behavior_;
  float collision_avoidance_;
  float speed_coefficient_;
  bool obeys_lights_;
  bool random_path_;
  float lane_change_optimization_;
  float lane_center_deviation_;
  float timegap_multiplier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficFlow_LaneSpan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.TrafficFlow.LaneSpan) */ {
 public:
  TrafficFlow_LaneSpan();
  virtual ~TrafficFlow_LaneSpan();

  TrafficFlow_LaneSpan(const TrafficFlow_LaneSpan& from);

  inline TrafficFlow_LaneSpan& operator=(const TrafficFlow_LaneSpan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficFlow_LaneSpan(TrafficFlow_LaneSpan&& from) noexcept
    : TrafficFlow_LaneSpan() {
    *this = ::std::move(from);
  }

  inline TrafficFlow_LaneSpan& operator=(TrafficFlow_LaneSpan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficFlow_LaneSpan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficFlow_LaneSpan* internal_default_instance() {
    return reinterpret_cast<const TrafficFlow_LaneSpan*>(
               &_TrafficFlow_LaneSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TrafficFlow_LaneSpan* other);
  friend void swap(TrafficFlow_LaneSpan& a, TrafficFlow_LaneSpan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficFlow_LaneSpan* New() const final {
    return CreateMaybeMessage<TrafficFlow_LaneSpan>(NULL);
  }

  TrafficFlow_LaneSpan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficFlow_LaneSpan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficFlow_LaneSpan& from);
  void MergeFrom(const TrafficFlow_LaneSpan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlow_LaneSpan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 lanes = 3;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 3;
  ::google::protobuf::int32 lanes(int index) const;
  void set_lanes(int index, ::google::protobuf::int32 value);
  void add_lanes(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lanes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lanes();

  // repeated .metamoto.types.Vector3 positions = 4;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 4;
  ::metamoto::types::Vector3* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
      mutable_positions();
  const ::metamoto::types::Vector3& positions(int index) const;
  ::metamoto::types::Vector3* add_positions();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
      positions() const;

  // string road_id = 1;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 1;
  const ::std::string& road_id() const;
  void set_road_id(const ::std::string& value);
  #if LANG_CXX11
  void set_road_id(::std::string&& value);
  #endif
  void set_road_id(const char* value);
  void set_road_id(const char* value, size_t size);
  ::std::string* mutable_road_id();
  ::std::string* release_road_id();
  void set_allocated_road_id(::std::string* road_id);

  // float s = 2;
  void clear_s();
  static const int kSFieldNumber = 2;
  float s() const;
  void set_s(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.TrafficFlow.LaneSpan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lanes_;
  mutable int _lanes_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 > positions_;
  ::google::protobuf::internal::ArenaStringPtr road_id_;
  float s_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficFlow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.TrafficFlow) */ {
 public:
  TrafficFlow();
  virtual ~TrafficFlow();

  TrafficFlow(const TrafficFlow& from);

  inline TrafficFlow& operator=(const TrafficFlow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficFlow(TrafficFlow&& from) noexcept
    : TrafficFlow() {
    *this = ::std::move(from);
  }

  inline TrafficFlow& operator=(TrafficFlow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficFlow* internal_default_instance() {
    return reinterpret_cast<const TrafficFlow*>(
               &_TrafficFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TrafficFlow* other);
  friend void swap(TrafficFlow& a, TrafficFlow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficFlow* New() const final {
    return CreateMaybeMessage<TrafficFlow>(NULL);
  }

  TrafficFlow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficFlow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficFlow& from);
  void MergeFrom(const TrafficFlow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficFlow_LaneSpan LaneSpan;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.TrafficFlow.LaneSpan sinks = 3;
  int sinks_size() const;
  void clear_sinks();
  static const int kSinksFieldNumber = 3;
  ::metamoto::types::TrafficFlow_LaneSpan* mutable_sinks(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow_LaneSpan >*
      mutable_sinks();
  const ::metamoto::types::TrafficFlow_LaneSpan& sinks(int index) const;
  ::metamoto::types::TrafficFlow_LaneSpan* add_sinks();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow_LaneSpan >&
      sinks() const;

  // .metamoto.types.TrafficFlow.LaneSpan source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  private:
  const ::metamoto::types::TrafficFlow_LaneSpan& _internal_source() const;
  public:
  const ::metamoto::types::TrafficFlow_LaneSpan& source() const;
  ::metamoto::types::TrafficFlow_LaneSpan* release_source();
  ::metamoto::types::TrafficFlow_LaneSpan* mutable_source();
  void set_allocated_source(::metamoto::types::TrafficFlow_LaneSpan* source);

  // .metamoto.types.NormalDistribution generation_rate = 4;
  bool has_generation_rate() const;
  void clear_generation_rate();
  static const int kGenerationRateFieldNumber = 4;
  private:
  const ::metamoto::types::NormalDistribution& _internal_generation_rate() const;
  public:
  const ::metamoto::types::NormalDistribution& generation_rate() const;
  ::metamoto::types::NormalDistribution* release_generation_rate();
  ::metamoto::types::NormalDistribution* mutable_generation_rate();
  void set_allocated_generation_rate(::metamoto::types::NormalDistribution* generation_rate);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // float speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // bool populate = 6;
  void clear_populate();
  static const int kPopulateFieldNumber = 6;
  bool populate() const;
  void set_populate(bool value);

  // @@protoc_insertion_point(class_scope:metamoto.types.TrafficFlow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow_LaneSpan > sinks_;
  ::metamoto::types::TrafficFlow_LaneSpan* source_;
  ::metamoto::types::NormalDistribution* generation_rate_;
  ::google::protobuf::int32 id_;
  float speed_;
  bool populate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficVehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.TrafficVehicle) */ {
 public:
  TrafficVehicle();
  virtual ~TrafficVehicle();

  TrafficVehicle(const TrafficVehicle& from);

  inline TrafficVehicle& operator=(const TrafficVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficVehicle(TrafficVehicle&& from) noexcept
    : TrafficVehicle() {
    *this = ::std::move(from);
  }

  inline TrafficVehicle& operator=(TrafficVehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficVehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficVehicle* internal_default_instance() {
    return reinterpret_cast<const TrafficVehicle*>(
               &_TrafficVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(TrafficVehicle* other);
  friend void swap(TrafficVehicle& a, TrafficVehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficVehicle* New() const final {
    return CreateMaybeMessage<TrafficVehicle>(NULL);
  }

  TrafficVehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficVehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficVehicle& from);
  void MergeFrom(const TrafficVehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficVehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Waypoint path = 3;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 3;
  ::metamoto::types::Waypoint* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
      mutable_path();
  const ::metamoto::types::Waypoint& path(int index) const;
  ::metamoto::types::Waypoint* add_path();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
      path() const;

  // string display_name = 1;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 1;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // .metamoto.types.VehicleInstance instance = 2;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 2;
  private:
  const ::metamoto::types::VehicleInstance& _internal_instance() const;
  public:
  const ::metamoto::types::VehicleInstance& instance() const;
  ::metamoto::types::VehicleInstance* release_instance();
  ::metamoto::types::VehicleInstance* mutable_instance();
  void set_allocated_instance(::metamoto::types::VehicleInstance* instance);

  // .metamoto.types.DriverModel driver_model = 4;
  bool has_driver_model() const;
  void clear_driver_model();
  static const int kDriverModelFieldNumber = 4;
  private:
  const ::metamoto::types::DriverModel& _internal_driver_model() const;
  public:
  const ::metamoto::types::DriverModel& driver_model() const;
  ::metamoto::types::DriverModel* release_driver_model();
  ::metamoto::types::DriverModel* mutable_driver_model();
  void set_allocated_driver_model(::metamoto::types::DriverModel* driver_model);

  // int32 flow_id = 5;
  void clear_flow_id();
  static const int kFlowIdFieldNumber = 5;
  ::google::protobuf::int32 flow_id() const;
  void set_flow_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.TrafficVehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint > path_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::metamoto::types::VehicleInstance* instance_;
  ::metamoto::types::DriverModel* driver_model_;
  ::google::protobuf::int32 flow_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkedVehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.ParkedVehicle) */ {
 public:
  ParkedVehicle();
  virtual ~ParkedVehicle();

  ParkedVehicle(const ParkedVehicle& from);

  inline ParkedVehicle& operator=(const ParkedVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkedVehicle(ParkedVehicle&& from) noexcept
    : ParkedVehicle() {
    *this = ::std::move(from);
  }

  inline ParkedVehicle& operator=(ParkedVehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkedVehicle& default_instance();

  enum PointOneofCase {
    kWorldPoint = 3,
    kRoadPoint = 4,
    POINT_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkedVehicle* internal_default_instance() {
    return reinterpret_cast<const ParkedVehicle*>(
               &_ParkedVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ParkedVehicle* other);
  friend void swap(ParkedVehicle& a, ParkedVehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkedVehicle* New() const final {
    return CreateMaybeMessage<ParkedVehicle>(NULL);
  }

  ParkedVehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParkedVehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParkedVehicle& from);
  void MergeFrom(const ParkedVehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkedVehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string display_name = 1;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 1;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // .metamoto.types.VehicleInstance instance = 2;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 2;
  private:
  const ::metamoto::types::VehicleInstance& _internal_instance() const;
  public:
  const ::metamoto::types::VehicleInstance& instance() const;
  ::metamoto::types::VehicleInstance* release_instance();
  ::metamoto::types::VehicleInstance* mutable_instance();
  void set_allocated_instance(::metamoto::types::VehicleInstance* instance);

  // .metamoto.types.Pose world_point = 3;
  bool has_world_point() const;
  void clear_world_point();
  static const int kWorldPointFieldNumber = 3;
  private:
  const ::metamoto::types::Pose& _internal_world_point() const;
  public:
  const ::metamoto::types::Pose& world_point() const;
  ::metamoto::types::Pose* release_world_point();
  ::metamoto::types::Pose* mutable_world_point();
  void set_allocated_world_point(::metamoto::types::Pose* world_point);

  // .metamoto.types.RoadPoint road_point = 4;
  bool has_road_point() const;
  void clear_road_point();
  static const int kRoadPointFieldNumber = 4;
  private:
  const ::metamoto::types::RoadPoint& _internal_road_point() const;
  public:
  const ::metamoto::types::RoadPoint& road_point() const;
  ::metamoto::types::RoadPoint* release_road_point();
  ::metamoto::types::RoadPoint* mutable_road_point();
  void set_allocated_road_point(::metamoto::types::RoadPoint* road_point);

  void clear_point_oneof();
  PointOneofCase point_oneof_case() const;
  // @@protoc_insertion_point(class_scope:metamoto.types.ParkedVehicle)
 private:
  void set_has_world_point();
  void set_has_road_point();

  inline bool has_point_oneof() const;
  inline void clear_has_point_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::metamoto::types::VehicleInstance* instance_;
  union PointOneofUnion {
    PointOneofUnion() {}
    ::metamoto::types::Pose* world_point_;
    ::metamoto::types::RoadPoint* road_point_;
  } point_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PedestrianConfiguration_PathPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.PedestrianConfiguration.PathPoint) */ {
 public:
  PedestrianConfiguration_PathPoint();
  virtual ~PedestrianConfiguration_PathPoint();

  PedestrianConfiguration_PathPoint(const PedestrianConfiguration_PathPoint& from);

  inline PedestrianConfiguration_PathPoint& operator=(const PedestrianConfiguration_PathPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PedestrianConfiguration_PathPoint(PedestrianConfiguration_PathPoint&& from) noexcept
    : PedestrianConfiguration_PathPoint() {
    *this = ::std::move(from);
  }

  inline PedestrianConfiguration_PathPoint& operator=(PedestrianConfiguration_PathPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PedestrianConfiguration_PathPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PedestrianConfiguration_PathPoint* internal_default_instance() {
    return reinterpret_cast<const PedestrianConfiguration_PathPoint*>(
               &_PedestrianConfiguration_PathPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(PedestrianConfiguration_PathPoint* other);
  friend void swap(PedestrianConfiguration_PathPoint& a, PedestrianConfiguration_PathPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PedestrianConfiguration_PathPoint* New() const final {
    return CreateMaybeMessage<PedestrianConfiguration_PathPoint>(NULL);
  }

  PedestrianConfiguration_PathPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PedestrianConfiguration_PathPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PedestrianConfiguration_PathPoint& from);
  void MergeFrom(const PedestrianConfiguration_PathPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PedestrianConfiguration_PathPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 target_point = 3;
  bool has_target_point() const;
  void clear_target_point();
  static const int kTargetPointFieldNumber = 3;
  private:
  const ::metamoto::types::Vector3& _internal_target_point() const;
  public:
  const ::metamoto::types::Vector3& target_point() const;
  ::metamoto::types::Vector3* release_target_point();
  ::metamoto::types::Vector3* mutable_target_point();
  void set_allocated_target_point(::metamoto::types::Vector3* target_point);

  // .metamoto.types.PedestrianConfiguration.State state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::metamoto::types::PedestrianConfiguration_State state() const;
  void set_state(::metamoto::types::PedestrianConfiguration_State value);

  // uint32 state_variant = 2;
  void clear_state_variant();
  static const int kStateVariantFieldNumber = 2;
  ::google::protobuf::uint32 state_variant() const;
  void set_state_variant(::google::protobuf::uint32 value);

  // float wait_time = 4;
  void clear_wait_time();
  static const int kWaitTimeFieldNumber = 4;
  float wait_time() const;
  void set_wait_time(float value);

  // .metamoto.types.PedestrianConfiguration.PathingBehaviour pathing_behaviour = 5;
  void clear_pathing_behaviour();
  static const int kPathingBehaviourFieldNumber = 5;
  ::metamoto::types::PedestrianConfiguration_PathingBehaviour pathing_behaviour() const;
  void set_pathing_behaviour(::metamoto::types::PedestrianConfiguration_PathingBehaviour value);

  // @@protoc_insertion_point(class_scope:metamoto.types.PedestrianConfiguration.PathPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* target_point_;
  int state_;
  ::google::protobuf::uint32 state_variant_;
  float wait_time_;
  int pathing_behaviour_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PedestrianConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.PedestrianConfiguration) */ {
 public:
  PedestrianConfiguration();
  virtual ~PedestrianConfiguration();

  PedestrianConfiguration(const PedestrianConfiguration& from);

  inline PedestrianConfiguration& operator=(const PedestrianConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PedestrianConfiguration(PedestrianConfiguration&& from) noexcept
    : PedestrianConfiguration() {
    *this = ::std::move(from);
  }

  inline PedestrianConfiguration& operator=(PedestrianConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PedestrianConfiguration& default_instance();

  enum InstanceOneofCase {
    kName = 2,
    kType = 3,
    INSTANCE_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PedestrianConfiguration* internal_default_instance() {
    return reinterpret_cast<const PedestrianConfiguration*>(
               &_PedestrianConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(PedestrianConfiguration* other);
  friend void swap(PedestrianConfiguration& a, PedestrianConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PedestrianConfiguration* New() const final {
    return CreateMaybeMessage<PedestrianConfiguration>(NULL);
  }

  PedestrianConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PedestrianConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PedestrianConfiguration& from);
  void MergeFrom(const PedestrianConfiguration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PedestrianConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PedestrianConfiguration_PathPoint PathPoint;

  typedef PedestrianConfiguration_State State;
  static const State STATE_UNKNOWN =
    PedestrianConfiguration_State_STATE_UNKNOWN;
  static const State STATE_OTHER =
    PedestrianConfiguration_State_STATE_OTHER;
  static const State IDLE =
    PedestrianConfiguration_State_IDLE;
  static const State WALK =
    PedestrianConfiguration_State_WALK;
  static const State RUN =
    PedestrianConfiguration_State_RUN;
  static const State RUN_IN_PLACE =
    PedestrianConfiguration_State_RUN_IN_PLACE;
  static inline bool State_IsValid(int value) {
    return PedestrianConfiguration_State_IsValid(value);
  }
  static const State State_MIN =
    PedestrianConfiguration_State_State_MIN;
  static const State State_MAX =
    PedestrianConfiguration_State_State_MAX;
  static const int State_ARRAYSIZE =
    PedestrianConfiguration_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return PedestrianConfiguration_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return PedestrianConfiguration_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return PedestrianConfiguration_State_Parse(name, value);
  }

  typedef PedestrianConfiguration_PathingBehaviour PathingBehaviour;
  static const PathingBehaviour STANDARD =
    PedestrianConfiguration_PathingBehaviour_STANDARD;
  static const PathingBehaviour UNCONSTRAINED =
    PedestrianConfiguration_PathingBehaviour_UNCONSTRAINED;
  static inline bool PathingBehaviour_IsValid(int value) {
    return PedestrianConfiguration_PathingBehaviour_IsValid(value);
  }
  static const PathingBehaviour PathingBehaviour_MIN =
    PedestrianConfiguration_PathingBehaviour_PathingBehaviour_MIN;
  static const PathingBehaviour PathingBehaviour_MAX =
    PedestrianConfiguration_PathingBehaviour_PathingBehaviour_MAX;
  static const int PathingBehaviour_ARRAYSIZE =
    PedestrianConfiguration_PathingBehaviour_PathingBehaviour_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PathingBehaviour_descriptor() {
    return PedestrianConfiguration_PathingBehaviour_descriptor();
  }
  static inline const ::std::string& PathingBehaviour_Name(PathingBehaviour value) {
    return PedestrianConfiguration_PathingBehaviour_Name(value);
  }
  static inline bool PathingBehaviour_Parse(const ::std::string& name,
      PathingBehaviour* value) {
    return PedestrianConfiguration_PathingBehaviour_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.PedestrianConfiguration.PathPoint path = 4;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 4;
  ::metamoto::types::PedestrianConfiguration_PathPoint* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration_PathPoint >*
      mutable_path();
  const ::metamoto::types::PedestrianConfiguration_PathPoint& path(int index) const;
  ::metamoto::types::PedestrianConfiguration_PathPoint* add_path();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration_PathPoint >&
      path() const;

  // string display_name = 1;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 1;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // bool random_path = 5;
  void clear_random_path();
  static const int kRandomPathFieldNumber = 5;
  bool random_path() const;
  void set_random_path(bool value);

  // string name = 2;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .metamoto.types.Pedestrian.Type type = 3;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::metamoto::types::Pedestrian_Type type() const;
  void set_type(::metamoto::types::Pedestrian_Type value);

  void clear_instance_oneof();
  InstanceOneofCase instance_oneof_case() const;
  // @@protoc_insertion_point(class_scope:metamoto.types.PedestrianConfiguration)
 private:
  void set_has_name();
  void set_has_type();

  inline bool has_instance_oneof() const;
  inline void clear_has_instance_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration_PathPoint > path_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  bool random_path_;
  union InstanceOneofUnion {
    InstanceOneofUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
    int type_;
  } instance_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event_ProximityTrigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Event.ProximityTrigger) */ {
 public:
  Event_ProximityTrigger();
  virtual ~Event_ProximityTrigger();

  Event_ProximityTrigger(const Event_ProximityTrigger& from);

  inline Event_ProximityTrigger& operator=(const Event_ProximityTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_ProximityTrigger(Event_ProximityTrigger&& from) noexcept
    : Event_ProximityTrigger() {
    *this = ::std::move(from);
  }

  inline Event_ProximityTrigger& operator=(Event_ProximityTrigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_ProximityTrigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_ProximityTrigger* internal_default_instance() {
    return reinterpret_cast<const Event_ProximityTrigger*>(
               &_Event_ProximityTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(Event_ProximityTrigger* other);
  friend void swap(Event_ProximityTrigger& a, Event_ProximityTrigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_ProximityTrigger* New() const final {
    return CreateMaybeMessage<Event_ProximityTrigger>(NULL);
  }

  Event_ProximityTrigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_ProximityTrigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_ProximityTrigger& from);
  void MergeFrom(const Event_ProximityTrigger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_ProximityTrigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  private:
  const ::metamoto::types::Vector3& _internal_location() const;
  public:
  const ::metamoto::types::Vector3& location() const;
  ::metamoto::types::Vector3* release_location();
  ::metamoto::types::Vector3* mutable_location();
  void set_allocated_location(::metamoto::types::Vector3* location);

  // float radius = 2;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // int32 ego_vehicle_index = 3;
  void clear_ego_vehicle_index();
  static const int kEgoVehicleIndexFieldNumber = 3;
  ::google::protobuf::int32 ego_vehicle_index() const;
  void set_ego_vehicle_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Event.ProximityTrigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* location_;
  float radius_;
  ::google::protobuf::int32 ego_vehicle_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_ProximityTrigger ProximityTrigger;

  typedef Event_ObjectType ObjectType;
  static const ObjectType OBJECT_OTHER =
    Event_ObjectType_OBJECT_OTHER;
  static const ObjectType SENSOR =
    Event_ObjectType_SENSOR;
  static const ObjectType CONTROLLER =
    Event_ObjectType_CONTROLLER;
  static const ObjectType EGO_VEHICLE =
    Event_ObjectType_EGO_VEHICLE;
  static const ObjectType TRAFFIC_VEHICLE =
    Event_ObjectType_TRAFFIC_VEHICLE;
  static const ObjectType TRAFFIC_FLOW =
    Event_ObjectType_TRAFFIC_FLOW;
  static const ObjectType PEDESTRIAN =
    Event_ObjectType_PEDESTRIAN;
  static const ObjectType TRAFFIC_LIGHT =
    Event_ObjectType_TRAFFIC_LIGHT;
  static const ObjectType ENVIRONMENT =
    Event_ObjectType_ENVIRONMENT;
  static inline bool ObjectType_IsValid(int value) {
    return Event_ObjectType_IsValid(value);
  }
  static const ObjectType ObjectType_MIN =
    Event_ObjectType_ObjectType_MIN;
  static const ObjectType ObjectType_MAX =
    Event_ObjectType_ObjectType_MAX;
  static const int ObjectType_ARRAYSIZE =
    Event_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectType_descriptor() {
    return Event_ObjectType_descriptor();
  }
  static inline const ::std::string& ObjectType_Name(ObjectType value) {
    return Event_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(const ::std::string& name,
      ObjectType* value) {
    return Event_ObjectType_Parse(name, value);
  }

  typedef Event_Action Action;
  static const Action ACTION_OTHER =
    Event_Action_ACTION_OTHER;
  static const Action ACTIVATE =
    Event_Action_ACTIVATE;
  static const Action DEACTIVATE =
    Event_Action_DEACTIVATE;
  static const Action CREATE =
    Event_Action_CREATE;
  static const Action REMOVE =
    Event_Action_REMOVE;
  static const Action MODIFY =
    Event_Action_MODIFY;
  static const Action SEND =
    Event_Action_SEND;
  static inline bool Action_IsValid(int value) {
    return Event_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Event_Action_Action_MIN;
  static const Action Action_MAX =
    Event_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Event_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return Event_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return Event_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return Event_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string payload_string = 7;
  int payload_string_size() const;
  void clear_payload_string();
  static const int kPayloadStringFieldNumber = 7;
  const ::std::string& payload_string(int index) const;
  ::std::string* mutable_payload_string(int index);
  void set_payload_string(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_payload_string(int index, ::std::string&& value);
  #endif
  void set_payload_string(int index, const char* value);
  void set_payload_string(int index, const char* value, size_t size);
  ::std::string* add_payload_string();
  void add_payload_string(const ::std::string& value);
  #if LANG_CXX11
  void add_payload_string(::std::string&& value);
  #endif
  void add_payload_string(const char* value);
  void add_payload_string(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& payload_string() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_payload_string();

  // repeated float payload_float = 8;
  int payload_float_size() const;
  void clear_payload_float();
  static const int kPayloadFloatFieldNumber = 8;
  float payload_float(int index) const;
  void set_payload_float(int index, float value);
  void add_payload_float(float value);
  const ::google::protobuf::RepeatedField< float >&
      payload_float() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_payload_float();

  // repeated .metamoto.types.Waypoint waypoints = 9;
  int waypoints_size() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 9;
  ::metamoto::types::Waypoint* mutable_waypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
      mutable_waypoints();
  const ::metamoto::types::Waypoint& waypoints(int index) const;
  ::metamoto::types::Waypoint* add_waypoints();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
      waypoints() const;

  // string id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string secondary_id = 6;
  void clear_secondary_id();
  static const int kSecondaryIdFieldNumber = 6;
  const ::std::string& secondary_id() const;
  void set_secondary_id(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_id(::std::string&& value);
  #endif
  void set_secondary_id(const char* value);
  void set_secondary_id(const char* value, size_t size);
  ::std::string* mutable_secondary_id();
  ::std::string* release_secondary_id();
  void set_allocated_secondary_id(::std::string* secondary_id);

  // .metamoto.types.Event.ProximityTrigger trigger = 4;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 4;
  private:
  const ::metamoto::types::Event_ProximityTrigger& _internal_trigger() const;
  public:
  const ::metamoto::types::Event_ProximityTrigger& trigger() const;
  ::metamoto::types::Event_ProximityTrigger* release_trigger();
  ::metamoto::types::Event_ProximityTrigger* mutable_trigger();
  void set_allocated_trigger(::metamoto::types::Event_ProximityTrigger* trigger);

  // .metamoto.types.Event.ObjectType object_type = 1;
  void clear_object_type();
  static const int kObjectTypeFieldNumber = 1;
  ::metamoto::types::Event_ObjectType object_type() const;
  void set_object_type(::metamoto::types::Event_ObjectType value);

  // .metamoto.types.Event.Action action = 2;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::metamoto::types::Event_Action action() const;
  void set_action(::metamoto::types::Event_Action value);

  // double time = 3;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> payload_string_;
  ::google::protobuf::RepeatedField< float > payload_float_;
  mutable int _payload_float_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint > waypoints_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr secondary_id_;
  ::metamoto::types::Event_ProximityTrigger* trigger_;
  int object_type_;
  int action_;
  double time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2fscenario_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Scenario_System_Encoder

// string ffmpeg_exe = 1;
inline void Scenario_System_Encoder::clear_ffmpeg_exe() {
  ffmpeg_exe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Encoder::ffmpeg_exe() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
  return ffmpeg_exe_.GetNoArena();
}
inline void Scenario_System_Encoder::set_ffmpeg_exe(const ::std::string& value) {
  
  ffmpeg_exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
}
#if LANG_CXX11
inline void Scenario_System_Encoder::set_ffmpeg_exe(::std::string&& value) {
  
  ffmpeg_exe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
}
#endif
inline void Scenario_System_Encoder::set_ffmpeg_exe(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ffmpeg_exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
}
inline void Scenario_System_Encoder::set_ffmpeg_exe(const char* value, size_t size) {
  
  ffmpeg_exe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
}
inline ::std::string* Scenario_System_Encoder::mutable_ffmpeg_exe() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
  return ffmpeg_exe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Encoder::release_ffmpeg_exe() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
  
  return ffmpeg_exe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Encoder::set_allocated_ffmpeg_exe(::std::string* ffmpeg_exe) {
  if (ffmpeg_exe != NULL) {
    
  } else {
    
  }
  ffmpeg_exe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ffmpeg_exe);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Encoder.ffmpeg_exe)
}

// string ffmpeg_codec = 2;
inline void Scenario_System_Encoder::clear_ffmpeg_codec() {
  ffmpeg_codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Encoder::ffmpeg_codec() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
  return ffmpeg_codec_.GetNoArena();
}
inline void Scenario_System_Encoder::set_ffmpeg_codec(const ::std::string& value) {
  
  ffmpeg_codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
}
#if LANG_CXX11
inline void Scenario_System_Encoder::set_ffmpeg_codec(::std::string&& value) {
  
  ffmpeg_codec_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
}
#endif
inline void Scenario_System_Encoder::set_ffmpeg_codec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ffmpeg_codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
}
inline void Scenario_System_Encoder::set_ffmpeg_codec(const char* value, size_t size) {
  
  ffmpeg_codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
}
inline ::std::string* Scenario_System_Encoder::mutable_ffmpeg_codec() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
  return ffmpeg_codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Encoder::release_ffmpeg_codec() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
  
  return ffmpeg_codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Encoder::set_allocated_ffmpeg_codec(::std::string* ffmpeg_codec) {
  if (ffmpeg_codec != NULL) {
    
  } else {
    
  }
  ffmpeg_codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ffmpeg_codec);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Encoder.ffmpeg_codec)
}

// string ffmpeg_codec_options = 3;
inline void Scenario_System_Encoder::clear_ffmpeg_codec_options() {
  ffmpeg_codec_options_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Encoder::ffmpeg_codec_options() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
  return ffmpeg_codec_options_.GetNoArena();
}
inline void Scenario_System_Encoder::set_ffmpeg_codec_options(const ::std::string& value) {
  
  ffmpeg_codec_options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
}
#if LANG_CXX11
inline void Scenario_System_Encoder::set_ffmpeg_codec_options(::std::string&& value) {
  
  ffmpeg_codec_options_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
}
#endif
inline void Scenario_System_Encoder::set_ffmpeg_codec_options(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ffmpeg_codec_options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
}
inline void Scenario_System_Encoder::set_ffmpeg_codec_options(const char* value, size_t size) {
  
  ffmpeg_codec_options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
}
inline ::std::string* Scenario_System_Encoder::mutable_ffmpeg_codec_options() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
  return ffmpeg_codec_options_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Encoder::release_ffmpeg_codec_options() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
  
  return ffmpeg_codec_options_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Encoder::set_allocated_ffmpeg_codec_options(::std::string* ffmpeg_codec_options) {
  if (ffmpeg_codec_options != NULL) {
    
  } else {
    
  }
  ffmpeg_codec_options_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ffmpeg_codec_options);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Encoder.ffmpeg_codec_options)
}

// -------------------------------------------------------------------

// Scenario_System_Logger

// string mode = 1;
inline void Scenario_System_Logger::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Logger::mode() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Logger.mode)
  return mode_.GetNoArena();
}
inline void Scenario_System_Logger::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Logger.mode)
}
#if LANG_CXX11
inline void Scenario_System_Logger::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Logger.mode)
}
#endif
inline void Scenario_System_Logger::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Logger.mode)
}
inline void Scenario_System_Logger::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Logger.mode)
}
inline ::std::string* Scenario_System_Logger::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Logger.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Logger::release_mode() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Logger.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Logger::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Logger.mode)
}

// string filename = 2;
inline void Scenario_System_Logger::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Logger::filename() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Logger.filename)
  return filename_.GetNoArena();
}
inline void Scenario_System_Logger::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Logger.filename)
}
#if LANG_CXX11
inline void Scenario_System_Logger::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Logger.filename)
}
#endif
inline void Scenario_System_Logger::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Logger.filename)
}
inline void Scenario_System_Logger::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Logger.filename)
}
inline ::std::string* Scenario_System_Logger::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Logger.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Logger::release_filename() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Logger.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Logger::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Logger.filename)
}

// string address = 3;
inline void Scenario_System_Logger::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_Logger::address() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Logger.address)
  return address_.GetNoArena();
}
inline void Scenario_System_Logger::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Logger.address)
}
#if LANG_CXX11
inline void Scenario_System_Logger::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.Logger.address)
}
#endif
inline void Scenario_System_Logger::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.Logger.address)
}
inline void Scenario_System_Logger::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.Logger.address)
}
inline ::std::string* Scenario_System_Logger::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.Logger.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_Logger::release_address() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.Logger.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_Logger::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.Logger.address)
}

// int32 port = 4;
inline void Scenario_System_Logger::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 Scenario_System_Logger::port() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Logger.port)
  return port_;
}
inline void Scenario_System_Logger::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Logger.port)
}

// -------------------------------------------------------------------

// Scenario_System_RayTracer

// string url = 1;
inline void Scenario_System_RayTracer::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System_RayTracer::url() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.RayTracer.url)
  return url_.GetNoArena();
}
inline void Scenario_System_RayTracer::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.RayTracer.url)
}
#if LANG_CXX11
inline void Scenario_System_RayTracer::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.RayTracer.url)
}
#endif
inline void Scenario_System_RayTracer::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.RayTracer.url)
}
inline void Scenario_System_RayTracer::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.RayTracer.url)
}
inline ::std::string* Scenario_System_RayTracer::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.RayTracer.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System_RayTracer::release_url() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.RayTracer.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System_RayTracer::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.RayTracer.url)
}

// bool file_mode = 2;
inline void Scenario_System_RayTracer::clear_file_mode() {
  file_mode_ = false;
}
inline bool Scenario_System_RayTracer::file_mode() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.RayTracer.file_mode)
  return file_mode_;
}
inline void Scenario_System_RayTracer::set_file_mode(bool value) {
  
  file_mode_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.RayTracer.file_mode)
}

// int32 file_threshold = 3;
inline void Scenario_System_RayTracer::clear_file_threshold() {
  file_threshold_ = 0;
}
inline ::google::protobuf::int32 Scenario_System_RayTracer::file_threshold() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.RayTracer.file_threshold)
  return file_threshold_;
}
inline void Scenario_System_RayTracer::set_file_threshold(::google::protobuf::int32 value) {
  
  file_threshold_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.RayTracer.file_threshold)
}

// -------------------------------------------------------------------

// Scenario_System_Service

// int32 port = 1;
inline void Scenario_System_Service::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 Scenario_System_Service::port() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Service.port)
  return port_;
}
inline void Scenario_System_Service::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Service.port)
}

// int32 external_port = 2;
inline void Scenario_System_Service::clear_external_port() {
  external_port_ = 0;
}
inline ::google::protobuf::int32 Scenario_System_Service::external_port() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.Service.external_port)
  return external_port_;
}
inline void Scenario_System_Service::set_external_port(::google::protobuf::int32 value) {
  
  external_port_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.Service.external_port)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scenario_System

// int32 random_seed = 1;
inline void Scenario_System::clear_random_seed() {
  random_seed_ = 0;
}
inline ::google::protobuf::int32 Scenario_System::random_seed() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.random_seed)
  return random_seed_;
}
inline void Scenario_System::set_random_seed(::google::protobuf::int32 value) {
  
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.random_seed)
}

// string host = 2;
inline void Scenario_System::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_System::host() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.host)
  return host_.GetNoArena();
}
inline void Scenario_System::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.host)
}
#if LANG_CXX11
inline void Scenario_System::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.System.host)
}
#endif
inline void Scenario_System::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.System.host)
}
inline void Scenario_System::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.System.host)
}
inline ::std::string* Scenario_System::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_System::release_host() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_System::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.host)
}

// bool record_ground_truth = 3;
inline void Scenario_System::clear_record_ground_truth() {
  record_ground_truth_ = false;
}
inline bool Scenario_System::record_ground_truth() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.record_ground_truth)
  return record_ground_truth_;
}
inline void Scenario_System::set_record_ground_truth(bool value) {
  
  record_ground_truth_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.record_ground_truth)
}

// bool profile = 4;
inline void Scenario_System::clear_profile() {
  profile_ = false;
}
inline bool Scenario_System::profile() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.profile)
  return profile_;
}
inline void Scenario_System::set_profile(bool value) {
  
  profile_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.profile)
}

// float physics_rate = 5;
inline void Scenario_System::clear_physics_rate() {
  physics_rate_ = 0;
}
inline float Scenario_System::physics_rate() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.physics_rate)
  return physics_rate_;
}
inline void Scenario_System::set_physics_rate(float value) {
  
  physics_rate_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.physics_rate)
}

// .metamoto.types.Scenario.System.Encoder encoder = 6;
inline bool Scenario_System::has_encoder() const {
  return this != internal_default_instance() && encoder_ != NULL;
}
inline void Scenario_System::clear_encoder() {
  if (GetArenaNoVirtual() == NULL && encoder_ != NULL) {
    delete encoder_;
  }
  encoder_ = NULL;
}
inline const ::metamoto::types::Scenario_System_Encoder& Scenario_System::_internal_encoder() const {
  return *encoder_;
}
inline const ::metamoto::types::Scenario_System_Encoder& Scenario_System::encoder() const {
  const ::metamoto::types::Scenario_System_Encoder* p = encoder_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.encoder)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_System_Encoder*>(
      &::metamoto::types::_Scenario_System_Encoder_default_instance_);
}
inline ::metamoto::types::Scenario_System_Encoder* Scenario_System::release_encoder() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.encoder)
  
  ::metamoto::types::Scenario_System_Encoder* temp = encoder_;
  encoder_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_System_Encoder* Scenario_System::mutable_encoder() {
  
  if (encoder_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_System_Encoder>(GetArenaNoVirtual());
    encoder_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.encoder)
  return encoder_;
}
inline void Scenario_System::set_allocated_encoder(::metamoto::types::Scenario_System_Encoder* encoder) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encoder_;
  }
  if (encoder) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encoder = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encoder, submessage_arena);
    }
    
  } else {
    
  }
  encoder_ = encoder;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.encoder)
}

// .metamoto.types.Scenario.System.Logger logger = 7;
inline bool Scenario_System::has_logger() const {
  return this != internal_default_instance() && logger_ != NULL;
}
inline void Scenario_System::clear_logger() {
  if (GetArenaNoVirtual() == NULL && logger_ != NULL) {
    delete logger_;
  }
  logger_ = NULL;
}
inline const ::metamoto::types::Scenario_System_Logger& Scenario_System::_internal_logger() const {
  return *logger_;
}
inline const ::metamoto::types::Scenario_System_Logger& Scenario_System::logger() const {
  const ::metamoto::types::Scenario_System_Logger* p = logger_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.logger)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_System_Logger*>(
      &::metamoto::types::_Scenario_System_Logger_default_instance_);
}
inline ::metamoto::types::Scenario_System_Logger* Scenario_System::release_logger() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.logger)
  
  ::metamoto::types::Scenario_System_Logger* temp = logger_;
  logger_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_System_Logger* Scenario_System::mutable_logger() {
  
  if (logger_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_System_Logger>(GetArenaNoVirtual());
    logger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.logger)
  return logger_;
}
inline void Scenario_System::set_allocated_logger(::metamoto::types::Scenario_System_Logger* logger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logger_;
  }
  if (logger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logger, submessage_arena);
    }
    
  } else {
    
  }
  logger_ = logger;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.logger)
}

// .metamoto.types.Scenario.System.RayTracer ray_tracer = 8;
inline bool Scenario_System::has_ray_tracer() const {
  return this != internal_default_instance() && ray_tracer_ != NULL;
}
inline void Scenario_System::clear_ray_tracer() {
  if (GetArenaNoVirtual() == NULL && ray_tracer_ != NULL) {
    delete ray_tracer_;
  }
  ray_tracer_ = NULL;
}
inline const ::metamoto::types::Scenario_System_RayTracer& Scenario_System::_internal_ray_tracer() const {
  return *ray_tracer_;
}
inline const ::metamoto::types::Scenario_System_RayTracer& Scenario_System::ray_tracer() const {
  const ::metamoto::types::Scenario_System_RayTracer* p = ray_tracer_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.ray_tracer)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_System_RayTracer*>(
      &::metamoto::types::_Scenario_System_RayTracer_default_instance_);
}
inline ::metamoto::types::Scenario_System_RayTracer* Scenario_System::release_ray_tracer() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.System.ray_tracer)
  
  ::metamoto::types::Scenario_System_RayTracer* temp = ray_tracer_;
  ray_tracer_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_System_RayTracer* Scenario_System::mutable_ray_tracer() {
  
  if (ray_tracer_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_System_RayTracer>(GetArenaNoVirtual());
    ray_tracer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.System.ray_tracer)
  return ray_tracer_;
}
inline void Scenario_System::set_allocated_ray_tracer(::metamoto::types::Scenario_System_RayTracer* ray_tracer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ray_tracer_;
  }
  if (ray_tracer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ray_tracer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ray_tracer, submessage_arena);
    }
    
  } else {
    
  }
  ray_tracer_ = ray_tracer;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.System.ray_tracer)
}

// map<string, .metamoto.types.Scenario.System.Service> services = 9;
inline int Scenario_System::services_size() const {
  return services_.size();
}
inline void Scenario_System::clear_services() {
  services_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_System_Service >&
Scenario_System::services() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.System.services)
  return services_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_System_Service >*
Scenario_System::mutable_services() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.System.services)
  return services_.MutableMap();
}

// .metamoto.types.Scenario.System.LevelOfDetail camera_lod = 10;
inline void Scenario_System::clear_camera_lod() {
  camera_lod_ = 0;
}
inline ::metamoto::types::Scenario_System_LevelOfDetail Scenario_System::camera_lod() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.camera_lod)
  return static_cast< ::metamoto::types::Scenario_System_LevelOfDetail >(camera_lod_);
}
inline void Scenario_System::set_camera_lod(::metamoto::types::Scenario_System_LevelOfDetail value) {
  
  camera_lod_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.camera_lod)
}

// .metamoto.types.Scenario.System.LevelOfDetail ray_tracer_lod = 11;
inline void Scenario_System::clear_ray_tracer_lod() {
  ray_tracer_lod_ = 0;
}
inline ::metamoto::types::Scenario_System_LevelOfDetail Scenario_System::ray_tracer_lod() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.System.ray_tracer_lod)
  return static_cast< ::metamoto::types::Scenario_System_LevelOfDetail >(ray_tracer_lod_);
}
inline void Scenario_System::set_ray_tracer_lod(::metamoto::types::Scenario_System_LevelOfDetail value) {
  
  ray_tracer_lod_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.System.ray_tracer_lod)
}

// -------------------------------------------------------------------

// Scenario_Objectives

// float duration = 1;
inline void Scenario_Objectives::clear_duration() {
  duration_ = 0;
}
inline float Scenario_Objectives::duration() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.duration)
  return duration_;
}
inline void Scenario_Objectives::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Objectives.duration)
}

// .metamoto.types.Vector3 destination_world_point = 2;
inline bool Scenario_Objectives::has_destination_world_point() const {
  return destination_oneof_case() == kDestinationWorldPoint;
}
inline void Scenario_Objectives::set_has_destination_world_point() {
  _oneof_case_[0] = kDestinationWorldPoint;
}
inline const ::metamoto::types::Vector3& Scenario_Objectives::_internal_destination_world_point() const {
  return *destination_oneof_.destination_world_point_;
}
inline ::metamoto::types::Vector3* Scenario_Objectives::release_destination_world_point() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Objectives.destination_world_point)
  if (has_destination_world_point()) {
    clear_has_destination_oneof();
      ::metamoto::types::Vector3* temp = destination_oneof_.destination_world_point_;
    destination_oneof_.destination_world_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::metamoto::types::Vector3& Scenario_Objectives::destination_world_point() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.destination_world_point)
  return has_destination_world_point()
      ? *destination_oneof_.destination_world_point_
      : *reinterpret_cast< ::metamoto::types::Vector3*>(&::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Scenario_Objectives::mutable_destination_world_point() {
  if (!has_destination_world_point()) {
    clear_destination_oneof();
    set_has_destination_world_point();
    destination_oneof_.destination_world_point_ = CreateMaybeMessage< ::metamoto::types::Vector3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Objectives.destination_world_point)
  return destination_oneof_.destination_world_point_;
}

// .metamoto.types.RoadPoint destination_road_point = 3;
inline bool Scenario_Objectives::has_destination_road_point() const {
  return destination_oneof_case() == kDestinationRoadPoint;
}
inline void Scenario_Objectives::set_has_destination_road_point() {
  _oneof_case_[0] = kDestinationRoadPoint;
}
inline const ::metamoto::types::RoadPoint& Scenario_Objectives::_internal_destination_road_point() const {
  return *destination_oneof_.destination_road_point_;
}
inline ::metamoto::types::RoadPoint* Scenario_Objectives::release_destination_road_point() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Objectives.destination_road_point)
  if (has_destination_road_point()) {
    clear_has_destination_oneof();
      ::metamoto::types::RoadPoint* temp = destination_oneof_.destination_road_point_;
    destination_oneof_.destination_road_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::metamoto::types::RoadPoint& Scenario_Objectives::destination_road_point() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.destination_road_point)
  return has_destination_road_point()
      ? *destination_oneof_.destination_road_point_
      : *reinterpret_cast< ::metamoto::types::RoadPoint*>(&::metamoto::types::_RoadPoint_default_instance_);
}
inline ::metamoto::types::RoadPoint* Scenario_Objectives::mutable_destination_road_point() {
  if (!has_destination_road_point()) {
    clear_destination_oneof();
    set_has_destination_road_point();
    destination_oneof_.destination_road_point_ = CreateMaybeMessage< ::metamoto::types::RoadPoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Objectives.destination_road_point)
  return destination_oneof_.destination_road_point_;
}

// float destination_radius = 4;
inline void Scenario_Objectives::clear_destination_radius() {
  destination_radius_ = 0;
}
inline float Scenario_Objectives::destination_radius() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.destination_radius)
  return destination_radius_;
}
inline void Scenario_Objectives::set_destination_radius(float value) {
  
  destination_radius_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Objectives.destination_radius)
}

// repeated .metamoto.types.Infraction infractions = 5;
inline int Scenario_Objectives::infractions_size() const {
  return infractions_.size();
}
inline void Scenario_Objectives::clear_infractions() {
  infractions_.Clear();
}
inline ::metamoto::types::Infraction* Scenario_Objectives::mutable_infractions(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Objectives.infractions)
  return infractions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Infraction >*
Scenario_Objectives::mutable_infractions() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Objectives.infractions)
  return &infractions_;
}
inline const ::metamoto::types::Infraction& Scenario_Objectives::infractions(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.infractions)
  return infractions_.Get(index);
}
inline ::metamoto::types::Infraction* Scenario_Objectives::add_infractions() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Objectives.infractions)
  return infractions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Infraction >&
Scenario_Objectives::infractions() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Objectives.infractions)
  return infractions_;
}

// float random_failure_probability = 6;
inline void Scenario_Objectives::clear_random_failure_probability() {
  random_failure_probability_ = 0;
}
inline float Scenario_Objectives::random_failure_probability() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.random_failure_probability)
  return random_failure_probability_;
}
inline void Scenario_Objectives::set_random_failure_probability(float value) {
  
  random_failure_probability_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Objectives.random_failure_probability)
}

// bool monitor_all_vehicles = 7;
inline void Scenario_Objectives::clear_monitor_all_vehicles() {
  monitor_all_vehicles_ = false;
}
inline bool Scenario_Objectives::monitor_all_vehicles() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Objectives.monitor_all_vehicles)
  return monitor_all_vehicles_;
}
inline void Scenario_Objectives::set_monitor_all_vehicles(bool value) {
  
  monitor_all_vehicles_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Objectives.monitor_all_vehicles)
}

inline bool Scenario_Objectives::has_destination_oneof() const {
  return destination_oneof_case() != DESTINATION_ONEOF_NOT_SET;
}
inline void Scenario_Objectives::clear_has_destination_oneof() {
  _oneof_case_[0] = DESTINATION_ONEOF_NOT_SET;
}
inline Scenario_Objectives::DestinationOneofCase Scenario_Objectives::destination_oneof_case() const {
  return Scenario_Objectives::DestinationOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Scenario_EgoVehicle

// repeated .metamoto.types.Waypoint path = 1;
inline int Scenario_EgoVehicle::path_size() const {
  return path_.size();
}
inline ::metamoto::types::Waypoint* Scenario_EgoVehicle::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.EgoVehicle.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
Scenario_EgoVehicle::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.EgoVehicle.path)
  return &path_;
}
inline const ::metamoto::types::Waypoint& Scenario_EgoVehicle::path(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.EgoVehicle.path)
  return path_.Get(index);
}
inline ::metamoto::types::Waypoint* Scenario_EgoVehicle::add_path() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.EgoVehicle.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
Scenario_EgoVehicle::path() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.EgoVehicle.path)
  return path_;
}

// .metamoto.types.DriverModel driver_model = 2;
inline bool Scenario_EgoVehicle::has_driver_model() const {
  return this != internal_default_instance() && driver_model_ != NULL;
}
inline void Scenario_EgoVehicle::clear_driver_model() {
  if (GetArenaNoVirtual() == NULL && driver_model_ != NULL) {
    delete driver_model_;
  }
  driver_model_ = NULL;
}
inline const ::metamoto::types::DriverModel& Scenario_EgoVehicle::_internal_driver_model() const {
  return *driver_model_;
}
inline const ::metamoto::types::DriverModel& Scenario_EgoVehicle::driver_model() const {
  const ::metamoto::types::DriverModel* p = driver_model_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.EgoVehicle.driver_model)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::DriverModel*>(
      &::metamoto::types::_DriverModel_default_instance_);
}
inline ::metamoto::types::DriverModel* Scenario_EgoVehicle::release_driver_model() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.EgoVehicle.driver_model)
  
  ::metamoto::types::DriverModel* temp = driver_model_;
  driver_model_ = NULL;
  return temp;
}
inline ::metamoto::types::DriverModel* Scenario_EgoVehicle::mutable_driver_model() {
  
  if (driver_model_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::DriverModel>(GetArenaNoVirtual());
    driver_model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.EgoVehicle.driver_model)
  return driver_model_;
}
inline void Scenario_EgoVehicle::set_allocated_driver_model(::metamoto::types::DriverModel* driver_model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete driver_model_;
  }
  if (driver_model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      driver_model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, driver_model, submessage_arena);
    }
    
  } else {
    
  }
  driver_model_ = driver_model;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.EgoVehicle.driver_model)
}

// bool random_spawn_point = 3;
inline void Scenario_EgoVehicle::clear_random_spawn_point() {
  random_spawn_point_ = false;
}
inline bool Scenario_EgoVehicle::random_spawn_point() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.EgoVehicle.random_spawn_point)
  return random_spawn_point_;
}
inline void Scenario_EgoVehicle::set_random_spawn_point(bool value) {
  
  random_spawn_point_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.EgoVehicle.random_spawn_point)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scenario_Traffic_Distribution

// map<string, float> model_weights = 1;
inline int Scenario_Traffic_Distribution::model_weights_size() const {
  return model_weights_.size();
}
inline void Scenario_Traffic_Distribution::clear_model_weights() {
  model_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Traffic_Distribution::model_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Traffic.Distribution.model_weights)
  return model_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Traffic_Distribution::mutable_model_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Traffic.Distribution.model_weights)
  return model_weights_.MutableMap();
}

// map<string, float> type_weights = 2;
inline int Scenario_Traffic_Distribution::type_weights_size() const {
  return type_weights_.size();
}
inline void Scenario_Traffic_Distribution::clear_type_weights() {
  type_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Traffic_Distribution::type_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Traffic.Distribution.type_weights)
  return type_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Traffic_Distribution::mutable_type_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Traffic.Distribution.type_weights)
  return type_weights_.MutableMap();
}

// map<string, float> paint_weights = 3;
inline int Scenario_Traffic_Distribution::paint_weights_size() const {
  return paint_weights_.size();
}
inline void Scenario_Traffic_Distribution::clear_paint_weights() {
  paint_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Traffic_Distribution::paint_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Traffic.Distribution.paint_weights)
  return paint_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Traffic_Distribution::mutable_paint_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Traffic.Distribution.paint_weights)
  return paint_weights_.MutableMap();
}

// -------------------------------------------------------------------

// Scenario_Traffic

// repeated .metamoto.types.Vector3 region = 1;
inline int Scenario_Traffic::region_size() const {
  return region_.size();
}
inline ::metamoto::types::Vector3* Scenario_Traffic::mutable_region(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.region)
  return region_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
Scenario_Traffic::mutable_region() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Traffic.region)
  return &region_;
}
inline const ::metamoto::types::Vector3& Scenario_Traffic::region(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.region)
  return region_.Get(index);
}
inline ::metamoto::types::Vector3* Scenario_Traffic::add_region() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Traffic.region)
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
Scenario_Traffic::region() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Traffic.region)
  return region_;
}

// .metamoto.types.Scenario.Traffic.Distribution distribution = 2;
inline bool Scenario_Traffic::has_distribution() const {
  return this != internal_default_instance() && distribution_ != NULL;
}
inline void Scenario_Traffic::clear_distribution() {
  if (GetArenaNoVirtual() == NULL && distribution_ != NULL) {
    delete distribution_;
  }
  distribution_ = NULL;
}
inline const ::metamoto::types::Scenario_Traffic_Distribution& Scenario_Traffic::_internal_distribution() const {
  return *distribution_;
}
inline const ::metamoto::types::Scenario_Traffic_Distribution& Scenario_Traffic::distribution() const {
  const ::metamoto::types::Scenario_Traffic_Distribution* p = distribution_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.distribution)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Traffic_Distribution*>(
      &::metamoto::types::_Scenario_Traffic_Distribution_default_instance_);
}
inline ::metamoto::types::Scenario_Traffic_Distribution* Scenario_Traffic::release_distribution() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Traffic.distribution)
  
  ::metamoto::types::Scenario_Traffic_Distribution* temp = distribution_;
  distribution_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Traffic_Distribution* Scenario_Traffic::mutable_distribution() {
  
  if (distribution_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution>(GetArenaNoVirtual());
    distribution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.distribution)
  return distribution_;
}
inline void Scenario_Traffic::set_allocated_distribution(::metamoto::types::Scenario_Traffic_Distribution* distribution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distribution_;
  }
  if (distribution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distribution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distribution, submessage_arena);
    }
    
  } else {
    
  }
  distribution_ = distribution;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Traffic.distribution)
}

// int32 num_random_vehicles = 3;
inline bool Scenario_Traffic::has_num_random_vehicles() const {
  return random_oneof_case() == kNumRandomVehicles;
}
inline void Scenario_Traffic::set_has_num_random_vehicles() {
  _oneof_case_[0] = kNumRandomVehicles;
}
inline void Scenario_Traffic::clear_num_random_vehicles() {
  if (has_num_random_vehicles()) {
    random_oneof_.num_random_vehicles_ = 0;
    clear_has_random_oneof();
  }
}
inline ::google::protobuf::int32 Scenario_Traffic::num_random_vehicles() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.num_random_vehicles)
  if (has_num_random_vehicles()) {
    return random_oneof_.num_random_vehicles_;
  }
  return 0;
}
inline void Scenario_Traffic::set_num_random_vehicles(::google::protobuf::int32 value) {
  if (!has_num_random_vehicles()) {
    clear_random_oneof();
    set_has_num_random_vehicles();
  }
  random_oneof_.num_random_vehicles_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Traffic.num_random_vehicles)
}

// float congestion = 4;
inline bool Scenario_Traffic::has_congestion() const {
  return random_oneof_case() == kCongestion;
}
inline void Scenario_Traffic::set_has_congestion() {
  _oneof_case_[0] = kCongestion;
}
inline void Scenario_Traffic::clear_congestion() {
  if (has_congestion()) {
    random_oneof_.congestion_ = 0;
    clear_has_random_oneof();
  }
}
inline float Scenario_Traffic::congestion() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.congestion)
  if (has_congestion()) {
    return random_oneof_.congestion_;
  }
  return 0;
}
inline void Scenario_Traffic::set_congestion(float value) {
  if (!has_congestion()) {
    clear_random_oneof();
    set_has_congestion();
  }
  random_oneof_.congestion_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Traffic.congestion)
}

// repeated .metamoto.types.TrafficFlow flows = 5;
inline int Scenario_Traffic::flows_size() const {
  return flows_.size();
}
inline void Scenario_Traffic::clear_flows() {
  flows_.Clear();
}
inline ::metamoto::types::TrafficFlow* Scenario_Traffic::mutable_flows(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.flows)
  return flows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow >*
Scenario_Traffic::mutable_flows() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Traffic.flows)
  return &flows_;
}
inline const ::metamoto::types::TrafficFlow& Scenario_Traffic::flows(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.flows)
  return flows_.Get(index);
}
inline ::metamoto::types::TrafficFlow* Scenario_Traffic::add_flows() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Traffic.flows)
  return flows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow >&
Scenario_Traffic::flows() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Traffic.flows)
  return flows_;
}

// repeated .metamoto.types.TrafficVehicle vehicles = 6;
inline int Scenario_Traffic::vehicles_size() const {
  return vehicles_.size();
}
inline void Scenario_Traffic::clear_vehicles() {
  vehicles_.Clear();
}
inline ::metamoto::types::TrafficVehicle* Scenario_Traffic::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.vehicles)
  return vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficVehicle >*
Scenario_Traffic::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Traffic.vehicles)
  return &vehicles_;
}
inline const ::metamoto::types::TrafficVehicle& Scenario_Traffic::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.vehicles)
  return vehicles_.Get(index);
}
inline ::metamoto::types::TrafficVehicle* Scenario_Traffic::add_vehicles() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Traffic.vehicles)
  return vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficVehicle >&
Scenario_Traffic::vehicles() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Traffic.vehicles)
  return vehicles_;
}

// .metamoto.types.Scenario.Traffic.Distribution parked_distribution = 7;
inline bool Scenario_Traffic::has_parked_distribution() const {
  return this != internal_default_instance() && parked_distribution_ != NULL;
}
inline void Scenario_Traffic::clear_parked_distribution() {
  if (GetArenaNoVirtual() == NULL && parked_distribution_ != NULL) {
    delete parked_distribution_;
  }
  parked_distribution_ = NULL;
}
inline const ::metamoto::types::Scenario_Traffic_Distribution& Scenario_Traffic::_internal_parked_distribution() const {
  return *parked_distribution_;
}
inline const ::metamoto::types::Scenario_Traffic_Distribution& Scenario_Traffic::parked_distribution() const {
  const ::metamoto::types::Scenario_Traffic_Distribution* p = parked_distribution_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.parked_distribution)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Traffic_Distribution*>(
      &::metamoto::types::_Scenario_Traffic_Distribution_default_instance_);
}
inline ::metamoto::types::Scenario_Traffic_Distribution* Scenario_Traffic::release_parked_distribution() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Traffic.parked_distribution)
  
  ::metamoto::types::Scenario_Traffic_Distribution* temp = parked_distribution_;
  parked_distribution_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Traffic_Distribution* Scenario_Traffic::mutable_parked_distribution() {
  
  if (parked_distribution_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Traffic_Distribution>(GetArenaNoVirtual());
    parked_distribution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.parked_distribution)
  return parked_distribution_;
}
inline void Scenario_Traffic::set_allocated_parked_distribution(::metamoto::types::Scenario_Traffic_Distribution* parked_distribution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parked_distribution_;
  }
  if (parked_distribution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parked_distribution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parked_distribution, submessage_arena);
    }
    
  } else {
    
  }
  parked_distribution_ = parked_distribution;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Traffic.parked_distribution)
}

// int32 num_random_parked_vehicles = 8;
inline bool Scenario_Traffic::has_num_random_parked_vehicles() const {
  return random_parked_oneof_case() == kNumRandomParkedVehicles;
}
inline void Scenario_Traffic::set_has_num_random_parked_vehicles() {
  _oneof_case_[1] = kNumRandomParkedVehicles;
}
inline void Scenario_Traffic::clear_num_random_parked_vehicles() {
  if (has_num_random_parked_vehicles()) {
    random_parked_oneof_.num_random_parked_vehicles_ = 0;
    clear_has_random_parked_oneof();
  }
}
inline ::google::protobuf::int32 Scenario_Traffic::num_random_parked_vehicles() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.num_random_parked_vehicles)
  if (has_num_random_parked_vehicles()) {
    return random_parked_oneof_.num_random_parked_vehicles_;
  }
  return 0;
}
inline void Scenario_Traffic::set_num_random_parked_vehicles(::google::protobuf::int32 value) {
  if (!has_num_random_parked_vehicles()) {
    clear_random_parked_oneof();
    set_has_num_random_parked_vehicles();
  }
  random_parked_oneof_.num_random_parked_vehicles_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Traffic.num_random_parked_vehicles)
}

// float parking_fullness = 9;
inline bool Scenario_Traffic::has_parking_fullness() const {
  return random_parked_oneof_case() == kParkingFullness;
}
inline void Scenario_Traffic::set_has_parking_fullness() {
  _oneof_case_[1] = kParkingFullness;
}
inline void Scenario_Traffic::clear_parking_fullness() {
  if (has_parking_fullness()) {
    random_parked_oneof_.parking_fullness_ = 0;
    clear_has_random_parked_oneof();
  }
}
inline float Scenario_Traffic::parking_fullness() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.parking_fullness)
  if (has_parking_fullness()) {
    return random_parked_oneof_.parking_fullness_;
  }
  return 0;
}
inline void Scenario_Traffic::set_parking_fullness(float value) {
  if (!has_parking_fullness()) {
    clear_random_parked_oneof();
    set_has_parking_fullness();
  }
  random_parked_oneof_.parking_fullness_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Traffic.parking_fullness)
}

// repeated .metamoto.types.ParkedVehicle parked_vehicles = 10;
inline int Scenario_Traffic::parked_vehicles_size() const {
  return parked_vehicles_.size();
}
inline void Scenario_Traffic::clear_parked_vehicles() {
  parked_vehicles_.Clear();
}
inline ::metamoto::types::ParkedVehicle* Scenario_Traffic::mutable_parked_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Traffic.parked_vehicles)
  return parked_vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::ParkedVehicle >*
Scenario_Traffic::mutable_parked_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Traffic.parked_vehicles)
  return &parked_vehicles_;
}
inline const ::metamoto::types::ParkedVehicle& Scenario_Traffic::parked_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Traffic.parked_vehicles)
  return parked_vehicles_.Get(index);
}
inline ::metamoto::types::ParkedVehicle* Scenario_Traffic::add_parked_vehicles() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Traffic.parked_vehicles)
  return parked_vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::ParkedVehicle >&
Scenario_Traffic::parked_vehicles() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Traffic.parked_vehicles)
  return parked_vehicles_;
}

inline bool Scenario_Traffic::has_random_oneof() const {
  return random_oneof_case() != RANDOM_ONEOF_NOT_SET;
}
inline void Scenario_Traffic::clear_has_random_oneof() {
  _oneof_case_[0] = RANDOM_ONEOF_NOT_SET;
}
inline bool Scenario_Traffic::has_random_parked_oneof() const {
  return random_parked_oneof_case() != RANDOM_PARKED_ONEOF_NOT_SET;
}
inline void Scenario_Traffic::clear_has_random_parked_oneof() {
  _oneof_case_[1] = RANDOM_PARKED_ONEOF_NOT_SET;
}
inline Scenario_Traffic::RandomOneofCase Scenario_Traffic::random_oneof_case() const {
  return Scenario_Traffic::RandomOneofCase(_oneof_case_[0]);
}
inline Scenario_Traffic::RandomParkedOneofCase Scenario_Traffic::random_parked_oneof_case() const {
  return Scenario_Traffic::RandomParkedOneofCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scenario_Pedestrians_Distribution

// map<string, float> name_weights = 1;
inline int Scenario_Pedestrians_Distribution::name_weights_size() const {
  return name_weights_.size();
}
inline void Scenario_Pedestrians_Distribution::clear_name_weights() {
  name_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Pedestrians_Distribution::name_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Pedestrians.Distribution.name_weights)
  return name_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Pedestrians_Distribution::mutable_name_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Pedestrians.Distribution.name_weights)
  return name_weights_.MutableMap();
}

// map<string, float> type_weights = 2;
inline int Scenario_Pedestrians_Distribution::type_weights_size() const {
  return type_weights_.size();
}
inline void Scenario_Pedestrians_Distribution::clear_type_weights() {
  type_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Pedestrians_Distribution::type_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Pedestrians.Distribution.type_weights)
  return type_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Pedestrians_Distribution::mutable_type_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Pedestrians.Distribution.type_weights)
  return type_weights_.MutableMap();
}

// map<string, float> state_weights = 3;
inline int Scenario_Pedestrians_Distribution::state_weights_size() const {
  return state_weights_.size();
}
inline void Scenario_Pedestrians_Distribution::clear_state_weights() {
  state_weights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, float >&
Scenario_Pedestrians_Distribution::state_weights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.Pedestrians.Distribution.state_weights)
  return state_weights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, float >*
Scenario_Pedestrians_Distribution::mutable_state_weights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.Pedestrians.Distribution.state_weights)
  return state_weights_.MutableMap();
}

// -------------------------------------------------------------------

// Scenario_Pedestrians

// repeated .metamoto.types.Vector3 region = 1;
inline int Scenario_Pedestrians::region_size() const {
  return region_.size();
}
inline ::metamoto::types::Vector3* Scenario_Pedestrians::mutable_region(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Pedestrians.region)
  return region_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
Scenario_Pedestrians::mutable_region() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Pedestrians.region)
  return &region_;
}
inline const ::metamoto::types::Vector3& Scenario_Pedestrians::region(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Pedestrians.region)
  return region_.Get(index);
}
inline ::metamoto::types::Vector3* Scenario_Pedestrians::add_region() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Pedestrians.region)
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
Scenario_Pedestrians::region() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Pedestrians.region)
  return region_;
}

// .metamoto.types.Scenario.Pedestrians.Distribution distribution = 2;
inline bool Scenario_Pedestrians::has_distribution() const {
  return this != internal_default_instance() && distribution_ != NULL;
}
inline void Scenario_Pedestrians::clear_distribution() {
  if (GetArenaNoVirtual() == NULL && distribution_ != NULL) {
    delete distribution_;
  }
  distribution_ = NULL;
}
inline const ::metamoto::types::Scenario_Pedestrians_Distribution& Scenario_Pedestrians::_internal_distribution() const {
  return *distribution_;
}
inline const ::metamoto::types::Scenario_Pedestrians_Distribution& Scenario_Pedestrians::distribution() const {
  const ::metamoto::types::Scenario_Pedestrians_Distribution* p = distribution_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Pedestrians.distribution)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Pedestrians_Distribution*>(
      &::metamoto::types::_Scenario_Pedestrians_Distribution_default_instance_);
}
inline ::metamoto::types::Scenario_Pedestrians_Distribution* Scenario_Pedestrians::release_distribution() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Pedestrians.distribution)
  
  ::metamoto::types::Scenario_Pedestrians_Distribution* temp = distribution_;
  distribution_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Pedestrians_Distribution* Scenario_Pedestrians::mutable_distribution() {
  
  if (distribution_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians_Distribution>(GetArenaNoVirtual());
    distribution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Pedestrians.distribution)
  return distribution_;
}
inline void Scenario_Pedestrians::set_allocated_distribution(::metamoto::types::Scenario_Pedestrians_Distribution* distribution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distribution_;
  }
  if (distribution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distribution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distribution, submessage_arena);
    }
    
  } else {
    
  }
  distribution_ = distribution;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Pedestrians.distribution)
}

// repeated .metamoto.types.PedestrianConfiguration pedestrians = 3;
inline int Scenario_Pedestrians::pedestrians_size() const {
  return pedestrians_.size();
}
inline void Scenario_Pedestrians::clear_pedestrians() {
  pedestrians_.Clear();
}
inline ::metamoto::types::PedestrianConfiguration* Scenario_Pedestrians::mutable_pedestrians(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Pedestrians.pedestrians)
  return pedestrians_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration >*
Scenario_Pedestrians::mutable_pedestrians() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Pedestrians.pedestrians)
  return &pedestrians_;
}
inline const ::metamoto::types::PedestrianConfiguration& Scenario_Pedestrians::pedestrians(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Pedestrians.pedestrians)
  return pedestrians_.Get(index);
}
inline ::metamoto::types::PedestrianConfiguration* Scenario_Pedestrians::add_pedestrians() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Pedestrians.pedestrians)
  return pedestrians_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration >&
Scenario_Pedestrians::pedestrians() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Pedestrians.pedestrians)
  return pedestrians_;
}

// int32 num_random_pedestrians = 4;
inline bool Scenario_Pedestrians::has_num_random_pedestrians() const {
  return random_oneof_case() == kNumRandomPedestrians;
}
inline void Scenario_Pedestrians::set_has_num_random_pedestrians() {
  _oneof_case_[0] = kNumRandomPedestrians;
}
inline void Scenario_Pedestrians::clear_num_random_pedestrians() {
  if (has_num_random_pedestrians()) {
    random_oneof_.num_random_pedestrians_ = 0;
    clear_has_random_oneof();
  }
}
inline ::google::protobuf::int32 Scenario_Pedestrians::num_random_pedestrians() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Pedestrians.num_random_pedestrians)
  if (has_num_random_pedestrians()) {
    return random_oneof_.num_random_pedestrians_;
  }
  return 0;
}
inline void Scenario_Pedestrians::set_num_random_pedestrians(::google::protobuf::int32 value) {
  if (!has_num_random_pedestrians()) {
    clear_random_oneof();
    set_has_num_random_pedestrians();
  }
  random_oneof_.num_random_pedestrians_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Pedestrians.num_random_pedestrians)
}

// float pedestrian_traffic = 5;
inline bool Scenario_Pedestrians::has_pedestrian_traffic() const {
  return random_oneof_case() == kPedestrianTraffic;
}
inline void Scenario_Pedestrians::set_has_pedestrian_traffic() {
  _oneof_case_[0] = kPedestrianTraffic;
}
inline void Scenario_Pedestrians::clear_pedestrian_traffic() {
  if (has_pedestrian_traffic()) {
    random_oneof_.pedestrian_traffic_ = 0;
    clear_has_random_oneof();
  }
}
inline float Scenario_Pedestrians::pedestrian_traffic() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Pedestrians.pedestrian_traffic)
  if (has_pedestrian_traffic()) {
    return random_oneof_.pedestrian_traffic_;
  }
  return 0;
}
inline void Scenario_Pedestrians::set_pedestrian_traffic(float value) {
  if (!has_pedestrian_traffic()) {
    clear_random_oneof();
    set_has_pedestrian_traffic();
  }
  random_oneof_.pedestrian_traffic_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Pedestrians.pedestrian_traffic)
}

inline bool Scenario_Pedestrians::has_random_oneof() const {
  return random_oneof_case() != RANDOM_ONEOF_NOT_SET;
}
inline void Scenario_Pedestrians::clear_has_random_oneof() {
  _oneof_case_[0] = RANDOM_ONEOF_NOT_SET;
}
inline Scenario_Pedestrians::RandomOneofCase Scenario_Pedestrians::random_oneof_case() const {
  return Scenario_Pedestrians::RandomOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Scenario_TrafficLight_Direction

// string id = 1;
inline void Scenario_TrafficLight_Direction::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_TrafficLight_Direction::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.Direction.id)
  return id_.GetNoArena();
}
inline void Scenario_TrafficLight_Direction::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.TrafficLight.Direction.id)
}
#if LANG_CXX11
inline void Scenario_TrafficLight_Direction::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.TrafficLight.Direction.id)
}
#endif
inline void Scenario_TrafficLight_Direction::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.TrafficLight.Direction.id)
}
inline void Scenario_TrafficLight_Direction::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.TrafficLight.Direction.id)
}
inline ::std::string* Scenario_TrafficLight_Direction::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.Direction.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_TrafficLight_Direction::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.Direction.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_TrafficLight_Direction::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.Direction.id)
}

// .google.protobuf.FloatValue green_time = 2;
inline bool Scenario_TrafficLight_Direction::has_green_time() const {
  return this != internal_default_instance() && green_time_ != NULL;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::_internal_green_time() const {
  return *green_time_;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::green_time() const {
  const ::google::protobuf::FloatValue* p = green_time_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.Direction.green_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::release_green_time() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.Direction.green_time)
  
  ::google::protobuf::FloatValue* temp = green_time_;
  green_time_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::mutable_green_time() {
  
  if (green_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    green_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.Direction.green_time)
  return green_time_;
}
inline void Scenario_TrafficLight_Direction::set_allocated_green_time(::google::protobuf::FloatValue* green_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(green_time_);
  }
  if (green_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(green_time)->GetArena();
    if (message_arena != submessage_arena) {
      green_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, green_time, submessage_arena);
    }
    
  } else {
    
  }
  green_time_ = green_time;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.Direction.green_time)
}

// .google.protobuf.FloatValue yellow_time = 3;
inline bool Scenario_TrafficLight_Direction::has_yellow_time() const {
  return this != internal_default_instance() && yellow_time_ != NULL;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::_internal_yellow_time() const {
  return *yellow_time_;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::yellow_time() const {
  const ::google::protobuf::FloatValue* p = yellow_time_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.Direction.yellow_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::release_yellow_time() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.Direction.yellow_time)
  
  ::google::protobuf::FloatValue* temp = yellow_time_;
  yellow_time_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::mutable_yellow_time() {
  
  if (yellow_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    yellow_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.Direction.yellow_time)
  return yellow_time_;
}
inline void Scenario_TrafficLight_Direction::set_allocated_yellow_time(::google::protobuf::FloatValue* yellow_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yellow_time_);
  }
  if (yellow_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(yellow_time)->GetArena();
    if (message_arena != submessage_arena) {
      yellow_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yellow_time, submessage_arena);
    }
    
  } else {
    
  }
  yellow_time_ = yellow_time;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.Direction.yellow_time)
}

// .google.protobuf.FloatValue crosswalk_walk_time = 4;
inline bool Scenario_TrafficLight_Direction::has_crosswalk_walk_time() const {
  return this != internal_default_instance() && crosswalk_walk_time_ != NULL;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::_internal_crosswalk_walk_time() const {
  return *crosswalk_walk_time_;
}
inline const ::google::protobuf::FloatValue& Scenario_TrafficLight_Direction::crosswalk_walk_time() const {
  const ::google::protobuf::FloatValue* p = crosswalk_walk_time_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.Direction.crosswalk_walk_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::release_crosswalk_walk_time() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.Direction.crosswalk_walk_time)
  
  ::google::protobuf::FloatValue* temp = crosswalk_walk_time_;
  crosswalk_walk_time_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Scenario_TrafficLight_Direction::mutable_crosswalk_walk_time() {
  
  if (crosswalk_walk_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    crosswalk_walk_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.Direction.crosswalk_walk_time)
  return crosswalk_walk_time_;
}
inline void Scenario_TrafficLight_Direction::set_allocated_crosswalk_walk_time(::google::protobuf::FloatValue* crosswalk_walk_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(crosswalk_walk_time_);
  }
  if (crosswalk_walk_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(crosswalk_walk_time)->GetArena();
    if (message_arena != submessage_arena) {
      crosswalk_walk_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, crosswalk_walk_time, submessage_arena);
    }
    
  } else {
    
  }
  crosswalk_walk_time_ = crosswalk_walk_time;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.Direction.crosswalk_walk_time)
}

// string synchronize_with_direction_id = 5;
inline void Scenario_TrafficLight_Direction::clear_synchronize_with_direction_id() {
  synchronize_with_direction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_TrafficLight_Direction::synchronize_with_direction_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
  return synchronize_with_direction_id_.GetNoArena();
}
inline void Scenario_TrafficLight_Direction::set_synchronize_with_direction_id(const ::std::string& value) {
  
  synchronize_with_direction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
}
#if LANG_CXX11
inline void Scenario_TrafficLight_Direction::set_synchronize_with_direction_id(::std::string&& value) {
  
  synchronize_with_direction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
}
#endif
inline void Scenario_TrafficLight_Direction::set_synchronize_with_direction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  synchronize_with_direction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
}
inline void Scenario_TrafficLight_Direction::set_synchronize_with_direction_id(const char* value, size_t size) {
  
  synchronize_with_direction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
}
inline ::std::string* Scenario_TrafficLight_Direction::mutable_synchronize_with_direction_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
  return synchronize_with_direction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_TrafficLight_Direction::release_synchronize_with_direction_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
  
  return synchronize_with_direction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_TrafficLight_Direction::set_allocated_synchronize_with_direction_id(::std::string* synchronize_with_direction_id) {
  if (synchronize_with_direction_id != NULL) {
    
  } else {
    
  }
  synchronize_with_direction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), synchronize_with_direction_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.Direction.synchronize_with_direction_id)
}

// -------------------------------------------------------------------

// Scenario_TrafficLight

// repeated .metamoto.types.Scenario.TrafficLight.Direction directions = 1;
inline int Scenario_TrafficLight::directions_size() const {
  return directions_.size();
}
inline void Scenario_TrafficLight::clear_directions() {
  directions_.Clear();
}
inline ::metamoto::types::Scenario_TrafficLight_Direction* Scenario_TrafficLight::mutable_directions(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.directions)
  return directions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_TrafficLight_Direction >*
Scenario_TrafficLight::mutable_directions() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.TrafficLight.directions)
  return &directions_;
}
inline const ::metamoto::types::Scenario_TrafficLight_Direction& Scenario_TrafficLight::directions(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.directions)
  return directions_.Get(index);
}
inline ::metamoto::types::Scenario_TrafficLight_Direction* Scenario_TrafficLight::add_directions() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.TrafficLight.directions)
  return directions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_TrafficLight_Direction >&
Scenario_TrafficLight::directions() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.TrafficLight.directions)
  return directions_;
}

// float all_red_time = 2;
inline void Scenario_TrafficLight::clear_all_red_time() {
  all_red_time_ = 0;
}
inline float Scenario_TrafficLight::all_red_time() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.all_red_time)
  return all_red_time_;
}
inline void Scenario_TrafficLight::set_all_red_time(float value) {
  
  all_red_time_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.TrafficLight.all_red_time)
}

// string start_green_direction = 3;
inline void Scenario_TrafficLight::clear_start_green_direction() {
  start_green_direction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_TrafficLight::start_green_direction() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.start_green_direction)
  return start_green_direction_.GetNoArena();
}
inline void Scenario_TrafficLight::set_start_green_direction(const ::std::string& value) {
  
  start_green_direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.TrafficLight.start_green_direction)
}
#if LANG_CXX11
inline void Scenario_TrafficLight::set_start_green_direction(::std::string&& value) {
  
  start_green_direction_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.TrafficLight.start_green_direction)
}
#endif
inline void Scenario_TrafficLight::set_start_green_direction(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_green_direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.TrafficLight.start_green_direction)
}
inline void Scenario_TrafficLight::set_start_green_direction(const char* value, size_t size) {
  
  start_green_direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.TrafficLight.start_green_direction)
}
inline ::std::string* Scenario_TrafficLight::mutable_start_green_direction() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.TrafficLight.start_green_direction)
  return start_green_direction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_TrafficLight::release_start_green_direction() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.TrafficLight.start_green_direction)
  
  return start_green_direction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_TrafficLight::set_allocated_start_green_direction(::std::string* start_green_direction) {
  if (start_green_direction != NULL) {
    
  } else {
    
  }
  start_green_direction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_green_direction);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.TrafficLight.start_green_direction)
}

// float start_cycle_offset = 4;
inline void Scenario_TrafficLight::clear_start_cycle_offset() {
  start_cycle_offset_ = 0;
}
inline float Scenario_TrafficLight::start_cycle_offset() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.TrafficLight.start_cycle_offset)
  return start_cycle_offset_;
}
inline void Scenario_TrafficLight::set_start_cycle_offset(float value) {
  
  start_cycle_offset_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.TrafficLight.start_cycle_offset)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scenario_Intersection_SignalState

// string signal_id = 1;
inline void Scenario_Intersection_SignalState::clear_signal_id() {
  signal_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_Intersection_SignalState::signal_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.SignalState.signal_id)
  return signal_id_.GetNoArena();
}
inline void Scenario_Intersection_SignalState::set_signal_id(const ::std::string& value) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.SignalState.signal_id)
}
#if LANG_CXX11
inline void Scenario_Intersection_SignalState::set_signal_id(::std::string&& value) {
  
  signal_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.Intersection.SignalState.signal_id)
}
#endif
inline void Scenario_Intersection_SignalState::set_signal_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.Intersection.SignalState.signal_id)
}
inline void Scenario_Intersection_SignalState::set_signal_id(const char* value, size_t size) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.Intersection.SignalState.signal_id)
}
inline ::std::string* Scenario_Intersection_SignalState::mutable_signal_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.SignalState.signal_id)
  return signal_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_Intersection_SignalState::release_signal_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Intersection.SignalState.signal_id)
  
  return signal_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_Intersection_SignalState::set_allocated_signal_id(::std::string* signal_id) {
  if (signal_id != NULL) {
    
  } else {
    
  }
  signal_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Intersection.SignalState.signal_id)
}

// string state_name = 2;
inline void Scenario_Intersection_SignalState::clear_state_name() {
  state_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_Intersection_SignalState::state_name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.SignalState.state_name)
  return state_name_.GetNoArena();
}
inline void Scenario_Intersection_SignalState::set_state_name(const ::std::string& value) {
  
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.SignalState.state_name)
}
#if LANG_CXX11
inline void Scenario_Intersection_SignalState::set_state_name(::std::string&& value) {
  
  state_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.Intersection.SignalState.state_name)
}
#endif
inline void Scenario_Intersection_SignalState::set_state_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.Intersection.SignalState.state_name)
}
inline void Scenario_Intersection_SignalState::set_state_name(const char* value, size_t size) {
  
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.Intersection.SignalState.state_name)
}
inline ::std::string* Scenario_Intersection_SignalState::mutable_state_name() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.SignalState.state_name)
  return state_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_Intersection_SignalState::release_state_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Intersection.SignalState.state_name)
  
  return state_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_Intersection_SignalState::set_allocated_state_name(::std::string* state_name) {
  if (state_name != NULL) {
    
  } else {
    
  }
  state_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state_name);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Intersection.SignalState.state_name)
}

// -------------------------------------------------------------------

// Scenario_Intersection_IntersectionState

// float duration = 1;
inline void Scenario_Intersection_IntersectionState::clear_duration() {
  duration_ = 0;
}
inline float Scenario_Intersection_IntersectionState::duration() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.IntersectionState.duration)
  return duration_;
}
inline void Scenario_Intersection_IntersectionState::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.IntersectionState.duration)
}

// repeated .metamoto.types.Scenario.Intersection.SignalState signal_states = 2;
inline int Scenario_Intersection_IntersectionState::signal_states_size() const {
  return signal_states_.size();
}
inline void Scenario_Intersection_IntersectionState::clear_signal_states() {
  signal_states_.Clear();
}
inline ::metamoto::types::Scenario_Intersection_SignalState* Scenario_Intersection_IntersectionState::mutable_signal_states(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.IntersectionState.signal_states)
  return signal_states_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_SignalState >*
Scenario_Intersection_IntersectionState::mutable_signal_states() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Intersection.IntersectionState.signal_states)
  return &signal_states_;
}
inline const ::metamoto::types::Scenario_Intersection_SignalState& Scenario_Intersection_IntersectionState::signal_states(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.IntersectionState.signal_states)
  return signal_states_.Get(index);
}
inline ::metamoto::types::Scenario_Intersection_SignalState* Scenario_Intersection_IntersectionState::add_signal_states() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Intersection.IntersectionState.signal_states)
  return signal_states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_SignalState >&
Scenario_Intersection_IntersectionState::signal_states() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Intersection.IntersectionState.signal_states)
  return signal_states_;
}

// -------------------------------------------------------------------

// Scenario_Intersection_Phase

// repeated .metamoto.types.Scenario.Intersection.IntersectionState intersection_states = 1;
inline int Scenario_Intersection_Phase::intersection_states_size() const {
  return intersection_states_.size();
}
inline void Scenario_Intersection_Phase::clear_intersection_states() {
  intersection_states_.Clear();
}
inline ::metamoto::types::Scenario_Intersection_IntersectionState* Scenario_Intersection_Phase::mutable_intersection_states(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.Phase.intersection_states)
  return intersection_states_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_IntersectionState >*
Scenario_Intersection_Phase::mutable_intersection_states() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Intersection.Phase.intersection_states)
  return &intersection_states_;
}
inline const ::metamoto::types::Scenario_Intersection_IntersectionState& Scenario_Intersection_Phase::intersection_states(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.Phase.intersection_states)
  return intersection_states_.Get(index);
}
inline ::metamoto::types::Scenario_Intersection_IntersectionState* Scenario_Intersection_Phase::add_intersection_states() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Intersection.Phase.intersection_states)
  return intersection_states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_IntersectionState >&
Scenario_Intersection_Phase::intersection_states() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Intersection.Phase.intersection_states)
  return intersection_states_;
}

// -------------------------------------------------------------------

// Scenario_Intersection

// repeated .metamoto.types.Scenario.Intersection.Phase phases = 1;
inline int Scenario_Intersection::phases_size() const {
  return phases_.size();
}
inline void Scenario_Intersection::clear_phases() {
  phases_.Clear();
}
inline ::metamoto::types::Scenario_Intersection_Phase* Scenario_Intersection::mutable_phases(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.phases)
  return phases_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_Phase >*
Scenario_Intersection::mutable_phases() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.Intersection.phases)
  return &phases_;
}
inline const ::metamoto::types::Scenario_Intersection_Phase& Scenario_Intersection::phases(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.phases)
  return phases_.Get(index);
}
inline ::metamoto::types::Scenario_Intersection_Phase* Scenario_Intersection::add_phases() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.Intersection.phases)
  return phases_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_Intersection_Phase >&
Scenario_Intersection::phases() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.Intersection.phases)
  return phases_;
}

// int32 starting_phase_index = 2;
inline void Scenario_Intersection::clear_starting_phase_index() {
  starting_phase_index_ = 0;
}
inline ::google::protobuf::int32 Scenario_Intersection::starting_phase_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.starting_phase_index)
  return starting_phase_index_;
}
inline void Scenario_Intersection::set_starting_phase_index(::google::protobuf::int32 value) {
  
  starting_phase_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.starting_phase_index)
}

// float starting_duration_offset = 3;
inline void Scenario_Intersection::clear_starting_duration_offset() {
  starting_duration_offset_ = 0;
}
inline float Scenario_Intersection::starting_duration_offset() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.starting_duration_offset)
  return starting_duration_offset_;
}
inline void Scenario_Intersection::set_starting_duration_offset(float value) {
  
  starting_duration_offset_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.starting_duration_offset)
}

// .metamoto.types.Vector3 position = 4;
inline bool Scenario_Intersection::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::metamoto::types::Vector3& Scenario_Intersection::_internal_position() const {
  return *position_;
}
inline const ::metamoto::types::Vector3& Scenario_Intersection::position() const {
  const ::metamoto::types::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.position)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Scenario_Intersection::release_position() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Intersection.position)
  
  ::metamoto::types::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Scenario_Intersection::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.position)
  return position_;
}
inline void Scenario_Intersection::set_allocated_position(::metamoto::types::Vector3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Intersection.position)
}

// string vector_id = 5;
inline void Scenario_Intersection::clear_vector_id() {
  vector_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario_Intersection::vector_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.Intersection.vector_id)
  return vector_id_.GetNoArena();
}
inline void Scenario_Intersection::set_vector_id(const ::std::string& value) {
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.Intersection.vector_id)
}
#if LANG_CXX11
inline void Scenario_Intersection::set_vector_id(::std::string&& value) {
  
  vector_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.Intersection.vector_id)
}
#endif
inline void Scenario_Intersection::set_vector_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.Intersection.vector_id)
}
inline void Scenario_Intersection::set_vector_id(const char* value, size_t size) {
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.Intersection.vector_id)
}
inline ::std::string* Scenario_Intersection::mutable_vector_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.Intersection.vector_id)
  return vector_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario_Intersection::release_vector_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.Intersection.vector_id)
  
  return vector_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario_Intersection::set_allocated_vector_id(::std::string* vector_id) {
  if (vector_id != NULL) {
    
  } else {
    
  }
  vector_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vector_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.Intersection.vector_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scenario

// string id = 1;
inline void Scenario::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.id)
  return id_.GetNoArena();
}
inline void Scenario::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.id)
}
#if LANG_CXX11
inline void Scenario::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.id)
}
#endif
inline void Scenario::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.id)
}
inline void Scenario::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.id)
}
inline ::std::string* Scenario::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.id)
}

// string name = 2;
inline void Scenario::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario::name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.name)
  return name_.GetNoArena();
}
inline void Scenario::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.name)
}
#if LANG_CXX11
inline void Scenario::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.name)
}
#endif
inline void Scenario::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.name)
}
inline void Scenario::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.name)
}
inline ::std::string* Scenario::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario::release_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.name)
}

// string scene = 3;
inline void Scenario::clear_scene() {
  scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario::scene() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.scene)
  return scene_.GetNoArena();
}
inline void Scenario::set_scene(const ::std::string& value) {
  
  scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.scene)
}
#if LANG_CXX11
inline void Scenario::set_scene(::std::string&& value) {
  
  scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.scene)
}
#endif
inline void Scenario::set_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.scene)
}
inline void Scenario::set_scene(const char* value, size_t size) {
  
  scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.scene)
}
inline ::std::string* Scenario::mutable_scene() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.scene)
  return scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario::release_scene() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.scene)
  
  return scene_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario::set_allocated_scene(::std::string* scene) {
  if (scene != NULL) {
    
  } else {
    
  }
  scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scene);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.scene)
}

// string description = 4;
inline void Scenario::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scenario::description() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.description)
  return description_.GetNoArena();
}
inline void Scenario::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.description)
}
#if LANG_CXX11
inline void Scenario::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Scenario.description)
}
#endif
inline void Scenario::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Scenario.description)
}
inline void Scenario::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Scenario.description)
}
inline ::std::string* Scenario::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scenario::release_description() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scenario::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.description)
}

// bool read_only = 5;
inline void Scenario::clear_read_only() {
  read_only_ = false;
}
inline bool Scenario::read_only() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.read_only)
  return read_only_;
}
inline void Scenario::set_read_only(bool value) {
  
  read_only_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Scenario.read_only)
}

// .metamoto.types.Version version = 17;
inline bool Scenario::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline const ::metamoto::types::Version& Scenario::_internal_version() const {
  return *version_;
}
inline const ::metamoto::types::Version& Scenario::version() const {
  const ::metamoto::types::Version* p = version_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.version)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Version*>(
      &::metamoto::types::_Version_default_instance_);
}
inline ::metamoto::types::Version* Scenario::release_version() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.version)
  
  ::metamoto::types::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline ::metamoto::types::Version* Scenario::mutable_version() {
  
  if (version_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.version)
  return version_;
}
inline void Scenario::set_allocated_version(::metamoto::types::Version* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(version_);
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.version)
}

// .metamoto.types.Scenario.System system = 6;
inline bool Scenario::has_system() const {
  return this != internal_default_instance() && system_ != NULL;
}
inline void Scenario::clear_system() {
  if (GetArenaNoVirtual() == NULL && system_ != NULL) {
    delete system_;
  }
  system_ = NULL;
}
inline const ::metamoto::types::Scenario_System& Scenario::_internal_system() const {
  return *system_;
}
inline const ::metamoto::types::Scenario_System& Scenario::system() const {
  const ::metamoto::types::Scenario_System* p = system_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.system)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_System*>(
      &::metamoto::types::_Scenario_System_default_instance_);
}
inline ::metamoto::types::Scenario_System* Scenario::release_system() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.system)
  
  ::metamoto::types::Scenario_System* temp = system_;
  system_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_System* Scenario::mutable_system() {
  
  if (system_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_System>(GetArenaNoVirtual());
    system_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.system)
  return system_;
}
inline void Scenario::set_allocated_system(::metamoto::types::Scenario_System* system) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete system_;
  }
  if (system) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      system = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, system, submessage_arena);
    }
    
  } else {
    
  }
  system_ = system;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.system)
}

// .metamoto.types.Scenario.Objectives objectives = 7;
inline bool Scenario::has_objectives() const {
  return this != internal_default_instance() && objectives_ != NULL;
}
inline void Scenario::clear_objectives() {
  if (GetArenaNoVirtual() == NULL && objectives_ != NULL) {
    delete objectives_;
  }
  objectives_ = NULL;
}
inline const ::metamoto::types::Scenario_Objectives& Scenario::_internal_objectives() const {
  return *objectives_;
}
inline const ::metamoto::types::Scenario_Objectives& Scenario::objectives() const {
  const ::metamoto::types::Scenario_Objectives* p = objectives_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.objectives)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Objectives*>(
      &::metamoto::types::_Scenario_Objectives_default_instance_);
}
inline ::metamoto::types::Scenario_Objectives* Scenario::release_objectives() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.objectives)
  
  ::metamoto::types::Scenario_Objectives* temp = objectives_;
  objectives_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Objectives* Scenario::mutable_objectives() {
  
  if (objectives_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Objectives>(GetArenaNoVirtual());
    objectives_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.objectives)
  return objectives_;
}
inline void Scenario::set_allocated_objectives(::metamoto::types::Scenario_Objectives* objectives) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete objectives_;
  }
  if (objectives) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      objectives = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, objectives, submessage_arena);
    }
    
  } else {
    
  }
  objectives_ = objectives;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.objectives)
}

// .metamoto.types.Environment environment = 8;
inline bool Scenario::has_environment() const {
  return this != internal_default_instance() && environment_ != NULL;
}
inline const ::metamoto::types::Environment& Scenario::_internal_environment() const {
  return *environment_;
}
inline const ::metamoto::types::Environment& Scenario::environment() const {
  const ::metamoto::types::Environment* p = environment_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.environment)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Environment*>(
      &::metamoto::types::_Environment_default_instance_);
}
inline ::metamoto::types::Environment* Scenario::release_environment() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.environment)
  
  ::metamoto::types::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline ::metamoto::types::Environment* Scenario::mutable_environment() {
  
  if (environment_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Environment>(GetArenaNoVirtual());
    environment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.environment)
  return environment_;
}
inline void Scenario::set_allocated_environment(::metamoto::types::Environment* environment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(environment_);
  }
  if (environment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      environment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    
  } else {
    
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.environment)
}

// .metamoto.types.Scenario.EgoVehicle ego_vehicle = 9;
inline bool Scenario::has_ego_vehicle() const {
  return this != internal_default_instance() && ego_vehicle_ != NULL;
}
inline void Scenario::clear_ego_vehicle() {
  if (GetArenaNoVirtual() == NULL && ego_vehicle_ != NULL) {
    delete ego_vehicle_;
  }
  ego_vehicle_ = NULL;
}
inline const ::metamoto::types::Scenario_EgoVehicle& Scenario::_internal_ego_vehicle() const {
  return *ego_vehicle_;
}
inline const ::metamoto::types::Scenario_EgoVehicle& Scenario::ego_vehicle() const {
  const ::metamoto::types::Scenario_EgoVehicle* p = ego_vehicle_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.ego_vehicle)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_EgoVehicle*>(
      &::metamoto::types::_Scenario_EgoVehicle_default_instance_);
}
inline ::metamoto::types::Scenario_EgoVehicle* Scenario::release_ego_vehicle() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.ego_vehicle)
  
  ::metamoto::types::Scenario_EgoVehicle* temp = ego_vehicle_;
  ego_vehicle_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_EgoVehicle* Scenario::mutable_ego_vehicle() {
  
  if (ego_vehicle_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_EgoVehicle>(GetArenaNoVirtual());
    ego_vehicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.ego_vehicle)
  return ego_vehicle_;
}
inline void Scenario::set_allocated_ego_vehicle(::metamoto::types::Scenario_EgoVehicle* ego_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ego_vehicle_;
  }
  if (ego_vehicle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ego_vehicle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ego_vehicle, submessage_arena);
    }
    
  } else {
    
  }
  ego_vehicle_ = ego_vehicle;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.ego_vehicle)
}

// .metamoto.types.Scenario.Traffic traffic = 10;
inline bool Scenario::has_traffic() const {
  return this != internal_default_instance() && traffic_ != NULL;
}
inline void Scenario::clear_traffic() {
  if (GetArenaNoVirtual() == NULL && traffic_ != NULL) {
    delete traffic_;
  }
  traffic_ = NULL;
}
inline const ::metamoto::types::Scenario_Traffic& Scenario::_internal_traffic() const {
  return *traffic_;
}
inline const ::metamoto::types::Scenario_Traffic& Scenario::traffic() const {
  const ::metamoto::types::Scenario_Traffic* p = traffic_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.traffic)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Traffic*>(
      &::metamoto::types::_Scenario_Traffic_default_instance_);
}
inline ::metamoto::types::Scenario_Traffic* Scenario::release_traffic() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.traffic)
  
  ::metamoto::types::Scenario_Traffic* temp = traffic_;
  traffic_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Traffic* Scenario::mutable_traffic() {
  
  if (traffic_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Traffic>(GetArenaNoVirtual());
    traffic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.traffic)
  return traffic_;
}
inline void Scenario::set_allocated_traffic(::metamoto::types::Scenario_Traffic* traffic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete traffic_;
  }
  if (traffic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traffic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traffic, submessage_arena);
    }
    
  } else {
    
  }
  traffic_ = traffic;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.traffic)
}

// .metamoto.types.Scenario.Pedestrians pedestrians = 11;
inline bool Scenario::has_pedestrians() const {
  return this != internal_default_instance() && pedestrians_ != NULL;
}
inline void Scenario::clear_pedestrians() {
  if (GetArenaNoVirtual() == NULL && pedestrians_ != NULL) {
    delete pedestrians_;
  }
  pedestrians_ = NULL;
}
inline const ::metamoto::types::Scenario_Pedestrians& Scenario::_internal_pedestrians() const {
  return *pedestrians_;
}
inline const ::metamoto::types::Scenario_Pedestrians& Scenario::pedestrians() const {
  const ::metamoto::types::Scenario_Pedestrians* p = pedestrians_;
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.pedestrians)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Scenario_Pedestrians*>(
      &::metamoto::types::_Scenario_Pedestrians_default_instance_);
}
inline ::metamoto::types::Scenario_Pedestrians* Scenario::release_pedestrians() {
  // @@protoc_insertion_point(field_release:metamoto.types.Scenario.pedestrians)
  
  ::metamoto::types::Scenario_Pedestrians* temp = pedestrians_;
  pedestrians_ = NULL;
  return temp;
}
inline ::metamoto::types::Scenario_Pedestrians* Scenario::mutable_pedestrians() {
  
  if (pedestrians_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Scenario_Pedestrians>(GetArenaNoVirtual());
    pedestrians_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.pedestrians)
  return pedestrians_;
}
inline void Scenario::set_allocated_pedestrians(::metamoto::types::Scenario_Pedestrians* pedestrians) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pedestrians_;
  }
  if (pedestrians) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pedestrians = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pedestrians, submessage_arena);
    }
    
  } else {
    
  }
  pedestrians_ = pedestrians;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Scenario.pedestrians)
}

// map<string, .metamoto.types.Scenario.TrafficLight> traffic_lights = 12;
inline int Scenario::traffic_lights_size() const {
  return traffic_lights_.size();
}
inline void Scenario::clear_traffic_lights() {
  traffic_lights_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_TrafficLight >&
Scenario::traffic_lights() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.traffic_lights)
  return traffic_lights_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_TrafficLight >*
Scenario::mutable_traffic_lights() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.traffic_lights)
  return traffic_lights_.MutableMap();
}

// repeated .metamoto.types.Event events = 13;
inline int Scenario::events_size() const {
  return events_.size();
}
inline void Scenario::clear_events() {
  events_.Clear();
}
inline ::metamoto::types::Event* Scenario::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Event >*
Scenario::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.events)
  return &events_;
}
inline const ::metamoto::types::Event& Scenario::events(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.events)
  return events_.Get(index);
}
inline ::metamoto::types::Event* Scenario::add_events() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Event >&
Scenario::events() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.events)
  return events_;
}

// repeated .metamoto.types.Asset assets = 14;
inline int Scenario::assets_size() const {
  return assets_.size();
}
inline ::metamoto::types::Asset* Scenario::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.assets)
  return assets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Asset >*
Scenario::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.assets)
  return &assets_;
}
inline const ::metamoto::types::Asset& Scenario::assets(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.assets)
  return assets_.Get(index);
}
inline ::metamoto::types::Asset* Scenario::add_assets() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.assets)
  return assets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Asset >&
Scenario::assets() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.assets)
  return assets_;
}

// repeated .metamoto.types.Scenario.EgoVehicle ego_vehicles = 15;
inline int Scenario::ego_vehicles_size() const {
  return ego_vehicles_.size();
}
inline void Scenario::clear_ego_vehicles() {
  ego_vehicles_.Clear();
}
inline ::metamoto::types::Scenario_EgoVehicle* Scenario::mutable_ego_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Scenario.ego_vehicles)
  return ego_vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_EgoVehicle >*
Scenario::mutable_ego_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Scenario.ego_vehicles)
  return &ego_vehicles_;
}
inline const ::metamoto::types::Scenario_EgoVehicle& Scenario::ego_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Scenario.ego_vehicles)
  return ego_vehicles_.Get(index);
}
inline ::metamoto::types::Scenario_EgoVehicle* Scenario::add_ego_vehicles() {
  // @@protoc_insertion_point(field_add:metamoto.types.Scenario.ego_vehicles)
  return ego_vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Scenario_EgoVehicle >&
Scenario::ego_vehicles() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Scenario.ego_vehicles)
  return ego_vehicles_;
}

// map<string, .metamoto.types.Scenario.Intersection> intersections = 16;
inline int Scenario::intersections_size() const {
  return intersections_.size();
}
inline void Scenario::clear_intersections() {
  intersections_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_Intersection >&
Scenario::intersections() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.intersections)
  return intersections_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::metamoto::types::Scenario_Intersection >*
Scenario::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.intersections)
  return intersections_.MutableMap();
}

// map<string, .metamoto.types.Range> ranges = 100;
inline int Scenario::ranges_size() const {
  return ranges_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::metamoto::types::Range >&
Scenario::ranges() const {
  // @@protoc_insertion_point(field_map:metamoto.types.Scenario.ranges)
  return ranges_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::metamoto::types::Range >*
Scenario::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_map:metamoto.types.Scenario.ranges)
  return ranges_.MutableMap();
}

// -------------------------------------------------------------------

// Infraction

// .metamoto.types.Infraction.Type type = 1;
inline void Infraction::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::Infraction_Type Infraction::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Infraction.type)
  return static_cast< ::metamoto::types::Infraction_Type >(type_);
}
inline void Infraction::set_type(::metamoto::types::Infraction_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Infraction.type)
}

// .google.protobuf.FloatValue fail_value = 2;
inline bool Infraction::has_fail_value() const {
  return this != internal_default_instance() && fail_value_ != NULL;
}
inline const ::google::protobuf::FloatValue& Infraction::_internal_fail_value() const {
  return *fail_value_;
}
inline const ::google::protobuf::FloatValue& Infraction::fail_value() const {
  const ::google::protobuf::FloatValue* p = fail_value_;
  // @@protoc_insertion_point(field_get:metamoto.types.Infraction.fail_value)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Infraction::release_fail_value() {
  // @@protoc_insertion_point(field_release:metamoto.types.Infraction.fail_value)
  
  ::google::protobuf::FloatValue* temp = fail_value_;
  fail_value_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Infraction::mutable_fail_value() {
  
  if (fail_value_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    fail_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Infraction.fail_value)
  return fail_value_;
}
inline void Infraction::set_allocated_fail_value(::google::protobuf::FloatValue* fail_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fail_value_);
  }
  if (fail_value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(fail_value)->GetArena();
    if (message_arena != submessage_arena) {
      fail_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fail_value, submessage_arena);
    }
    
  } else {
    
  }
  fail_value_ = fail_value;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Infraction.fail_value)
}

// .google.protobuf.FloatValue stop_value = 3;
inline bool Infraction::has_stop_value() const {
  return this != internal_default_instance() && stop_value_ != NULL;
}
inline const ::google::protobuf::FloatValue& Infraction::_internal_stop_value() const {
  return *stop_value_;
}
inline const ::google::protobuf::FloatValue& Infraction::stop_value() const {
  const ::google::protobuf::FloatValue* p = stop_value_;
  // @@protoc_insertion_point(field_get:metamoto.types.Infraction.stop_value)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Infraction::release_stop_value() {
  // @@protoc_insertion_point(field_release:metamoto.types.Infraction.stop_value)
  
  ::google::protobuf::FloatValue* temp = stop_value_;
  stop_value_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Infraction::mutable_stop_value() {
  
  if (stop_value_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    stop_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Infraction.stop_value)
  return stop_value_;
}
inline void Infraction::set_allocated_stop_value(::google::protobuf::FloatValue* stop_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stop_value_);
  }
  if (stop_value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(stop_value)->GetArena();
    if (message_arena != submessage_arena) {
      stop_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop_value, submessage_arena);
    }
    
  } else {
    
  }
  stop_value_ = stop_value;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Infraction.stop_value)
}

// repeated .google.protobuf.FloatValue other_values = 4;
inline int Infraction::other_values_size() const {
  return other_values_.size();
}
inline ::google::protobuf::FloatValue* Infraction::mutable_other_values(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Infraction.other_values)
  return other_values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::FloatValue >*
Infraction::mutable_other_values() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Infraction.other_values)
  return &other_values_;
}
inline const ::google::protobuf::FloatValue& Infraction::other_values(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Infraction.other_values)
  return other_values_.Get(index);
}
inline ::google::protobuf::FloatValue* Infraction::add_other_values() {
  // @@protoc_insertion_point(field_add:metamoto.types.Infraction.other_values)
  return other_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::FloatValue >&
Infraction::other_values() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Infraction.other_values)
  return other_values_;
}

// -------------------------------------------------------------------

// DriverModel_BrakingBehavior

// float coast_deceleration_threshold = 7;
inline void DriverModel_BrakingBehavior::clear_coast_deceleration_threshold() {
  coast_deceleration_threshold_ = 0;
}
inline float DriverModel_BrakingBehavior::coast_deceleration_threshold() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.BrakingBehavior.coast_deceleration_threshold)
  return coast_deceleration_threshold_;
}
inline void DriverModel_BrakingBehavior::set_coast_deceleration_threshold(float value) {
  
  coast_deceleration_threshold_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.BrakingBehavior.coast_deceleration_threshold)
}

// float coast_speed_threshold = 1;
inline void DriverModel_BrakingBehavior::clear_coast_speed_threshold() {
  coast_speed_threshold_ = 0;
}
inline float DriverModel_BrakingBehavior::coast_speed_threshold() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.BrakingBehavior.coast_speed_threshold)
  return coast_speed_threshold_;
}
inline void DriverModel_BrakingBehavior::set_coast_speed_threshold(float value) {
  
  coast_speed_threshold_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.BrakingBehavior.coast_speed_threshold)
}

// float min_brake = 2;
inline void DriverModel_BrakingBehavior::clear_min_brake() {
  min_brake_ = 0;
}
inline float DriverModel_BrakingBehavior::min_brake() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.BrakingBehavior.min_brake)
  return min_brake_;
}
inline void DriverModel_BrakingBehavior::set_min_brake(float value) {
  
  min_brake_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.BrakingBehavior.min_brake)
}

// -------------------------------------------------------------------

// DriverModel

// float collision_avoidance = 1;
inline void DriverModel::clear_collision_avoidance() {
  collision_avoidance_ = 0;
}
inline float DriverModel::collision_avoidance() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.collision_avoidance)
  return collision_avoidance_;
}
inline void DriverModel::set_collision_avoidance(float value) {
  
  collision_avoidance_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.collision_avoidance)
}

// float speed_coefficient = 2;
inline void DriverModel::clear_speed_coefficient() {
  speed_coefficient_ = 0;
}
inline float DriverModel::speed_coefficient() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.speed_coefficient)
  return speed_coefficient_;
}
inline void DriverModel::set_speed_coefficient(float value) {
  
  speed_coefficient_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.speed_coefficient)
}

// bool obeys_lights = 3;
inline void DriverModel::clear_obeys_lights() {
  obeys_lights_ = false;
}
inline bool DriverModel::obeys_lights() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.obeys_lights)
  return obeys_lights_;
}
inline void DriverModel::set_obeys_lights(bool value) {
  
  obeys_lights_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.obeys_lights)
}

// bool random_path = 4;
inline void DriverModel::clear_random_path() {
  random_path_ = false;
}
inline bool DriverModel::random_path() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.random_path)
  return random_path_;
}
inline void DriverModel::set_random_path(bool value) {
  
  random_path_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.random_path)
}

// float lane_change_optimization = 5;
inline void DriverModel::clear_lane_change_optimization() {
  lane_change_optimization_ = 0;
}
inline float DriverModel::lane_change_optimization() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.lane_change_optimization)
  return lane_change_optimization_;
}
inline void DriverModel::set_lane_change_optimization(float value) {
  
  lane_change_optimization_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.lane_change_optimization)
}

// float lane_center_deviation = 6;
inline void DriverModel::clear_lane_center_deviation() {
  lane_center_deviation_ = 0;
}
inline float DriverModel::lane_center_deviation() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.lane_center_deviation)
  return lane_center_deviation_;
}
inline void DriverModel::set_lane_center_deviation(float value) {
  
  lane_center_deviation_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.lane_center_deviation)
}

// float timegap_multiplier = 7;
inline void DriverModel::clear_timegap_multiplier() {
  timegap_multiplier_ = 0;
}
inline float DriverModel::timegap_multiplier() const {
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.timegap_multiplier)
  return timegap_multiplier_;
}
inline void DriverModel::set_timegap_multiplier(float value) {
  
  timegap_multiplier_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.DriverModel.timegap_multiplier)
}

// .metamoto.types.DriverModel.BrakingBehavior braking_behavior = 9;
inline bool DriverModel::has_braking_behavior() const {
  return this != internal_default_instance() && braking_behavior_ != NULL;
}
inline void DriverModel::clear_braking_behavior() {
  if (GetArenaNoVirtual() == NULL && braking_behavior_ != NULL) {
    delete braking_behavior_;
  }
  braking_behavior_ = NULL;
}
inline const ::metamoto::types::DriverModel_BrakingBehavior& DriverModel::_internal_braking_behavior() const {
  return *braking_behavior_;
}
inline const ::metamoto::types::DriverModel_BrakingBehavior& DriverModel::braking_behavior() const {
  const ::metamoto::types::DriverModel_BrakingBehavior* p = braking_behavior_;
  // @@protoc_insertion_point(field_get:metamoto.types.DriverModel.braking_behavior)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::DriverModel_BrakingBehavior*>(
      &::metamoto::types::_DriverModel_BrakingBehavior_default_instance_);
}
inline ::metamoto::types::DriverModel_BrakingBehavior* DriverModel::release_braking_behavior() {
  // @@protoc_insertion_point(field_release:metamoto.types.DriverModel.braking_behavior)
  
  ::metamoto::types::DriverModel_BrakingBehavior* temp = braking_behavior_;
  braking_behavior_ = NULL;
  return temp;
}
inline ::metamoto::types::DriverModel_BrakingBehavior* DriverModel::mutable_braking_behavior() {
  
  if (braking_behavior_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::DriverModel_BrakingBehavior>(GetArenaNoVirtual());
    braking_behavior_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.DriverModel.braking_behavior)
  return braking_behavior_;
}
inline void DriverModel::set_allocated_braking_behavior(::metamoto::types::DriverModel_BrakingBehavior* braking_behavior) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete braking_behavior_;
  }
  if (braking_behavior) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      braking_behavior = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, braking_behavior, submessage_arena);
    }
    
  } else {
    
  }
  braking_behavior_ = braking_behavior;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.DriverModel.braking_behavior)
}

// -------------------------------------------------------------------

// TrafficFlow_LaneSpan

// string road_id = 1;
inline void TrafficFlow_LaneSpan::clear_road_id() {
  road_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficFlow_LaneSpan::road_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.LaneSpan.road_id)
  return road_id_.GetNoArena();
}
inline void TrafficFlow_LaneSpan::set_road_id(const ::std::string& value) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.LaneSpan.road_id)
}
#if LANG_CXX11
inline void TrafficFlow_LaneSpan::set_road_id(::std::string&& value) {
  
  road_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.TrafficFlow.LaneSpan.road_id)
}
#endif
inline void TrafficFlow_LaneSpan::set_road_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.TrafficFlow.LaneSpan.road_id)
}
inline void TrafficFlow_LaneSpan::set_road_id(const char* value, size_t size) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.TrafficFlow.LaneSpan.road_id)
}
inline ::std::string* TrafficFlow_LaneSpan::mutable_road_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficFlow.LaneSpan.road_id)
  return road_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficFlow_LaneSpan::release_road_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficFlow.LaneSpan.road_id)
  
  return road_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficFlow_LaneSpan::set_allocated_road_id(::std::string* road_id) {
  if (road_id != NULL) {
    
  } else {
    
  }
  road_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), road_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficFlow.LaneSpan.road_id)
}

// float s = 2;
inline void TrafficFlow_LaneSpan::clear_s() {
  s_ = 0;
}
inline float TrafficFlow_LaneSpan::s() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.LaneSpan.s)
  return s_;
}
inline void TrafficFlow_LaneSpan::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.LaneSpan.s)
}

// repeated int32 lanes = 3;
inline int TrafficFlow_LaneSpan::lanes_size() const {
  return lanes_.size();
}
inline void TrafficFlow_LaneSpan::clear_lanes() {
  lanes_.Clear();
}
inline ::google::protobuf::int32 TrafficFlow_LaneSpan::lanes(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.LaneSpan.lanes)
  return lanes_.Get(index);
}
inline void TrafficFlow_LaneSpan::set_lanes(int index, ::google::protobuf::int32 value) {
  lanes_.Set(index, value);
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.LaneSpan.lanes)
}
inline void TrafficFlow_LaneSpan::add_lanes(::google::protobuf::int32 value) {
  lanes_.Add(value);
  // @@protoc_insertion_point(field_add:metamoto.types.TrafficFlow.LaneSpan.lanes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TrafficFlow_LaneSpan::lanes() const {
  // @@protoc_insertion_point(field_list:metamoto.types.TrafficFlow.LaneSpan.lanes)
  return lanes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TrafficFlow_LaneSpan::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.TrafficFlow.LaneSpan.lanes)
  return &lanes_;
}

// repeated .metamoto.types.Vector3 positions = 4;
inline int TrafficFlow_LaneSpan::positions_size() const {
  return positions_.size();
}
inline ::metamoto::types::Vector3* TrafficFlow_LaneSpan::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficFlow.LaneSpan.positions)
  return positions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >*
TrafficFlow_LaneSpan::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.TrafficFlow.LaneSpan.positions)
  return &positions_;
}
inline const ::metamoto::types::Vector3& TrafficFlow_LaneSpan::positions(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.LaneSpan.positions)
  return positions_.Get(index);
}
inline ::metamoto::types::Vector3* TrafficFlow_LaneSpan::add_positions() {
  // @@protoc_insertion_point(field_add:metamoto.types.TrafficFlow.LaneSpan.positions)
  return positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Vector3 >&
TrafficFlow_LaneSpan::positions() const {
  // @@protoc_insertion_point(field_list:metamoto.types.TrafficFlow.LaneSpan.positions)
  return positions_;
}

// -------------------------------------------------------------------

// TrafficFlow

// int32 id = 1;
inline void TrafficFlow::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TrafficFlow::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.id)
  return id_;
}
inline void TrafficFlow::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.id)
}

// .metamoto.types.TrafficFlow.LaneSpan source = 2;
inline bool TrafficFlow::has_source() const {
  return this != internal_default_instance() && source_ != NULL;
}
inline void TrafficFlow::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) {
    delete source_;
  }
  source_ = NULL;
}
inline const ::metamoto::types::TrafficFlow_LaneSpan& TrafficFlow::_internal_source() const {
  return *source_;
}
inline const ::metamoto::types::TrafficFlow_LaneSpan& TrafficFlow::source() const {
  const ::metamoto::types::TrafficFlow_LaneSpan* p = source_;
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.source)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::TrafficFlow_LaneSpan*>(
      &::metamoto::types::_TrafficFlow_LaneSpan_default_instance_);
}
inline ::metamoto::types::TrafficFlow_LaneSpan* TrafficFlow::release_source() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficFlow.source)
  
  ::metamoto::types::TrafficFlow_LaneSpan* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::metamoto::types::TrafficFlow_LaneSpan* TrafficFlow::mutable_source() {
  
  if (source_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::TrafficFlow_LaneSpan>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficFlow.source)
  return source_;
}
inline void TrafficFlow::set_allocated_source(::metamoto::types::TrafficFlow_LaneSpan* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficFlow.source)
}

// repeated .metamoto.types.TrafficFlow.LaneSpan sinks = 3;
inline int TrafficFlow::sinks_size() const {
  return sinks_.size();
}
inline void TrafficFlow::clear_sinks() {
  sinks_.Clear();
}
inline ::metamoto::types::TrafficFlow_LaneSpan* TrafficFlow::mutable_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficFlow.sinks)
  return sinks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow_LaneSpan >*
TrafficFlow::mutable_sinks() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.TrafficFlow.sinks)
  return &sinks_;
}
inline const ::metamoto::types::TrafficFlow_LaneSpan& TrafficFlow::sinks(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.sinks)
  return sinks_.Get(index);
}
inline ::metamoto::types::TrafficFlow_LaneSpan* TrafficFlow::add_sinks() {
  // @@protoc_insertion_point(field_add:metamoto.types.TrafficFlow.sinks)
  return sinks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::TrafficFlow_LaneSpan >&
TrafficFlow::sinks() const {
  // @@protoc_insertion_point(field_list:metamoto.types.TrafficFlow.sinks)
  return sinks_;
}

// .metamoto.types.NormalDistribution generation_rate = 4;
inline bool TrafficFlow::has_generation_rate() const {
  return this != internal_default_instance() && generation_rate_ != NULL;
}
inline const ::metamoto::types::NormalDistribution& TrafficFlow::_internal_generation_rate() const {
  return *generation_rate_;
}
inline const ::metamoto::types::NormalDistribution& TrafficFlow::generation_rate() const {
  const ::metamoto::types::NormalDistribution* p = generation_rate_;
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.generation_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::NormalDistribution*>(
      &::metamoto::types::_NormalDistribution_default_instance_);
}
inline ::metamoto::types::NormalDistribution* TrafficFlow::release_generation_rate() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficFlow.generation_rate)
  
  ::metamoto::types::NormalDistribution* temp = generation_rate_;
  generation_rate_ = NULL;
  return temp;
}
inline ::metamoto::types::NormalDistribution* TrafficFlow::mutable_generation_rate() {
  
  if (generation_rate_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::NormalDistribution>(GetArenaNoVirtual());
    generation_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficFlow.generation_rate)
  return generation_rate_;
}
inline void TrafficFlow::set_allocated_generation_rate(::metamoto::types::NormalDistribution* generation_rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(generation_rate_);
  }
  if (generation_rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      generation_rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, generation_rate, submessage_arena);
    }
    
  } else {
    
  }
  generation_rate_ = generation_rate;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficFlow.generation_rate)
}

// float speed = 5;
inline void TrafficFlow::clear_speed() {
  speed_ = 0;
}
inline float TrafficFlow::speed() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.speed)
  return speed_;
}
inline void TrafficFlow::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.speed)
}

// bool populate = 6;
inline void TrafficFlow::clear_populate() {
  populate_ = false;
}
inline bool TrafficFlow::populate() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficFlow.populate)
  return populate_;
}
inline void TrafficFlow::set_populate(bool value) {
  
  populate_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficFlow.populate)
}

// -------------------------------------------------------------------

// TrafficVehicle

// string display_name = 1;
inline void TrafficVehicle::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficVehicle::display_name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficVehicle.display_name)
  return display_name_.GetNoArena();
}
inline void TrafficVehicle::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficVehicle.display_name)
}
#if LANG_CXX11
inline void TrafficVehicle::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.TrafficVehicle.display_name)
}
#endif
inline void TrafficVehicle::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.TrafficVehicle.display_name)
}
inline void TrafficVehicle::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.TrafficVehicle.display_name)
}
inline ::std::string* TrafficVehicle::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficVehicle.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficVehicle::release_display_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficVehicle.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficVehicle::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficVehicle.display_name)
}

// .metamoto.types.VehicleInstance instance = 2;
inline bool TrafficVehicle::has_instance() const {
  return this != internal_default_instance() && instance_ != NULL;
}
inline const ::metamoto::types::VehicleInstance& TrafficVehicle::_internal_instance() const {
  return *instance_;
}
inline const ::metamoto::types::VehicleInstance& TrafficVehicle::instance() const {
  const ::metamoto::types::VehicleInstance* p = instance_;
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficVehicle.instance)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::VehicleInstance*>(
      &::metamoto::types::_VehicleInstance_default_instance_);
}
inline ::metamoto::types::VehicleInstance* TrafficVehicle::release_instance() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficVehicle.instance)
  
  ::metamoto::types::VehicleInstance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline ::metamoto::types::VehicleInstance* TrafficVehicle::mutable_instance() {
  
  if (instance_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::VehicleInstance>(GetArenaNoVirtual());
    instance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficVehicle.instance)
  return instance_;
}
inline void TrafficVehicle::set_allocated_instance(::metamoto::types::VehicleInstance* instance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instance_);
  }
  if (instance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficVehicle.instance)
}

// repeated .metamoto.types.Waypoint path = 3;
inline int TrafficVehicle::path_size() const {
  return path_.size();
}
inline ::metamoto::types::Waypoint* TrafficVehicle::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficVehicle.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
TrafficVehicle::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.TrafficVehicle.path)
  return &path_;
}
inline const ::metamoto::types::Waypoint& TrafficVehicle::path(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficVehicle.path)
  return path_.Get(index);
}
inline ::metamoto::types::Waypoint* TrafficVehicle::add_path() {
  // @@protoc_insertion_point(field_add:metamoto.types.TrafficVehicle.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
TrafficVehicle::path() const {
  // @@protoc_insertion_point(field_list:metamoto.types.TrafficVehicle.path)
  return path_;
}

// .metamoto.types.DriverModel driver_model = 4;
inline bool TrafficVehicle::has_driver_model() const {
  return this != internal_default_instance() && driver_model_ != NULL;
}
inline void TrafficVehicle::clear_driver_model() {
  if (GetArenaNoVirtual() == NULL && driver_model_ != NULL) {
    delete driver_model_;
  }
  driver_model_ = NULL;
}
inline const ::metamoto::types::DriverModel& TrafficVehicle::_internal_driver_model() const {
  return *driver_model_;
}
inline const ::metamoto::types::DriverModel& TrafficVehicle::driver_model() const {
  const ::metamoto::types::DriverModel* p = driver_model_;
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficVehicle.driver_model)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::DriverModel*>(
      &::metamoto::types::_DriverModel_default_instance_);
}
inline ::metamoto::types::DriverModel* TrafficVehicle::release_driver_model() {
  // @@protoc_insertion_point(field_release:metamoto.types.TrafficVehicle.driver_model)
  
  ::metamoto::types::DriverModel* temp = driver_model_;
  driver_model_ = NULL;
  return temp;
}
inline ::metamoto::types::DriverModel* TrafficVehicle::mutable_driver_model() {
  
  if (driver_model_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::DriverModel>(GetArenaNoVirtual());
    driver_model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.TrafficVehicle.driver_model)
  return driver_model_;
}
inline void TrafficVehicle::set_allocated_driver_model(::metamoto::types::DriverModel* driver_model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete driver_model_;
  }
  if (driver_model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      driver_model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, driver_model, submessage_arena);
    }
    
  } else {
    
  }
  driver_model_ = driver_model;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.TrafficVehicle.driver_model)
}

// int32 flow_id = 5;
inline void TrafficVehicle::clear_flow_id() {
  flow_id_ = 0;
}
inline ::google::protobuf::int32 TrafficVehicle::flow_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.TrafficVehicle.flow_id)
  return flow_id_;
}
inline void TrafficVehicle::set_flow_id(::google::protobuf::int32 value) {
  
  flow_id_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.TrafficVehicle.flow_id)
}

// -------------------------------------------------------------------

// ParkedVehicle

// string display_name = 1;
inline void ParkedVehicle::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ParkedVehicle::display_name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.ParkedVehicle.display_name)
  return display_name_.GetNoArena();
}
inline void ParkedVehicle::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.ParkedVehicle.display_name)
}
#if LANG_CXX11
inline void ParkedVehicle::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.ParkedVehicle.display_name)
}
#endif
inline void ParkedVehicle::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.ParkedVehicle.display_name)
}
inline void ParkedVehicle::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.ParkedVehicle.display_name)
}
inline ::std::string* ParkedVehicle::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.ParkedVehicle.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParkedVehicle::release_display_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.ParkedVehicle.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParkedVehicle::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.ParkedVehicle.display_name)
}

// .metamoto.types.VehicleInstance instance = 2;
inline bool ParkedVehicle::has_instance() const {
  return this != internal_default_instance() && instance_ != NULL;
}
inline const ::metamoto::types::VehicleInstance& ParkedVehicle::_internal_instance() const {
  return *instance_;
}
inline const ::metamoto::types::VehicleInstance& ParkedVehicle::instance() const {
  const ::metamoto::types::VehicleInstance* p = instance_;
  // @@protoc_insertion_point(field_get:metamoto.types.ParkedVehicle.instance)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::VehicleInstance*>(
      &::metamoto::types::_VehicleInstance_default_instance_);
}
inline ::metamoto::types::VehicleInstance* ParkedVehicle::release_instance() {
  // @@protoc_insertion_point(field_release:metamoto.types.ParkedVehicle.instance)
  
  ::metamoto::types::VehicleInstance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline ::metamoto::types::VehicleInstance* ParkedVehicle::mutable_instance() {
  
  if (instance_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::VehicleInstance>(GetArenaNoVirtual());
    instance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.ParkedVehicle.instance)
  return instance_;
}
inline void ParkedVehicle::set_allocated_instance(::metamoto::types::VehicleInstance* instance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(instance_);
  }
  if (instance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.ParkedVehicle.instance)
}

// .metamoto.types.Pose world_point = 3;
inline bool ParkedVehicle::has_world_point() const {
  return point_oneof_case() == kWorldPoint;
}
inline void ParkedVehicle::set_has_world_point() {
  _oneof_case_[0] = kWorldPoint;
}
inline const ::metamoto::types::Pose& ParkedVehicle::_internal_world_point() const {
  return *point_oneof_.world_point_;
}
inline ::metamoto::types::Pose* ParkedVehicle::release_world_point() {
  // @@protoc_insertion_point(field_release:metamoto.types.ParkedVehicle.world_point)
  if (has_world_point()) {
    clear_has_point_oneof();
      ::metamoto::types::Pose* temp = point_oneof_.world_point_;
    point_oneof_.world_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::metamoto::types::Pose& ParkedVehicle::world_point() const {
  // @@protoc_insertion_point(field_get:metamoto.types.ParkedVehicle.world_point)
  return has_world_point()
      ? *point_oneof_.world_point_
      : *reinterpret_cast< ::metamoto::types::Pose*>(&::metamoto::types::_Pose_default_instance_);
}
inline ::metamoto::types::Pose* ParkedVehicle::mutable_world_point() {
  if (!has_world_point()) {
    clear_point_oneof();
    set_has_world_point();
    point_oneof_.world_point_ = CreateMaybeMessage< ::metamoto::types::Pose >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.ParkedVehicle.world_point)
  return point_oneof_.world_point_;
}

// .metamoto.types.RoadPoint road_point = 4;
inline bool ParkedVehicle::has_road_point() const {
  return point_oneof_case() == kRoadPoint;
}
inline void ParkedVehicle::set_has_road_point() {
  _oneof_case_[0] = kRoadPoint;
}
inline const ::metamoto::types::RoadPoint& ParkedVehicle::_internal_road_point() const {
  return *point_oneof_.road_point_;
}
inline ::metamoto::types::RoadPoint* ParkedVehicle::release_road_point() {
  // @@protoc_insertion_point(field_release:metamoto.types.ParkedVehicle.road_point)
  if (has_road_point()) {
    clear_has_point_oneof();
      ::metamoto::types::RoadPoint* temp = point_oneof_.road_point_;
    point_oneof_.road_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::metamoto::types::RoadPoint& ParkedVehicle::road_point() const {
  // @@protoc_insertion_point(field_get:metamoto.types.ParkedVehicle.road_point)
  return has_road_point()
      ? *point_oneof_.road_point_
      : *reinterpret_cast< ::metamoto::types::RoadPoint*>(&::metamoto::types::_RoadPoint_default_instance_);
}
inline ::metamoto::types::RoadPoint* ParkedVehicle::mutable_road_point() {
  if (!has_road_point()) {
    clear_point_oneof();
    set_has_road_point();
    point_oneof_.road_point_ = CreateMaybeMessage< ::metamoto::types::RoadPoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.ParkedVehicle.road_point)
  return point_oneof_.road_point_;
}

inline bool ParkedVehicle::has_point_oneof() const {
  return point_oneof_case() != POINT_ONEOF_NOT_SET;
}
inline void ParkedVehicle::clear_has_point_oneof() {
  _oneof_case_[0] = POINT_ONEOF_NOT_SET;
}
inline ParkedVehicle::PointOneofCase ParkedVehicle::point_oneof_case() const {
  return ParkedVehicle::PointOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PedestrianConfiguration_PathPoint

// .metamoto.types.PedestrianConfiguration.State state = 1;
inline void PedestrianConfiguration_PathPoint::clear_state() {
  state_ = 0;
}
inline ::metamoto::types::PedestrianConfiguration_State PedestrianConfiguration_PathPoint::state() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.PathPoint.state)
  return static_cast< ::metamoto::types::PedestrianConfiguration_State >(state_);
}
inline void PedestrianConfiguration_PathPoint::set_state(::metamoto::types::PedestrianConfiguration_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.PathPoint.state)
}

// uint32 state_variant = 2;
inline void PedestrianConfiguration_PathPoint::clear_state_variant() {
  state_variant_ = 0u;
}
inline ::google::protobuf::uint32 PedestrianConfiguration_PathPoint::state_variant() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.PathPoint.state_variant)
  return state_variant_;
}
inline void PedestrianConfiguration_PathPoint::set_state_variant(::google::protobuf::uint32 value) {
  
  state_variant_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.PathPoint.state_variant)
}

// .metamoto.types.Vector3 target_point = 3;
inline bool PedestrianConfiguration_PathPoint::has_target_point() const {
  return this != internal_default_instance() && target_point_ != NULL;
}
inline const ::metamoto::types::Vector3& PedestrianConfiguration_PathPoint::_internal_target_point() const {
  return *target_point_;
}
inline const ::metamoto::types::Vector3& PedestrianConfiguration_PathPoint::target_point() const {
  const ::metamoto::types::Vector3* p = target_point_;
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.PathPoint.target_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* PedestrianConfiguration_PathPoint::release_target_point() {
  // @@protoc_insertion_point(field_release:metamoto.types.PedestrianConfiguration.PathPoint.target_point)
  
  ::metamoto::types::Vector3* temp = target_point_;
  target_point_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* PedestrianConfiguration_PathPoint::mutable_target_point() {
  
  if (target_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    target_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.PedestrianConfiguration.PathPoint.target_point)
  return target_point_;
}
inline void PedestrianConfiguration_PathPoint::set_allocated_target_point(::metamoto::types::Vector3* target_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_point_);
  }
  if (target_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    
  } else {
    
  }
  target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.PedestrianConfiguration.PathPoint.target_point)
}

// float wait_time = 4;
inline void PedestrianConfiguration_PathPoint::clear_wait_time() {
  wait_time_ = 0;
}
inline float PedestrianConfiguration_PathPoint::wait_time() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.PathPoint.wait_time)
  return wait_time_;
}
inline void PedestrianConfiguration_PathPoint::set_wait_time(float value) {
  
  wait_time_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.PathPoint.wait_time)
}

// .metamoto.types.PedestrianConfiguration.PathingBehaviour pathing_behaviour = 5;
inline void PedestrianConfiguration_PathPoint::clear_pathing_behaviour() {
  pathing_behaviour_ = 0;
}
inline ::metamoto::types::PedestrianConfiguration_PathingBehaviour PedestrianConfiguration_PathPoint::pathing_behaviour() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.PathPoint.pathing_behaviour)
  return static_cast< ::metamoto::types::PedestrianConfiguration_PathingBehaviour >(pathing_behaviour_);
}
inline void PedestrianConfiguration_PathPoint::set_pathing_behaviour(::metamoto::types::PedestrianConfiguration_PathingBehaviour value) {
  
  pathing_behaviour_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.PathPoint.pathing_behaviour)
}

// -------------------------------------------------------------------

// PedestrianConfiguration

// string display_name = 1;
inline void PedestrianConfiguration::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PedestrianConfiguration::display_name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.display_name)
  return display_name_.GetNoArena();
}
inline void PedestrianConfiguration::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.display_name)
}
#if LANG_CXX11
inline void PedestrianConfiguration::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.PedestrianConfiguration.display_name)
}
#endif
inline void PedestrianConfiguration::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.PedestrianConfiguration.display_name)
}
inline void PedestrianConfiguration::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.PedestrianConfiguration.display_name)
}
inline ::std::string* PedestrianConfiguration::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.PedestrianConfiguration.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PedestrianConfiguration::release_display_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.PedestrianConfiguration.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PedestrianConfiguration::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.PedestrianConfiguration.display_name)
}

// string name = 2;
inline bool PedestrianConfiguration::has_name() const {
  return instance_oneof_case() == kName;
}
inline void PedestrianConfiguration::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void PedestrianConfiguration::clear_name() {
  if (has_name()) {
    instance_oneof_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_instance_oneof();
  }
}
inline const ::std::string& PedestrianConfiguration::name() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.name)
  if (has_name()) {
    return instance_oneof_.name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void PedestrianConfiguration::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.name)
  if (!has_name()) {
    clear_instance_oneof();
    set_has_name();
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  instance_oneof_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.name)
}
#if LANG_CXX11
inline void PedestrianConfiguration::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.name)
  if (!has_name()) {
    clear_instance_oneof();
    set_has_name();
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  instance_oneof_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.PedestrianConfiguration.name)
}
#endif
inline void PedestrianConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_name()) {
    clear_instance_oneof();
    set_has_name();
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  instance_oneof_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.PedestrianConfiguration.name)
}
inline void PedestrianConfiguration::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_instance_oneof();
    set_has_name();
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  instance_oneof_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.PedestrianConfiguration.name)
}
inline ::std::string* PedestrianConfiguration::mutable_name() {
  if (!has_name()) {
    clear_instance_oneof();
    set_has_name();
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.PedestrianConfiguration.name)
  return instance_oneof_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PedestrianConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:metamoto.types.PedestrianConfiguration.name)
  if (has_name()) {
    clear_has_instance_oneof();
    return instance_oneof_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void PedestrianConfiguration::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    instance_oneof_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_instance_oneof();
  if (name != NULL) {
    set_has_name();
    instance_oneof_.name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  }
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.PedestrianConfiguration.name)
}

// .metamoto.types.Pedestrian.Type type = 3;
inline bool PedestrianConfiguration::has_type() const {
  return instance_oneof_case() == kType;
}
inline void PedestrianConfiguration::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void PedestrianConfiguration::clear_type() {
  if (has_type()) {
    instance_oneof_.type_ = 0;
    clear_has_instance_oneof();
  }
}
inline ::metamoto::types::Pedestrian_Type PedestrianConfiguration::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.type)
  if (has_type()) {
    return static_cast< ::metamoto::types::Pedestrian_Type >(instance_oneof_.type_);
  }
  return static_cast< ::metamoto::types::Pedestrian_Type >(0);
}
inline void PedestrianConfiguration::set_type(::metamoto::types::Pedestrian_Type value) {
  if (!has_type()) {
    clear_instance_oneof();
    set_has_type();
  }
  instance_oneof_.type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.type)
}

// repeated .metamoto.types.PedestrianConfiguration.PathPoint path = 4;
inline int PedestrianConfiguration::path_size() const {
  return path_.size();
}
inline void PedestrianConfiguration::clear_path() {
  path_.Clear();
}
inline ::metamoto::types::PedestrianConfiguration_PathPoint* PedestrianConfiguration::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.PedestrianConfiguration.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration_PathPoint >*
PedestrianConfiguration::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.PedestrianConfiguration.path)
  return &path_;
}
inline const ::metamoto::types::PedestrianConfiguration_PathPoint& PedestrianConfiguration::path(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.path)
  return path_.Get(index);
}
inline ::metamoto::types::PedestrianConfiguration_PathPoint* PedestrianConfiguration::add_path() {
  // @@protoc_insertion_point(field_add:metamoto.types.PedestrianConfiguration.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::PedestrianConfiguration_PathPoint >&
PedestrianConfiguration::path() const {
  // @@protoc_insertion_point(field_list:metamoto.types.PedestrianConfiguration.path)
  return path_;
}

// bool random_path = 5;
inline void PedestrianConfiguration::clear_random_path() {
  random_path_ = false;
}
inline bool PedestrianConfiguration::random_path() const {
  // @@protoc_insertion_point(field_get:metamoto.types.PedestrianConfiguration.random_path)
  return random_path_;
}
inline void PedestrianConfiguration::set_random_path(bool value) {
  
  random_path_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.PedestrianConfiguration.random_path)
}

inline bool PedestrianConfiguration::has_instance_oneof() const {
  return instance_oneof_case() != INSTANCE_ONEOF_NOT_SET;
}
inline void PedestrianConfiguration::clear_has_instance_oneof() {
  _oneof_case_[0] = INSTANCE_ONEOF_NOT_SET;
}
inline PedestrianConfiguration::InstanceOneofCase PedestrianConfiguration::instance_oneof_case() const {
  return PedestrianConfiguration::InstanceOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_ProximityTrigger

// .metamoto.types.Vector3 location = 1;
inline bool Event_ProximityTrigger::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::metamoto::types::Vector3& Event_ProximityTrigger::_internal_location() const {
  return *location_;
}
inline const ::metamoto::types::Vector3& Event_ProximityTrigger::location() const {
  const ::metamoto::types::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:metamoto.types.Event.ProximityTrigger.location)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Event_ProximityTrigger::release_location() {
  // @@protoc_insertion_point(field_release:metamoto.types.Event.ProximityTrigger.location)
  
  ::metamoto::types::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Event_ProximityTrigger::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.ProximityTrigger.location)
  return location_;
}
inline void Event_ProximityTrigger::set_allocated_location(::metamoto::types::Vector3* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Event.ProximityTrigger.location)
}

// float radius = 2;
inline void Event_ProximityTrigger::clear_radius() {
  radius_ = 0;
}
inline float Event_ProximityTrigger::radius() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.ProximityTrigger.radius)
  return radius_;
}
inline void Event_ProximityTrigger::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Event.ProximityTrigger.radius)
}

// int32 ego_vehicle_index = 3;
inline void Event_ProximityTrigger::clear_ego_vehicle_index() {
  ego_vehicle_index_ = 0;
}
inline ::google::protobuf::int32 Event_ProximityTrigger::ego_vehicle_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.ProximityTrigger.ego_vehicle_index)
  return ego_vehicle_index_;
}
inline void Event_ProximityTrigger::set_ego_vehicle_index(::google::protobuf::int32 value) {
  
  ego_vehicle_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Event.ProximityTrigger.ego_vehicle_index)
}

// -------------------------------------------------------------------

// Event

// .metamoto.types.Event.ObjectType object_type = 1;
inline void Event::clear_object_type() {
  object_type_ = 0;
}
inline ::metamoto::types::Event_ObjectType Event::object_type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.object_type)
  return static_cast< ::metamoto::types::Event_ObjectType >(object_type_);
}
inline void Event::set_object_type(::metamoto::types::Event_ObjectType value) {
  
  object_type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Event.object_type)
}

// .metamoto.types.Event.Action action = 2;
inline void Event::clear_action() {
  action_ = 0;
}
inline ::metamoto::types::Event_Action Event::action() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.action)
  return static_cast< ::metamoto::types::Event_Action >(action_);
}
inline void Event::set_action(::metamoto::types::Event_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Event.action)
}

// double time = 3;
inline void Event::clear_time() {
  time_ = 0;
}
inline double Event::time() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.time)
  return time_;
}
inline void Event::set_time(double value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Event.time)
}

// .metamoto.types.Event.ProximityTrigger trigger = 4;
inline bool Event::has_trigger() const {
  return this != internal_default_instance() && trigger_ != NULL;
}
inline void Event::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) {
    delete trigger_;
  }
  trigger_ = NULL;
}
inline const ::metamoto::types::Event_ProximityTrigger& Event::_internal_trigger() const {
  return *trigger_;
}
inline const ::metamoto::types::Event_ProximityTrigger& Event::trigger() const {
  const ::metamoto::types::Event_ProximityTrigger* p = trigger_;
  // @@protoc_insertion_point(field_get:metamoto.types.Event.trigger)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Event_ProximityTrigger*>(
      &::metamoto::types::_Event_ProximityTrigger_default_instance_);
}
inline ::metamoto::types::Event_ProximityTrigger* Event::release_trigger() {
  // @@protoc_insertion_point(field_release:metamoto.types.Event.trigger)
  
  ::metamoto::types::Event_ProximityTrigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline ::metamoto::types::Event_ProximityTrigger* Event::mutable_trigger() {
  
  if (trigger_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Event_ProximityTrigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.trigger)
  return trigger_;
}
inline void Event::set_allocated_trigger(::metamoto::types::Event_ProximityTrigger* trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trigger_;
  }
  if (trigger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Event.trigger)
}

// string id = 5;
inline void Event::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.id)
  return id_.GetNoArena();
}
inline void Event::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Event.id)
}
#if LANG_CXX11
inline void Event::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Event.id)
}
#endif
inline void Event::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Event.id)
}
inline void Event::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Event.id)
}
inline ::std::string* Event::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Event.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Event.id)
}

// string secondary_id = 6;
inline void Event::clear_secondary_id() {
  secondary_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::secondary_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.secondary_id)
  return secondary_id_.GetNoArena();
}
inline void Event::set_secondary_id(const ::std::string& value) {
  
  secondary_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Event.secondary_id)
}
#if LANG_CXX11
inline void Event::set_secondary_id(::std::string&& value) {
  
  secondary_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Event.secondary_id)
}
#endif
inline void Event::set_secondary_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Event.secondary_id)
}
inline void Event::set_secondary_id(const char* value, size_t size) {
  
  secondary_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Event.secondary_id)
}
inline ::std::string* Event::mutable_secondary_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.secondary_id)
  return secondary_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_secondary_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Event.secondary_id)
  
  return secondary_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_secondary_id(::std::string* secondary_id) {
  if (secondary_id != NULL) {
    
  } else {
    
  }
  secondary_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Event.secondary_id)
}

// repeated string payload_string = 7;
inline int Event::payload_string_size() const {
  return payload_string_.size();
}
inline void Event::clear_payload_string() {
  payload_string_.Clear();
}
inline const ::std::string& Event::payload_string(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.payload_string)
  return payload_string_.Get(index);
}
inline ::std::string* Event::mutable_payload_string(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.payload_string)
  return payload_string_.Mutable(index);
}
inline void Event::set_payload_string(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Event.payload_string)
  payload_string_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Event::set_payload_string(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Event.payload_string)
  payload_string_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Event::set_payload_string(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  payload_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:metamoto.types.Event.payload_string)
}
inline void Event::set_payload_string(int index, const char* value, size_t size) {
  payload_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Event.payload_string)
}
inline ::std::string* Event::add_payload_string() {
  // @@protoc_insertion_point(field_add_mutable:metamoto.types.Event.payload_string)
  return payload_string_.Add();
}
inline void Event::add_payload_string(const ::std::string& value) {
  payload_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:metamoto.types.Event.payload_string)
}
#if LANG_CXX11
inline void Event::add_payload_string(::std::string&& value) {
  payload_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:metamoto.types.Event.payload_string)
}
#endif
inline void Event::add_payload_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  payload_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:metamoto.types.Event.payload_string)
}
inline void Event::add_payload_string(const char* value, size_t size) {
  payload_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:metamoto.types.Event.payload_string)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Event::payload_string() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Event.payload_string)
  return payload_string_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Event::mutable_payload_string() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Event.payload_string)
  return &payload_string_;
}

// repeated float payload_float = 8;
inline int Event::payload_float_size() const {
  return payload_float_.size();
}
inline void Event::clear_payload_float() {
  payload_float_.Clear();
}
inline float Event::payload_float(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.payload_float)
  return payload_float_.Get(index);
}
inline void Event::set_payload_float(int index, float value) {
  payload_float_.Set(index, value);
  // @@protoc_insertion_point(field_set:metamoto.types.Event.payload_float)
}
inline void Event::add_payload_float(float value) {
  payload_float_.Add(value);
  // @@protoc_insertion_point(field_add:metamoto.types.Event.payload_float)
}
inline const ::google::protobuf::RepeatedField< float >&
Event::payload_float() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Event.payload_float)
  return payload_float_;
}
inline ::google::protobuf::RepeatedField< float >*
Event::mutable_payload_float() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Event.payload_float)
  return &payload_float_;
}

// repeated .metamoto.types.Waypoint waypoints = 9;
inline int Event::waypoints_size() const {
  return waypoints_.size();
}
inline ::metamoto::types::Waypoint* Event::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Event.waypoints)
  return waypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
Event::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Event.waypoints)
  return &waypoints_;
}
inline const ::metamoto::types::Waypoint& Event::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Event.waypoints)
  return waypoints_.Get(index);
}
inline ::metamoto::types::Waypoint* Event::add_waypoints() {
  // @@protoc_insertion_point(field_add:metamoto.types.Event.waypoints)
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
Event::waypoints() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Event.waypoints)
  return waypoints_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace metamoto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::metamoto::types::Scenario_System_LevelOfDetail> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Scenario_System_LevelOfDetail>() {
  return ::metamoto::types::Scenario_System_LevelOfDetail_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Infraction_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Infraction_Type>() {
  return ::metamoto::types::Infraction_Type_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::PedestrianConfiguration_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::PedestrianConfiguration_State>() {
  return ::metamoto::types::PedestrianConfiguration_State_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::PedestrianConfiguration_PathingBehaviour> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::PedestrianConfiguration_PathingBehaviour>() {
  return ::metamoto::types::PedestrianConfiguration_PathingBehaviour_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Event_ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Event_ObjectType>() {
  return ::metamoto::types::Event_ObjectType_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Event_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Event_Action>() {
  return ::metamoto::types::Event_Action_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_metamoto_2ftypes_2fscenario_2eproto
