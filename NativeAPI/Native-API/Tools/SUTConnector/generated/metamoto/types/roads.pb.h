// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metamoto/types/roads.proto

#ifndef PROTOBUF_INCLUDED_metamoto_2ftypes_2froads_2eproto
#define PROTOBUF_INCLUDED_metamoto_2ftypes_2froads_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "metamoto/types/vector3.pb.h"
#include "metamoto/types/geo_coordinates.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_metamoto_2ftypes_2froads_2eproto 

namespace protobuf_metamoto_2ftypes_2froads_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_metamoto_2ftypes_2froads_2eproto
namespace metamoto {
namespace types {
class ConnectingRoad;
class ConnectingRoadDefaultTypeInternal;
extern ConnectingRoadDefaultTypeInternal _ConnectingRoad_default_instance_;
class Elevation;
class ElevationDefaultTypeInternal;
extern ElevationDefaultTypeInternal _Elevation_default_instance_;
class Geometry;
class GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class Geometry_Arc;
class Geometry_ArcDefaultTypeInternal;
extern Geometry_ArcDefaultTypeInternal _Geometry_Arc_default_instance_;
class Junction;
class JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Junction_Connection;
class Junction_ConnectionDefaultTypeInternal;
extern Junction_ConnectionDefaultTypeInternal _Junction_Connection_default_instance_;
class Junction_Connection_RoadLink;
class Junction_Connection_RoadLinkDefaultTypeInternal;
extern Junction_Connection_RoadLinkDefaultTypeInternal _Junction_Connection_RoadLink_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneLink;
class LaneLinkDefaultTypeInternal;
extern LaneLinkDefaultTypeInternal _LaneLink_default_instance_;
class LaneSection;
class LaneSectionDefaultTypeInternal;
extern LaneSectionDefaultTypeInternal _LaneSection_default_instance_;
class Marking;
class MarkingDefaultTypeInternal;
extern MarkingDefaultTypeInternal _Marking_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadNetwork;
class RoadNetworkDefaultTypeInternal;
extern RoadNetworkDefaultTypeInternal _RoadNetwork_default_instance_;
class RoadPoint;
class RoadPointDefaultTypeInternal;
extern RoadPointDefaultTypeInternal _RoadPoint_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Signal_LaneValidity;
class Signal_LaneValidityDefaultTypeInternal;
extern Signal_LaneValidityDefaultTypeInternal _Signal_LaneValidity_default_instance_;
}  // namespace types
}  // namespace metamoto
namespace google {
namespace protobuf {
template<> ::metamoto::types::ConnectingRoad* Arena::CreateMaybeMessage<::metamoto::types::ConnectingRoad>(Arena*);
template<> ::metamoto::types::Elevation* Arena::CreateMaybeMessage<::metamoto::types::Elevation>(Arena*);
template<> ::metamoto::types::Geometry* Arena::CreateMaybeMessage<::metamoto::types::Geometry>(Arena*);
template<> ::metamoto::types::Geometry_Arc* Arena::CreateMaybeMessage<::metamoto::types::Geometry_Arc>(Arena*);
template<> ::metamoto::types::Junction* Arena::CreateMaybeMessage<::metamoto::types::Junction>(Arena*);
template<> ::metamoto::types::Junction_Connection* Arena::CreateMaybeMessage<::metamoto::types::Junction_Connection>(Arena*);
template<> ::metamoto::types::Junction_Connection_RoadLink* Arena::CreateMaybeMessage<::metamoto::types::Junction_Connection_RoadLink>(Arena*);
template<> ::metamoto::types::Lane* Arena::CreateMaybeMessage<::metamoto::types::Lane>(Arena*);
template<> ::metamoto::types::LaneLink* Arena::CreateMaybeMessage<::metamoto::types::LaneLink>(Arena*);
template<> ::metamoto::types::LaneSection* Arena::CreateMaybeMessage<::metamoto::types::LaneSection>(Arena*);
template<> ::metamoto::types::Marking* Arena::CreateMaybeMessage<::metamoto::types::Marking>(Arena*);
template<> ::metamoto::types::Road* Arena::CreateMaybeMessage<::metamoto::types::Road>(Arena*);
template<> ::metamoto::types::RoadNetwork* Arena::CreateMaybeMessage<::metamoto::types::RoadNetwork>(Arena*);
template<> ::metamoto::types::RoadPoint* Arena::CreateMaybeMessage<::metamoto::types::RoadPoint>(Arena*);
template<> ::metamoto::types::Signal* Arena::CreateMaybeMessage<::metamoto::types::Signal>(Arena*);
template<> ::metamoto::types::Signal_LaneValidity* Arena::CreateMaybeMessage<::metamoto::types::Signal_LaneValidity>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace metamoto {
namespace types {

enum Geometry_Type {
  Geometry_Type_UNKNOWN = 0,
  Geometry_Type_OTHER = 1,
  Geometry_Type_STRAIGHT_LINE = 2,
  Geometry_Type_ARC = 3,
  Geometry_Type_Geometry_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Geometry_Type_Geometry_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Geometry_Type_IsValid(int value);
const Geometry_Type Geometry_Type_Type_MIN = Geometry_Type_UNKNOWN;
const Geometry_Type Geometry_Type_Type_MAX = Geometry_Type_ARC;
const int Geometry_Type_Type_ARRAYSIZE = Geometry_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Geometry_Type_descriptor();
inline const ::std::string& Geometry_Type_Name(Geometry_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Geometry_Type_descriptor(), value);
}
inline bool Geometry_Type_Parse(
    const ::std::string& name, Geometry_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Geometry_Type>(
    Geometry_Type_descriptor(), name, value);
}
enum Marking_Type {
  Marking_Type_TYPE_UNKNOWN = 0,
  Marking_Type_TYPE_OTHER = 1,
  Marking_Type_SOLID = 2,
  Marking_Type_DASH = 3,
  Marking_Type_CURB = 4,
  Marking_Type_DOUBLE_SOLID = 5,
  Marking_Type_SOLID_RIGHT_DASH = 6,
  Marking_Type_SOLID_LEFT_DASH = 7,
  Marking_Type_PARALLEL_PARKING = 8,
  Marking_Type_PERPENDICULAR_PARKING = 9,
  Marking_Type_ANGLED_PARKING_60 = 10,
  Marking_Type_CROSSWALK = 11,
  Marking_Type_PARKING = 12,
  Marking_Type_Marking_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Marking_Type_Marking_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Marking_Type_IsValid(int value);
const Marking_Type Marking_Type_Type_MIN = Marking_Type_TYPE_UNKNOWN;
const Marking_Type Marking_Type_Type_MAX = Marking_Type_PARKING;
const int Marking_Type_Type_ARRAYSIZE = Marking_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Marking_Type_descriptor();
inline const ::std::string& Marking_Type_Name(Marking_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Marking_Type_descriptor(), value);
}
inline bool Marking_Type_Parse(
    const ::std::string& name, Marking_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Marking_Type>(
    Marking_Type_descriptor(), name, value);
}
enum Marking_Color {
  Marking_Color_COLOR_UNKNOWN = 0,
  Marking_Color_COLOR_OTHER = 1,
  Marking_Color_WHITE = 2,
  Marking_Color_YELLOW = 3,
  Marking_Color_RED = 4,
  Marking_Color_GREEN = 5,
  Marking_Color_BLUE = 6,
  Marking_Color_Marking_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Marking_Color_Marking_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Marking_Color_IsValid(int value);
const Marking_Color Marking_Color_Color_MIN = Marking_Color_COLOR_UNKNOWN;
const Marking_Color Marking_Color_Color_MAX = Marking_Color_BLUE;
const int Marking_Color_Color_ARRAYSIZE = Marking_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* Marking_Color_descriptor();
inline const ::std::string& Marking_Color_Name(Marking_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    Marking_Color_descriptor(), value);
}
inline bool Marking_Color_Parse(
    const ::std::string& name, Marking_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Marking_Color>(
    Marking_Color_descriptor(), name, value);
}
enum Lane_Type {
  Lane_Type_UNKNOWN = 0,
  Lane_Type_OTHER = 1,
  Lane_Type_MEDIAN = 2,
  Lane_Type_CAR_LANE = 3,
  Lane_Type_PARALLEL_PARKING_LANE = 4,
  Lane_Type_BIKE_LANE = 5,
  Lane_Type_SHOULDER = 6,
  Lane_Type_PERPENDICULAR_PARKING_LANE = 7,
  Lane_Type_ANGLED_PARKING_60_LANE = 8,
  Lane_Type_PARKING_LANE = 9,
  Lane_Type_Lane_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Lane_Type_Lane_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Lane_Type_IsValid(int value);
const Lane_Type Lane_Type_Type_MIN = Lane_Type_UNKNOWN;
const Lane_Type Lane_Type_Type_MAX = Lane_Type_PARKING_LANE;
const int Lane_Type_Type_ARRAYSIZE = Lane_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_Type_descriptor();
inline const ::std::string& Lane_Type_Name(Lane_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_Type_descriptor(), value);
}
inline bool Lane_Type_Parse(
    const ::std::string& name, Lane_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_Type>(
    Lane_Type_descriptor(), name, value);
}
enum Signal_Type {
  Signal_Type_UNKNOWN = 0,
  Signal_Type_OTHER = 1,
  Signal_Type_LIGHT = 2,
  Signal_Type_LEFT_TURN_LIGHT = 3,
  Signal_Type_RIGHT_TURN_LIGHT = 4,
  Signal_Type_STOP = 5,
  Signal_Type_YIELD = 6,
  Signal_Type_IMPLICIT_YIELD = 7,
  Signal_Type_DISCONTINUITY = 8,
  Signal_Type_Signal_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signal_Type_Signal_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_UNKNOWN;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_DISCONTINUITY;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum ConnectingRoad_Direction {
  ConnectingRoad_Direction_UNKNOWN = 0,
  ConnectingRoad_Direction_OTHER = 1,
  ConnectingRoad_Direction_STRAIGHT = 2,
  ConnectingRoad_Direction_RIGHT = 3,
  ConnectingRoad_Direction_LEFT = 4,
  ConnectingRoad_Direction_UTURN = 5,
  ConnectingRoad_Direction_SOFT_RIGHT = 6,
  ConnectingRoad_Direction_SOFT_LEFT = 7,
  ConnectingRoad_Direction_ConnectingRoad_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectingRoad_Direction_ConnectingRoad_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectingRoad_Direction_IsValid(int value);
const ConnectingRoad_Direction ConnectingRoad_Direction_Direction_MIN = ConnectingRoad_Direction_UNKNOWN;
const ConnectingRoad_Direction ConnectingRoad_Direction_Direction_MAX = ConnectingRoad_Direction_SOFT_LEFT;
const int ConnectingRoad_Direction_Direction_ARRAYSIZE = ConnectingRoad_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectingRoad_Direction_descriptor();
inline const ::std::string& ConnectingRoad_Direction_Name(ConnectingRoad_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectingRoad_Direction_descriptor(), value);
}
inline bool ConnectingRoad_Direction_Parse(
    const ::std::string& name, ConnectingRoad_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectingRoad_Direction>(
    ConnectingRoad_Direction_descriptor(), name, value);
}
enum Junction_Connection_RoadLink_ContactType {
  Junction_Connection_RoadLink_ContactType_START = 0,
  Junction_Connection_RoadLink_ContactType_END = 1,
  Junction_Connection_RoadLink_ContactType_Junction_Connection_RoadLink_ContactType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Junction_Connection_RoadLink_ContactType_Junction_Connection_RoadLink_ContactType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Junction_Connection_RoadLink_ContactType_IsValid(int value);
const Junction_Connection_RoadLink_ContactType Junction_Connection_RoadLink_ContactType_ContactType_MIN = Junction_Connection_RoadLink_ContactType_START;
const Junction_Connection_RoadLink_ContactType Junction_Connection_RoadLink_ContactType_ContactType_MAX = Junction_Connection_RoadLink_ContactType_END;
const int Junction_Connection_RoadLink_ContactType_ContactType_ARRAYSIZE = Junction_Connection_RoadLink_ContactType_ContactType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Junction_Connection_RoadLink_ContactType_descriptor();
inline const ::std::string& Junction_Connection_RoadLink_ContactType_Name(Junction_Connection_RoadLink_ContactType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Junction_Connection_RoadLink_ContactType_descriptor(), value);
}
inline bool Junction_Connection_RoadLink_ContactType_Parse(
    const ::std::string& name, Junction_Connection_RoadLink_ContactType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Junction_Connection_RoadLink_ContactType>(
    Junction_Connection_RoadLink_ContactType_descriptor(), name, value);
}
// ===================================================================

class Elevation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Elevation) */ {
 public:
  Elevation();
  virtual ~Elevation();

  Elevation(const Elevation& from);

  inline Elevation& operator=(const Elevation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Elevation(Elevation&& from) noexcept
    : Elevation() {
    *this = ::std::move(from);
  }

  inline Elevation& operator=(Elevation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Elevation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Elevation* internal_default_instance() {
    return reinterpret_cast<const Elevation*>(
               &_Elevation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Elevation* other);
  friend void swap(Elevation& a, Elevation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Elevation* New() const final {
    return CreateMaybeMessage<Elevation>(NULL);
  }

  Elevation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Elevation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Elevation& from);
  void MergeFrom(const Elevation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Elevation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float s = 1;
  void clear_s();
  static const int kSFieldNumber = 1;
  float s() const;
  void set_s(float value);

  // float a = 2;
  void clear_a();
  static const int kAFieldNumber = 2;
  float a() const;
  void set_a(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // float c = 4;
  void clear_c();
  static const int kCFieldNumber = 4;
  float c() const;
  void set_c(float value);

  // float d = 5;
  void clear_d();
  static const int kDFieldNumber = 5;
  float d() const;
  void set_d(float value);

  // bool reversed = 6;
  void clear_reversed();
  static const int kReversedFieldNumber = 6;
  bool reversed() const;
  void set_reversed(bool value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Elevation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float s_;
  float a_;
  float b_;
  float c_;
  float d_;
  bool reversed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geometry_Arc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Geometry.Arc) */ {
 public:
  Geometry_Arc();
  virtual ~Geometry_Arc();

  Geometry_Arc(const Geometry_Arc& from);

  inline Geometry_Arc& operator=(const Geometry_Arc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geometry_Arc(Geometry_Arc&& from) noexcept
    : Geometry_Arc() {
    *this = ::std::move(from);
  }

  inline Geometry_Arc& operator=(Geometry_Arc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry_Arc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geometry_Arc* internal_default_instance() {
    return reinterpret_cast<const Geometry_Arc*>(
               &_Geometry_Arc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Geometry_Arc* other);
  friend void swap(Geometry_Arc& a, Geometry_Arc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geometry_Arc* New() const final {
    return CreateMaybeMessage<Geometry_Arc>(NULL);
  }

  Geometry_Arc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geometry_Arc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geometry_Arc& from);
  void MergeFrom(const Geometry_Arc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geometry_Arc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 center = 3;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 3;
  private:
  const ::metamoto::types::Vector3& _internal_center() const;
  public:
  const ::metamoto::types::Vector3& center() const;
  ::metamoto::types::Vector3* release_center();
  ::metamoto::types::Vector3* mutable_center();
  void set_allocated_center(::metamoto::types::Vector3* center);

  // float radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // float angle = 2;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  float angle() const;
  void set_angle(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Geometry.Arc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* center_;
  float radius_;
  float angle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Geometry) */ {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Geometry* other);
  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const final {
    return CreateMaybeMessage<Geometry>(NULL);
  }

  Geometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Geometry_Arc Arc;

  typedef Geometry_Type Type;
  static const Type UNKNOWN =
    Geometry_Type_UNKNOWN;
  static const Type OTHER =
    Geometry_Type_OTHER;
  static const Type STRAIGHT_LINE =
    Geometry_Type_STRAIGHT_LINE;
  static const Type ARC =
    Geometry_Type_ARC;
  static inline bool Type_IsValid(int value) {
    return Geometry_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Geometry_Type_Type_MIN;
  static const Type Type_MAX =
    Geometry_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Geometry_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Geometry_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Geometry_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Geometry_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  private:
  const ::metamoto::types::Vector3& _internal_start() const;
  public:
  const ::metamoto::types::Vector3& start() const;
  ::metamoto::types::Vector3* release_start();
  ::metamoto::types::Vector3* mutable_start();
  void set_allocated_start(::metamoto::types::Vector3* start);

  // .metamoto.types.Vector3 heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  private:
  const ::metamoto::types::Vector3& _internal_heading() const;
  public:
  const ::metamoto::types::Vector3& heading() const;
  ::metamoto::types::Vector3* release_heading();
  ::metamoto::types::Vector3* mutable_heading();
  void set_allocated_heading(::metamoto::types::Vector3* heading);

  // .metamoto.types.Geometry.Arc arc = 6;
  bool has_arc() const;
  void clear_arc();
  static const int kArcFieldNumber = 6;
  private:
  const ::metamoto::types::Geometry_Arc& _internal_arc() const;
  public:
  const ::metamoto::types::Geometry_Arc& arc() const;
  ::metamoto::types::Geometry_Arc* release_arc();
  ::metamoto::types::Geometry_Arc* mutable_arc();
  void set_allocated_arc(::metamoto::types::Geometry_Arc* arc);

  // .metamoto.types.Geometry.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::metamoto::types::Geometry_Type type() const;
  void set_type(::metamoto::types::Geometry_Type value);

  // float s = 4;
  void clear_s();
  static const int kSFieldNumber = 4;
  float s() const;
  void set_s(float value);

  // float length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  float length() const;
  void set_length(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Geometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* start_;
  ::metamoto::types::Vector3* heading_;
  ::metamoto::types::Geometry_Arc* arc_;
  int type_;
  float s_;
  float length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Marking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Marking) */ {
 public:
  Marking();
  virtual ~Marking();

  Marking(const Marking& from);

  inline Marking& operator=(const Marking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Marking(Marking&& from) noexcept
    : Marking() {
    *this = ::std::move(from);
  }

  inline Marking& operator=(Marking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Marking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Marking* internal_default_instance() {
    return reinterpret_cast<const Marking*>(
               &_Marking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Marking* other);
  friend void swap(Marking& a, Marking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Marking* New() const final {
    return CreateMaybeMessage<Marking>(NULL);
  }

  Marking* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Marking>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Marking& from);
  void MergeFrom(const Marking& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Marking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Marking_Type Type;
  static const Type TYPE_UNKNOWN =
    Marking_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    Marking_Type_TYPE_OTHER;
  static const Type SOLID =
    Marking_Type_SOLID;
  static const Type DASH =
    Marking_Type_DASH;
  static const Type CURB =
    Marking_Type_CURB;
  static const Type DOUBLE_SOLID =
    Marking_Type_DOUBLE_SOLID;
  static const Type SOLID_RIGHT_DASH =
    Marking_Type_SOLID_RIGHT_DASH;
  static const Type SOLID_LEFT_DASH =
    Marking_Type_SOLID_LEFT_DASH;
  static const Type PARALLEL_PARKING =
    Marking_Type_PARALLEL_PARKING;
  static const Type PERPENDICULAR_PARKING =
    Marking_Type_PERPENDICULAR_PARKING;
  static const Type ANGLED_PARKING_60 =
    Marking_Type_ANGLED_PARKING_60;
  static const Type CROSSWALK =
    Marking_Type_CROSSWALK;
  static const Type PARKING =
    Marking_Type_PARKING;
  static inline bool Type_IsValid(int value) {
    return Marking_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Marking_Type_Type_MIN;
  static const Type Type_MAX =
    Marking_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Marking_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Marking_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Marking_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Marking_Type_Parse(name, value);
  }

  typedef Marking_Color Color;
  static const Color COLOR_UNKNOWN =
    Marking_Color_COLOR_UNKNOWN;
  static const Color COLOR_OTHER =
    Marking_Color_COLOR_OTHER;
  static const Color WHITE =
    Marking_Color_WHITE;
  static const Color YELLOW =
    Marking_Color_YELLOW;
  static const Color RED =
    Marking_Color_RED;
  static const Color GREEN =
    Marking_Color_GREEN;
  static const Color BLUE =
    Marking_Color_BLUE;
  static inline bool Color_IsValid(int value) {
    return Marking_Color_IsValid(value);
  }
  static const Color Color_MIN =
    Marking_Color_Color_MIN;
  static const Color Color_MAX =
    Marking_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    Marking_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return Marking_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return Marking_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return Marking_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue s = 3;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 3;
  private:
  const ::google::protobuf::FloatValue& _internal_s() const;
  public:
  const ::google::protobuf::FloatValue& s() const;
  ::google::protobuf::FloatValue* release_s();
  ::google::protobuf::FloatValue* mutable_s();
  void set_allocated_s(::google::protobuf::FloatValue* s);

  // .google.protobuf.FloatValue t = 4;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 4;
  private:
  const ::google::protobuf::FloatValue& _internal_t() const;
  public:
  const ::google::protobuf::FloatValue& t() const;
  ::google::protobuf::FloatValue* release_t();
  ::google::protobuf::FloatValue* mutable_t();
  void set_allocated_t(::google::protobuf::FloatValue* t);

  // .metamoto.types.Marking.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::metamoto::types::Marking_Type type() const;
  void set_type(::metamoto::types::Marking_Type value);

  // .metamoto.types.Marking.Color color = 2;
  void clear_color();
  static const int kColorFieldNumber = 2;
  ::metamoto::types::Marking_Color color() const;
  void set_color(::metamoto::types::Marking_Color value);

  // float heading_offset = 5;
  void clear_heading_offset();
  static const int kHeadingOffsetFieldNumber = 5;
  float heading_offset() const;
  void set_heading_offset(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Marking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* s_;
  ::google::protobuf::FloatValue* t_;
  int type_;
  int color_;
  float heading_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Lane_Type Type;
  static const Type UNKNOWN =
    Lane_Type_UNKNOWN;
  static const Type OTHER =
    Lane_Type_OTHER;
  static const Type MEDIAN =
    Lane_Type_MEDIAN;
  static const Type CAR_LANE =
    Lane_Type_CAR_LANE;
  static const Type PARALLEL_PARKING_LANE =
    Lane_Type_PARALLEL_PARKING_LANE;
  static const Type BIKE_LANE =
    Lane_Type_BIKE_LANE;
  static const Type SHOULDER =
    Lane_Type_SHOULDER;
  static const Type PERPENDICULAR_PARKING_LANE =
    Lane_Type_PERPENDICULAR_PARKING_LANE;
  static const Type ANGLED_PARKING_60_LANE =
    Lane_Type_ANGLED_PARKING_60_LANE;
  static const Type PARKING_LANE =
    Lane_Type_PARKING_LANE;
  static inline bool Type_IsValid(int value) {
    return Lane_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Lane_Type_Type_MIN;
  static const Type Type_MAX =
    Lane_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Lane_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Lane_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Lane_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Lane_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Marking markings = 8;
  int markings_size() const;
  void clear_markings();
  static const int kMarkingsFieldNumber = 8;
  ::metamoto::types::Marking* mutable_markings(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Marking >*
      mutable_markings();
  const ::metamoto::types::Marking& markings(int index) const;
  ::metamoto::types::Marking* add_markings();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Marking >&
      markings() const;

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // .metamoto.types.Lane.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::metamoto::types::Lane_Type type() const;
  void set_type(::metamoto::types::Lane_Type value);

  // float width0 = 4;
  void clear_width0();
  static const int kWidth0FieldNumber = 4;
  float width0() const;
  void set_width0(float value);

  // float width1 = 5;
  void clear_width1();
  static const int kWidth1FieldNumber = 5;
  float width1() const;
  void set_width1(float value);

  // float center0 = 6;
  void clear_center0();
  static const int kCenter0FieldNumber = 6;
  float center0() const;
  void set_center0(float value);

  // float center1 = 7;
  void clear_center1();
  static const int kCenter1FieldNumber = 7;
  float center1() const;
  void set_center1(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Marking > markings_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int32 index_;
  int type_;
  float width0_;
  float width1_;
  float center0_;
  float center1_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.LaneLink) */ {
 public:
  LaneLink();
  virtual ~LaneLink();

  LaneLink(const LaneLink& from);

  inline LaneLink& operator=(const LaneLink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLink(LaneLink&& from) noexcept
    : LaneLink() {
    *this = ::std::move(from);
  }

  inline LaneLink& operator=(LaneLink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLink* internal_default_instance() {
    return reinterpret_cast<const LaneLink*>(
               &_LaneLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(LaneLink* other);
  friend void swap(LaneLink& a, LaneLink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLink* New() const final {
    return CreateMaybeMessage<LaneLink>(NULL);
  }

  LaneLink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneLink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneLink& from);
  void MergeFrom(const LaneLink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from_lane_id = 3;
  void clear_from_lane_id();
  static const int kFromLaneIdFieldNumber = 3;
  const ::std::string& from_lane_id() const;
  void set_from_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void set_from_lane_id(::std::string&& value);
  #endif
  void set_from_lane_id(const char* value);
  void set_from_lane_id(const char* value, size_t size);
  ::std::string* mutable_from_lane_id();
  ::std::string* release_from_lane_id();
  void set_allocated_from_lane_id(::std::string* from_lane_id);

  // string to_lane_id = 4;
  void clear_to_lane_id();
  static const int kToLaneIdFieldNumber = 4;
  const ::std::string& to_lane_id() const;
  void set_to_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void set_to_lane_id(::std::string&& value);
  #endif
  void set_to_lane_id(const char* value);
  void set_to_lane_id(const char* value, size_t size);
  ::std::string* mutable_to_lane_id();
  ::std::string* release_to_lane_id();
  void set_allocated_to_lane_id(::std::string* to_lane_id);

  // string lane_id = 6;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 6;
  const ::std::string& lane_id() const;
  void set_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void set_lane_id(::std::string&& value);
  #endif
  void set_lane_id(const char* value);
  void set_lane_id(const char* value, size_t size);
  ::std::string* mutable_lane_id();
  ::std::string* release_lane_id();
  void set_allocated_lane_id(::std::string* lane_id);

  // int32 from_lane_index = 1;
  void clear_from_lane_index();
  static const int kFromLaneIndexFieldNumber = 1;
  ::google::protobuf::int32 from_lane_index() const;
  void set_from_lane_index(::google::protobuf::int32 value);

  // int32 to_lane_index = 2;
  void clear_to_lane_index();
  static const int kToLaneIndexFieldNumber = 2;
  ::google::protobuf::int32 to_lane_index() const;
  void set_to_lane_index(::google::protobuf::int32 value);

  // int32 lane_index = 5;
  void clear_lane_index();
  static const int kLaneIndexFieldNumber = 5;
  ::google::protobuf::int32 lane_index() const;
  void set_lane_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.LaneLink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_lane_id_;
  ::google::protobuf::internal::ArenaStringPtr to_lane_id_;
  ::google::protobuf::internal::ArenaStringPtr lane_id_;
  ::google::protobuf::int32 from_lane_index_;
  ::google::protobuf::int32 to_lane_index_;
  ::google::protobuf::int32 lane_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal_LaneValidity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Signal.LaneValidity) */ {
 public:
  Signal_LaneValidity();
  virtual ~Signal_LaneValidity();

  Signal_LaneValidity(const Signal_LaneValidity& from);

  inline Signal_LaneValidity& operator=(const Signal_LaneValidity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_LaneValidity(Signal_LaneValidity&& from) noexcept
    : Signal_LaneValidity() {
    *this = ::std::move(from);
  }

  inline Signal_LaneValidity& operator=(Signal_LaneValidity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal_LaneValidity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_LaneValidity* internal_default_instance() {
    return reinterpret_cast<const Signal_LaneValidity*>(
               &_Signal_LaneValidity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Signal_LaneValidity* other);
  friend void swap(Signal_LaneValidity& a, Signal_LaneValidity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_LaneValidity* New() const final {
    return CreateMaybeMessage<Signal_LaneValidity>(NULL);
  }

  Signal_LaneValidity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal_LaneValidity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal_LaneValidity& from);
  void MergeFrom(const Signal_LaneValidity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal_LaneValidity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 from_lane_index = 1;
  void clear_from_lane_index();
  static const int kFromLaneIndexFieldNumber = 1;
  ::google::protobuf::int32 from_lane_index() const;
  void set_from_lane_index(::google::protobuf::int32 value);

  // int32 to_lane_index = 2;
  void clear_to_lane_index();
  static const int kToLaneIndexFieldNumber = 2;
  ::google::protobuf::int32 to_lane_index() const;
  void set_to_lane_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Signal.LaneValidity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 from_lane_index_;
  ::google::protobuf::int32 to_lane_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signal_LaneValidity LaneValidity;

  typedef Signal_Type Type;
  static const Type UNKNOWN =
    Signal_Type_UNKNOWN;
  static const Type OTHER =
    Signal_Type_OTHER;
  static const Type LIGHT =
    Signal_Type_LIGHT;
  static const Type LEFT_TURN_LIGHT =
    Signal_Type_LEFT_TURN_LIGHT;
  static const Type RIGHT_TURN_LIGHT =
    Signal_Type_RIGHT_TURN_LIGHT;
  static const Type STOP =
    Signal_Type_STOP;
  static const Type YIELD =
    Signal_Type_YIELD;
  static const Type IMPLICIT_YIELD =
    Signal_Type_IMPLICIT_YIELD;
  static const Type DISCONTINUITY =
    Signal_Type_DISCONTINUITY;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .metamoto.types.Signal.LaneValidity lane_validity = 4;
  bool has_lane_validity() const;
  void clear_lane_validity();
  static const int kLaneValidityFieldNumber = 4;
  private:
  const ::metamoto::types::Signal_LaneValidity& _internal_lane_validity() const;
  public:
  const ::metamoto::types::Signal_LaneValidity& lane_validity() const;
  ::metamoto::types::Signal_LaneValidity* release_lane_validity();
  ::metamoto::types::Signal_LaneValidity* mutable_lane_validity();
  void set_allocated_lane_validity(::metamoto::types::Signal_LaneValidity* lane_validity);

  // .metamoto.types.Signal.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::metamoto::types::Signal_Type type() const;
  void set_type(::metamoto::types::Signal_Type value);

  // float s = 3;
  void clear_s();
  static const int kSFieldNumber = 3;
  float s() const;
  void set_s(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::metamoto::types::Signal_LaneValidity* lane_validity_;
  int type_;
  float s_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectingRoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.ConnectingRoad) */ {
 public:
  ConnectingRoad();
  virtual ~ConnectingRoad();

  ConnectingRoad(const ConnectingRoad& from);

  inline ConnectingRoad& operator=(const ConnectingRoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectingRoad(ConnectingRoad&& from) noexcept
    : ConnectingRoad() {
    *this = ::std::move(from);
  }

  inline ConnectingRoad& operator=(ConnectingRoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectingRoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectingRoad* internal_default_instance() {
    return reinterpret_cast<const ConnectingRoad*>(
               &_ConnectingRoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ConnectingRoad* other);
  friend void swap(ConnectingRoad& a, ConnectingRoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectingRoad* New() const final {
    return CreateMaybeMessage<ConnectingRoad>(NULL);
  }

  ConnectingRoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectingRoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectingRoad& from);
  void MergeFrom(const ConnectingRoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectingRoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectingRoad_Direction Direction;
  static const Direction UNKNOWN =
    ConnectingRoad_Direction_UNKNOWN;
  static const Direction OTHER =
    ConnectingRoad_Direction_OTHER;
  static const Direction STRAIGHT =
    ConnectingRoad_Direction_STRAIGHT;
  static const Direction RIGHT =
    ConnectingRoad_Direction_RIGHT;
  static const Direction LEFT =
    ConnectingRoad_Direction_LEFT;
  static const Direction UTURN =
    ConnectingRoad_Direction_UTURN;
  static const Direction SOFT_RIGHT =
    ConnectingRoad_Direction_SOFT_RIGHT;
  static const Direction SOFT_LEFT =
    ConnectingRoad_Direction_SOFT_LEFT;
  static inline bool Direction_IsValid(int value) {
    return ConnectingRoad_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    ConnectingRoad_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    ConnectingRoad_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    ConnectingRoad_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return ConnectingRoad_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return ConnectingRoad_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return ConnectingRoad_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.LaneLink lane_links = 3;
  int lane_links_size() const;
  void clear_lane_links();
  static const int kLaneLinksFieldNumber = 3;
  ::metamoto::types::LaneLink* mutable_lane_links(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneLink >*
      mutable_lane_links();
  const ::metamoto::types::LaneLink& lane_links(int index) const;
  ::metamoto::types::LaneLink* add_lane_links();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneLink >&
      lane_links() const;

  // string in_junction_id = 1;
  void clear_in_junction_id();
  static const int kInJunctionIdFieldNumber = 1;
  const ::std::string& in_junction_id() const;
  void set_in_junction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_in_junction_id(::std::string&& value);
  #endif
  void set_in_junction_id(const char* value);
  void set_in_junction_id(const char* value, size_t size);
  ::std::string* mutable_in_junction_id();
  ::std::string* release_in_junction_id();
  void set_allocated_in_junction_id(::std::string* in_junction_id);

  // .metamoto.types.ConnectingRoad.Direction type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::metamoto::types::ConnectingRoad_Direction type() const;
  void set_type(::metamoto::types::ConnectingRoad_Direction value);

  // @@protoc_insertion_point(class_scope:metamoto.types.ConnectingRoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneLink > lane_links_;
  ::google::protobuf::internal::ArenaStringPtr in_junction_id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneSection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.LaneSection) */ {
 public:
  LaneSection();
  virtual ~LaneSection();

  LaneSection(const LaneSection& from);

  inline LaneSection& operator=(const LaneSection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneSection(LaneSection&& from) noexcept
    : LaneSection() {
    *this = ::std::move(from);
  }

  inline LaneSection& operator=(LaneSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneSection* internal_default_instance() {
    return reinterpret_cast<const LaneSection*>(
               &_LaneSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(LaneSection* other);
  friend void swap(LaneSection& a, LaneSection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneSection* New() const final {
    return CreateMaybeMessage<LaneSection>(NULL);
  }

  LaneSection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneSection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneSection& from);
  void MergeFrom(const LaneSection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneSection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Lane lanes = 3;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 3;
  ::metamoto::types::Lane* mutable_lanes(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Lane >*
      mutable_lanes();
  const ::metamoto::types::Lane& lanes(int index) const;
  ::metamoto::types::Lane* add_lanes();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Lane >&
      lanes() const;

  // float s0 = 1;
  void clear_s0();
  static const int kS0FieldNumber = 1;
  float s0() const;
  void set_s0(float value);

  // float s1 = 2;
  void clear_s1();
  static const int kS1FieldNumber = 2;
  float s1() const;
  void set_s1(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.LaneSection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Lane > lanes_;
  float s0_;
  float s1_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(Road&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Road* other);
  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Road* New() const final {
    return CreateMaybeMessage<Road>(NULL);
  }

  Road* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Geometry geometries = 5;
  int geometries_size() const;
  void clear_geometries();
  static const int kGeometriesFieldNumber = 5;
  ::metamoto::types::Geometry* mutable_geometries(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Geometry >*
      mutable_geometries();
  const ::metamoto::types::Geometry& geometries(int index) const;
  ::metamoto::types::Geometry* add_geometries();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Geometry >&
      geometries() const;

  // repeated .metamoto.types.LaneSection lane_sections = 6;
  int lane_sections_size() const;
  void clear_lane_sections();
  static const int kLaneSectionsFieldNumber = 6;
  ::metamoto::types::LaneSection* mutable_lane_sections(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneSection >*
      mutable_lane_sections();
  const ::metamoto::types::LaneSection& lane_sections(int index) const;
  ::metamoto::types::LaneSection* add_lane_sections();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneSection >&
      lane_sections() const;

  // repeated .metamoto.types.Signal signals = 7;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 7;
  ::metamoto::types::Signal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Signal >*
      mutable_signals();
  const ::metamoto::types::Signal& signals(int index) const;
  ::metamoto::types::Signal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Signal >&
      signals() const;

  // repeated string predecessor_road_ids = 9;
  int predecessor_road_ids_size() const;
  void clear_predecessor_road_ids();
  static const int kPredecessorRoadIdsFieldNumber = 9;
  const ::std::string& predecessor_road_ids(int index) const;
  ::std::string* mutable_predecessor_road_ids(int index);
  void set_predecessor_road_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_predecessor_road_ids(int index, ::std::string&& value);
  #endif
  void set_predecessor_road_ids(int index, const char* value);
  void set_predecessor_road_ids(int index, const char* value, size_t size);
  ::std::string* add_predecessor_road_ids();
  void add_predecessor_road_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_predecessor_road_ids(::std::string&& value);
  #endif
  void add_predecessor_road_ids(const char* value);
  void add_predecessor_road_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& predecessor_road_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_predecessor_road_ids();

  // repeated string successor_road_ids = 10;
  int successor_road_ids_size() const;
  void clear_successor_road_ids();
  static const int kSuccessorRoadIdsFieldNumber = 10;
  const ::std::string& successor_road_ids(int index) const;
  ::std::string* mutable_successor_road_ids(int index);
  void set_successor_road_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_successor_road_ids(int index, ::std::string&& value);
  #endif
  void set_successor_road_ids(int index, const char* value);
  void set_successor_road_ids(int index, const char* value, size_t size);
  ::std::string* add_successor_road_ids();
  void add_successor_road_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_successor_road_ids(::std::string&& value);
  #endif
  void add_successor_road_ids(const char* value);
  void add_successor_road_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& successor_road_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_successor_road_ids();

  // repeated .metamoto.types.Elevation elevation = 13;
  int elevation_size() const;
  void clear_elevation();
  static const int kElevationFieldNumber = 13;
  ::metamoto::types::Elevation* mutable_elevation(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Elevation >*
      mutable_elevation();
  const ::metamoto::types::Elevation& elevation(int index) const;
  ::metamoto::types::Elevation* add_elevation();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Elevation >&
      elevation() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string predecessor_junction_id = 11;
  void clear_predecessor_junction_id();
  static const int kPredecessorJunctionIdFieldNumber = 11;
  const ::std::string& predecessor_junction_id() const;
  void set_predecessor_junction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_predecessor_junction_id(::std::string&& value);
  #endif
  void set_predecessor_junction_id(const char* value);
  void set_predecessor_junction_id(const char* value, size_t size);
  ::std::string* mutable_predecessor_junction_id();
  ::std::string* release_predecessor_junction_id();
  void set_allocated_predecessor_junction_id(::std::string* predecessor_junction_id);

  // string successor_junction_id = 12;
  void clear_successor_junction_id();
  static const int kSuccessorJunctionIdFieldNumber = 12;
  const ::std::string& successor_junction_id() const;
  void set_successor_junction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_successor_junction_id(::std::string&& value);
  #endif
  void set_successor_junction_id(const char* value);
  void set_successor_junction_id(const char* value, size_t size);
  ::std::string* mutable_successor_junction_id();
  ::std::string* release_successor_junction_id();
  void set_allocated_successor_junction_id(::std::string* successor_junction_id);

  // .metamoto.types.ConnectingRoad connecting_road = 8;
  bool has_connecting_road() const;
  void clear_connecting_road();
  static const int kConnectingRoadFieldNumber = 8;
  private:
  const ::metamoto::types::ConnectingRoad& _internal_connecting_road() const;
  public:
  const ::metamoto::types::ConnectingRoad& connecting_road() const;
  ::metamoto::types::ConnectingRoad* release_connecting_road();
  ::metamoto::types::ConnectingRoad* mutable_connecting_road();
  void set_allocated_connecting_road(::metamoto::types::ConnectingRoad* connecting_road);

  // float length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  float length() const;
  void set_length(float value);

  // float speed_limit = 3;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 3;
  float speed_limit() const;
  void set_speed_limit(float value);

  // bool one_way = 4;
  void clear_one_way();
  static const int kOneWayFieldNumber = 4;
  bool one_way() const;
  void set_one_way(bool value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Road)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Geometry > geometries_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneSection > lane_sections_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Signal > signals_;
  ::google::protobuf::RepeatedPtrField< ::std::string> predecessor_road_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> successor_road_ids_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Elevation > elevation_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr predecessor_junction_id_;
  ::google::protobuf::internal::ArenaStringPtr successor_junction_id_;
  ::metamoto::types::ConnectingRoad* connecting_road_;
  float length_;
  float speed_limit_;
  bool one_way_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Junction_Connection_RoadLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Junction.Connection.RoadLink) */ {
 public:
  Junction_Connection_RoadLink();
  virtual ~Junction_Connection_RoadLink();

  Junction_Connection_RoadLink(const Junction_Connection_RoadLink& from);

  inline Junction_Connection_RoadLink& operator=(const Junction_Connection_RoadLink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction_Connection_RoadLink(Junction_Connection_RoadLink&& from) noexcept
    : Junction_Connection_RoadLink() {
    *this = ::std::move(from);
  }

  inline Junction_Connection_RoadLink& operator=(Junction_Connection_RoadLink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction_Connection_RoadLink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction_Connection_RoadLink* internal_default_instance() {
    return reinterpret_cast<const Junction_Connection_RoadLink*>(
               &_Junction_Connection_RoadLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Junction_Connection_RoadLink* other);
  friend void swap(Junction_Connection_RoadLink& a, Junction_Connection_RoadLink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction_Connection_RoadLink* New() const final {
    return CreateMaybeMessage<Junction_Connection_RoadLink>(NULL);
  }

  Junction_Connection_RoadLink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Junction_Connection_RoadLink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Junction_Connection_RoadLink& from);
  void MergeFrom(const Junction_Connection_RoadLink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction_Connection_RoadLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Junction_Connection_RoadLink_ContactType ContactType;
  static const ContactType START =
    Junction_Connection_RoadLink_ContactType_START;
  static const ContactType END =
    Junction_Connection_RoadLink_ContactType_END;
  static inline bool ContactType_IsValid(int value) {
    return Junction_Connection_RoadLink_ContactType_IsValid(value);
  }
  static const ContactType ContactType_MIN =
    Junction_Connection_RoadLink_ContactType_ContactType_MIN;
  static const ContactType ContactType_MAX =
    Junction_Connection_RoadLink_ContactType_ContactType_MAX;
  static const int ContactType_ARRAYSIZE =
    Junction_Connection_RoadLink_ContactType_ContactType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContactType_descriptor() {
    return Junction_Connection_RoadLink_ContactType_descriptor();
  }
  static inline const ::std::string& ContactType_Name(ContactType value) {
    return Junction_Connection_RoadLink_ContactType_Name(value);
  }
  static inline bool ContactType_Parse(const ::std::string& name,
      ContactType* value) {
    return Junction_Connection_RoadLink_ContactType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string road_id = 1;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 1;
  const ::std::string& road_id() const;
  void set_road_id(const ::std::string& value);
  #if LANG_CXX11
  void set_road_id(::std::string&& value);
  #endif
  void set_road_id(const char* value);
  void set_road_id(const char* value, size_t size);
  ::std::string* mutable_road_id();
  ::std::string* release_road_id();
  void set_allocated_road_id(::std::string* road_id);

  // .metamoto.types.Junction.Connection.RoadLink.ContactType contact_type = 2;
  void clear_contact_type();
  static const int kContactTypeFieldNumber = 2;
  ::metamoto::types::Junction_Connection_RoadLink_ContactType contact_type() const;
  void set_contact_type(::metamoto::types::Junction_Connection_RoadLink_ContactType value);

  // @@protoc_insertion_point(class_scope:metamoto.types.Junction.Connection.RoadLink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr road_id_;
  int contact_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Junction_Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Junction.Connection) */ {
 public:
  Junction_Connection();
  virtual ~Junction_Connection();

  Junction_Connection(const Junction_Connection& from);

  inline Junction_Connection& operator=(const Junction_Connection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction_Connection(Junction_Connection&& from) noexcept
    : Junction_Connection() {
    *this = ::std::move(from);
  }

  inline Junction_Connection& operator=(Junction_Connection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction_Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction_Connection* internal_default_instance() {
    return reinterpret_cast<const Junction_Connection*>(
               &_Junction_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Junction_Connection* other);
  friend void swap(Junction_Connection& a, Junction_Connection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction_Connection* New() const final {
    return CreateMaybeMessage<Junction_Connection>(NULL);
  }

  Junction_Connection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Junction_Connection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Junction_Connection& from);
  void MergeFrom(const Junction_Connection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction_Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Junction_Connection_RoadLink RoadLink;

  // accessors -------------------------------------------------------

  // string connecting_road_id = 3;
  void clear_connecting_road_id();
  static const int kConnectingRoadIdFieldNumber = 3;
  const ::std::string& connecting_road_id() const;
  void set_connecting_road_id(const ::std::string& value);
  #if LANG_CXX11
  void set_connecting_road_id(::std::string&& value);
  #endif
  void set_connecting_road_id(const char* value);
  void set_connecting_road_id(const char* value, size_t size);
  ::std::string* mutable_connecting_road_id();
  ::std::string* release_connecting_road_id();
  void set_allocated_connecting_road_id(::std::string* connecting_road_id);

  // .metamoto.types.Junction.Connection.RoadLink from_road = 1;
  bool has_from_road() const;
  void clear_from_road();
  static const int kFromRoadFieldNumber = 1;
  private:
  const ::metamoto::types::Junction_Connection_RoadLink& _internal_from_road() const;
  public:
  const ::metamoto::types::Junction_Connection_RoadLink& from_road() const;
  ::metamoto::types::Junction_Connection_RoadLink* release_from_road();
  ::metamoto::types::Junction_Connection_RoadLink* mutable_from_road();
  void set_allocated_from_road(::metamoto::types::Junction_Connection_RoadLink* from_road);

  // .metamoto.types.Junction.Connection.RoadLink to_road = 2;
  bool has_to_road() const;
  void clear_to_road();
  static const int kToRoadFieldNumber = 2;
  private:
  const ::metamoto::types::Junction_Connection_RoadLink& _internal_to_road() const;
  public:
  const ::metamoto::types::Junction_Connection_RoadLink& to_road() const;
  ::metamoto::types::Junction_Connection_RoadLink* release_to_road();
  ::metamoto::types::Junction_Connection_RoadLink* mutable_to_road();
  void set_allocated_to_road(::metamoto::types::Junction_Connection_RoadLink* to_road);

  // @@protoc_insertion_point(class_scope:metamoto.types.Junction.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr connecting_road_id_;
  ::metamoto::types::Junction_Connection_RoadLink* from_road_;
  ::metamoto::types::Junction_Connection_RoadLink* to_road_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Junction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.Junction) */ {
 public:
  Junction();
  virtual ~Junction();

  Junction(const Junction& from);

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(Junction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Junction* other);
  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction* New() const final {
    return CreateMaybeMessage<Junction>(NULL);
  }

  Junction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Junction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Junction_Connection Connection;

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Junction.Connection connections = 2;
  int connections_size() const;
  void clear_connections();
  static const int kConnectionsFieldNumber = 2;
  ::metamoto::types::Junction_Connection* mutable_connections(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction_Connection >*
      mutable_connections();
  const ::metamoto::types::Junction_Connection& connections(int index) const;
  ::metamoto::types::Junction_Connection* add_connections();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction_Connection >&
      connections() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string vector_id = 4;
  void clear_vector_id();
  static const int kVectorIdFieldNumber = 4;
  const ::std::string& vector_id() const;
  void set_vector_id(const ::std::string& value);
  #if LANG_CXX11
  void set_vector_id(::std::string&& value);
  #endif
  void set_vector_id(const char* value);
  void set_vector_id(const char* value, size_t size);
  ::std::string* mutable_vector_id();
  ::std::string* release_vector_id();
  void set_allocated_vector_id(::std::string* vector_id);

  // .metamoto.types.Vector3 approx_location = 3;
  bool has_approx_location() const;
  void clear_approx_location();
  static const int kApproxLocationFieldNumber = 3;
  private:
  const ::metamoto::types::Vector3& _internal_approx_location() const;
  public:
  const ::metamoto::types::Vector3& approx_location() const;
  ::metamoto::types::Vector3* release_approx_location();
  ::metamoto::types::Vector3* mutable_approx_location();
  void set_allocated_approx_location(::metamoto::types::Vector3* approx_location);

  // @@protoc_insertion_point(class_scope:metamoto.types.Junction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction_Connection > connections_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr vector_id_;
  ::metamoto::types::Vector3* approx_location_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadNetwork : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.RoadNetwork) */ {
 public:
  RoadNetwork();
  virtual ~RoadNetwork();

  RoadNetwork(const RoadNetwork& from);

  inline RoadNetwork& operator=(const RoadNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadNetwork(RoadNetwork&& from) noexcept
    : RoadNetwork() {
    *this = ::std::move(from);
  }

  inline RoadNetwork& operator=(RoadNetwork&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadNetwork& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadNetwork* internal_default_instance() {
    return reinterpret_cast<const RoadNetwork*>(
               &_RoadNetwork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RoadNetwork* other);
  friend void swap(RoadNetwork& a, RoadNetwork& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadNetwork* New() const final {
    return CreateMaybeMessage<RoadNetwork>(NULL);
  }

  RoadNetwork* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadNetwork>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadNetwork& from);
  void MergeFrom(const RoadNetwork& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadNetwork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Road roads = 2;
  int roads_size() const;
  void clear_roads();
  static const int kRoadsFieldNumber = 2;
  ::metamoto::types::Road* mutable_roads(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Road >*
      mutable_roads();
  const ::metamoto::types::Road& roads(int index) const;
  ::metamoto::types::Road* add_roads();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Road >&
      roads() const;

  // repeated .metamoto.types.Junction junctions = 3;
  int junctions_size() const;
  void clear_junctions();
  static const int kJunctionsFieldNumber = 3;
  ::metamoto::types::Junction* mutable_junctions(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction >*
      mutable_junctions();
  const ::metamoto::types::Junction& junctions(int index) const;
  ::metamoto::types::Junction* add_junctions();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction >&
      junctions() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .metamoto.types.GeoCoordinates origin_coordinates = 4;
  bool has_origin_coordinates() const;
  void clear_origin_coordinates();
  static const int kOriginCoordinatesFieldNumber = 4;
  private:
  const ::metamoto::types::GeoCoordinates& _internal_origin_coordinates() const;
  public:
  const ::metamoto::types::GeoCoordinates& origin_coordinates() const;
  ::metamoto::types::GeoCoordinates* release_origin_coordinates();
  ::metamoto::types::GeoCoordinates* mutable_origin_coordinates();
  void set_allocated_origin_coordinates(::metamoto::types::GeoCoordinates* origin_coordinates);

  // @@protoc_insertion_point(class_scope:metamoto.types.RoadNetwork)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Road > roads_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction > junctions_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::metamoto::types::GeoCoordinates* origin_coordinates_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.types.RoadPoint) */ {
 public:
  RoadPoint();
  virtual ~RoadPoint();

  RoadPoint(const RoadPoint& from);

  inline RoadPoint& operator=(const RoadPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadPoint(RoadPoint&& from) noexcept
    : RoadPoint() {
    *this = ::std::move(from);
  }

  inline RoadPoint& operator=(RoadPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadPoint* internal_default_instance() {
    return reinterpret_cast<const RoadPoint*>(
               &_RoadPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RoadPoint* other);
  friend void swap(RoadPoint& a, RoadPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadPoint* New() const final {
    return CreateMaybeMessage<RoadPoint>(NULL);
  }

  RoadPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadPoint& from);
  void MergeFrom(const RoadPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string road_id = 1;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 1;
  const ::std::string& road_id() const;
  void set_road_id(const ::std::string& value);
  #if LANG_CXX11
  void set_road_id(::std::string&& value);
  #endif
  void set_road_id(const char* value);
  void set_road_id(const char* value, size_t size);
  ::std::string* mutable_road_id();
  ::std::string* release_road_id();
  void set_allocated_road_id(::std::string* road_id);

  // .metamoto.types.Vector3 world_position = 7;
  bool has_world_position() const;
  void clear_world_position();
  static const int kWorldPositionFieldNumber = 7;
  private:
  const ::metamoto::types::Vector3& _internal_world_position() const;
  public:
  const ::metamoto::types::Vector3& world_position() const;
  ::metamoto::types::Vector3* release_world_position();
  ::metamoto::types::Vector3* mutable_world_position();
  void set_allocated_world_position(::metamoto::types::Vector3* world_position);

  // int32 lane_section_index = 2;
  void clear_lane_section_index();
  static const int kLaneSectionIndexFieldNumber = 2;
  ::google::protobuf::int32 lane_section_index() const;
  void set_lane_section_index(::google::protobuf::int32 value);

  // int32 lane_index = 3;
  void clear_lane_index();
  static const int kLaneIndexFieldNumber = 3;
  ::google::protobuf::int32 lane_index() const;
  void set_lane_index(::google::protobuf::int32 value);

  // float s = 4;
  void clear_s();
  static const int kSFieldNumber = 4;
  float s() const;
  void set_s(float value);

  // float t = 5;
  void clear_t();
  static const int kTFieldNumber = 5;
  float t() const;
  void set_t(float value);

  // float heading_offset = 6;
  void clear_heading_offset();
  static const int kHeadingOffsetFieldNumber = 6;
  float heading_offset() const;
  void set_heading_offset(float value);

  // @@protoc_insertion_point(class_scope:metamoto.types.RoadPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr road_id_;
  ::metamoto::types::Vector3* world_position_;
  ::google::protobuf::int32 lane_section_index_;
  ::google::protobuf::int32 lane_index_;
  float s_;
  float t_;
  float heading_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2ftypes_2froads_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Elevation

// float s = 1;
inline void Elevation::clear_s() {
  s_ = 0;
}
inline float Elevation::s() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.s)
  return s_;
}
inline void Elevation::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.s)
}

// float a = 2;
inline void Elevation::clear_a() {
  a_ = 0;
}
inline float Elevation::a() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.a)
  return a_;
}
inline void Elevation::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.a)
}

// float b = 3;
inline void Elevation::clear_b() {
  b_ = 0;
}
inline float Elevation::b() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.b)
  return b_;
}
inline void Elevation::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.b)
}

// float c = 4;
inline void Elevation::clear_c() {
  c_ = 0;
}
inline float Elevation::c() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.c)
  return c_;
}
inline void Elevation::set_c(float value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.c)
}

// float d = 5;
inline void Elevation::clear_d() {
  d_ = 0;
}
inline float Elevation::d() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.d)
  return d_;
}
inline void Elevation::set_d(float value) {
  
  d_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.d)
}

// bool reversed = 6;
inline void Elevation::clear_reversed() {
  reversed_ = false;
}
inline bool Elevation::reversed() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Elevation.reversed)
  return reversed_;
}
inline void Elevation::set_reversed(bool value) {
  
  reversed_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Elevation.reversed)
}

// -------------------------------------------------------------------

// Geometry_Arc

// float radius = 1;
inline void Geometry_Arc::clear_radius() {
  radius_ = 0;
}
inline float Geometry_Arc::radius() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.Arc.radius)
  return radius_;
}
inline void Geometry_Arc::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Geometry.Arc.radius)
}

// float angle = 2;
inline void Geometry_Arc::clear_angle() {
  angle_ = 0;
}
inline float Geometry_Arc::angle() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.Arc.angle)
  return angle_;
}
inline void Geometry_Arc::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Geometry.Arc.angle)
}

// .metamoto.types.Vector3 center = 3;
inline bool Geometry_Arc::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline const ::metamoto::types::Vector3& Geometry_Arc::_internal_center() const {
  return *center_;
}
inline const ::metamoto::types::Vector3& Geometry_Arc::center() const {
  const ::metamoto::types::Vector3* p = center_;
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.Arc.center)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Geometry_Arc::release_center() {
  // @@protoc_insertion_point(field_release:metamoto.types.Geometry.Arc.center)
  
  ::metamoto::types::Vector3* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Geometry_Arc::mutable_center() {
  
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Geometry.Arc.center)
  return center_;
}
inline void Geometry_Arc::set_allocated_center(::metamoto::types::Vector3* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_);
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Geometry.Arc.center)
}

// -------------------------------------------------------------------

// Geometry

// .metamoto.types.Geometry.Type type = 1;
inline void Geometry::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::Geometry_Type Geometry::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.type)
  return static_cast< ::metamoto::types::Geometry_Type >(type_);
}
inline void Geometry::set_type(::metamoto::types::Geometry_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Geometry.type)
}

// .metamoto.types.Vector3 start = 2;
inline bool Geometry::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline const ::metamoto::types::Vector3& Geometry::_internal_start() const {
  return *start_;
}
inline const ::metamoto::types::Vector3& Geometry::start() const {
  const ::metamoto::types::Vector3* p = start_;
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.start)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Geometry::release_start() {
  // @@protoc_insertion_point(field_release:metamoto.types.Geometry.start)
  
  ::metamoto::types::Vector3* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Geometry::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Geometry.start)
  return start_;
}
inline void Geometry::set_allocated_start(::metamoto::types::Vector3* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_);
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Geometry.start)
}

// .metamoto.types.Vector3 heading = 3;
inline bool Geometry::has_heading() const {
  return this != internal_default_instance() && heading_ != NULL;
}
inline const ::metamoto::types::Vector3& Geometry::_internal_heading() const {
  return *heading_;
}
inline const ::metamoto::types::Vector3& Geometry::heading() const {
  const ::metamoto::types::Vector3* p = heading_;
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.heading)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Geometry::release_heading() {
  // @@protoc_insertion_point(field_release:metamoto.types.Geometry.heading)
  
  ::metamoto::types::Vector3* temp = heading_;
  heading_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Geometry::mutable_heading() {
  
  if (heading_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    heading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Geometry.heading)
  return heading_;
}
inline void Geometry::set_allocated_heading(::metamoto::types::Vector3* heading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(heading_);
  }
  if (heading) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heading, submessage_arena);
    }
    
  } else {
    
  }
  heading_ = heading;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Geometry.heading)
}

// float s = 4;
inline void Geometry::clear_s() {
  s_ = 0;
}
inline float Geometry::s() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.s)
  return s_;
}
inline void Geometry::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Geometry.s)
}

// float length = 5;
inline void Geometry::clear_length() {
  length_ = 0;
}
inline float Geometry::length() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.length)
  return length_;
}
inline void Geometry::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Geometry.length)
}

// .metamoto.types.Geometry.Arc arc = 6;
inline bool Geometry::has_arc() const {
  return this != internal_default_instance() && arc_ != NULL;
}
inline void Geometry::clear_arc() {
  if (GetArenaNoVirtual() == NULL && arc_ != NULL) {
    delete arc_;
  }
  arc_ = NULL;
}
inline const ::metamoto::types::Geometry_Arc& Geometry::_internal_arc() const {
  return *arc_;
}
inline const ::metamoto::types::Geometry_Arc& Geometry::arc() const {
  const ::metamoto::types::Geometry_Arc* p = arc_;
  // @@protoc_insertion_point(field_get:metamoto.types.Geometry.arc)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Geometry_Arc*>(
      &::metamoto::types::_Geometry_Arc_default_instance_);
}
inline ::metamoto::types::Geometry_Arc* Geometry::release_arc() {
  // @@protoc_insertion_point(field_release:metamoto.types.Geometry.arc)
  
  ::metamoto::types::Geometry_Arc* temp = arc_;
  arc_ = NULL;
  return temp;
}
inline ::metamoto::types::Geometry_Arc* Geometry::mutable_arc() {
  
  if (arc_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Geometry_Arc>(GetArenaNoVirtual());
    arc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Geometry.arc)
  return arc_;
}
inline void Geometry::set_allocated_arc(::metamoto::types::Geometry_Arc* arc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete arc_;
  }
  if (arc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      arc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arc, submessage_arena);
    }
    
  } else {
    
  }
  arc_ = arc;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Geometry.arc)
}

// -------------------------------------------------------------------

// Marking

// .metamoto.types.Marking.Type type = 1;
inline void Marking::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::Marking_Type Marking::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Marking.type)
  return static_cast< ::metamoto::types::Marking_Type >(type_);
}
inline void Marking::set_type(::metamoto::types::Marking_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Marking.type)
}

// .metamoto.types.Marking.Color color = 2;
inline void Marking::clear_color() {
  color_ = 0;
}
inline ::metamoto::types::Marking_Color Marking::color() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Marking.color)
  return static_cast< ::metamoto::types::Marking_Color >(color_);
}
inline void Marking::set_color(::metamoto::types::Marking_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Marking.color)
}

// .google.protobuf.FloatValue s = 3;
inline bool Marking::has_s() const {
  return this != internal_default_instance() && s_ != NULL;
}
inline const ::google::protobuf::FloatValue& Marking::_internal_s() const {
  return *s_;
}
inline const ::google::protobuf::FloatValue& Marking::s() const {
  const ::google::protobuf::FloatValue* p = s_;
  // @@protoc_insertion_point(field_get:metamoto.types.Marking.s)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Marking::release_s() {
  // @@protoc_insertion_point(field_release:metamoto.types.Marking.s)
  
  ::google::protobuf::FloatValue* temp = s_;
  s_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Marking::mutable_s() {
  
  if (s_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    s_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Marking.s)
  return s_;
}
inline void Marking::set_allocated_s(::google::protobuf::FloatValue* s) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(s_);
  }
  if (s) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(s)->GetArena();
    if (message_arena != submessage_arena) {
      s = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s, submessage_arena);
    }
    
  } else {
    
  }
  s_ = s;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Marking.s)
}

// .google.protobuf.FloatValue t = 4;
inline bool Marking::has_t() const {
  return this != internal_default_instance() && t_ != NULL;
}
inline const ::google::protobuf::FloatValue& Marking::_internal_t() const {
  return *t_;
}
inline const ::google::protobuf::FloatValue& Marking::t() const {
  const ::google::protobuf::FloatValue* p = t_;
  // @@protoc_insertion_point(field_get:metamoto.types.Marking.t)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* Marking::release_t() {
  // @@protoc_insertion_point(field_release:metamoto.types.Marking.t)
  
  ::google::protobuf::FloatValue* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* Marking::mutable_t() {
  
  if (t_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Marking.t)
  return t_;
}
inline void Marking::set_allocated_t(::google::protobuf::FloatValue* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(t_);
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(t)->GetArena();
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Marking.t)
}

// float heading_offset = 5;
inline void Marking::clear_heading_offset() {
  heading_offset_ = 0;
}
inline float Marking::heading_offset() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Marking.heading_offset)
  return heading_offset_;
}
inline void Marking::set_heading_offset(float value) {
  
  heading_offset_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Marking.heading_offset)
}

// -------------------------------------------------------------------

// Lane

// int32 index = 1;
inline void Lane::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 Lane::index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.index)
  return index_;
}
inline void Lane::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.index)
}

// string id = 2;
inline void Lane::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Lane::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.id)
  return id_.GetNoArena();
}
inline void Lane::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.id)
}
#if LANG_CXX11
inline void Lane::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Lane.id)
}
#endif
inline void Lane::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Lane.id)
}
inline void Lane::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Lane.id)
}
inline ::std::string* Lane::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Lane.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Lane::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Lane.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lane::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Lane.id)
}

// .metamoto.types.Lane.Type type = 3;
inline void Lane::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::Lane_Type Lane::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.type)
  return static_cast< ::metamoto::types::Lane_Type >(type_);
}
inline void Lane::set_type(::metamoto::types::Lane_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.type)
}

// float width0 = 4;
inline void Lane::clear_width0() {
  width0_ = 0;
}
inline float Lane::width0() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.width0)
  return width0_;
}
inline void Lane::set_width0(float value) {
  
  width0_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.width0)
}

// float width1 = 5;
inline void Lane::clear_width1() {
  width1_ = 0;
}
inline float Lane::width1() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.width1)
  return width1_;
}
inline void Lane::set_width1(float value) {
  
  width1_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.width1)
}

// float center0 = 6;
inline void Lane::clear_center0() {
  center0_ = 0;
}
inline float Lane::center0() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.center0)
  return center0_;
}
inline void Lane::set_center0(float value) {
  
  center0_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.center0)
}

// float center1 = 7;
inline void Lane::clear_center1() {
  center1_ = 0;
}
inline float Lane::center1() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.center1)
  return center1_;
}
inline void Lane::set_center1(float value) {
  
  center1_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Lane.center1)
}

// repeated .metamoto.types.Marking markings = 8;
inline int Lane::markings_size() const {
  return markings_.size();
}
inline void Lane::clear_markings() {
  markings_.Clear();
}
inline ::metamoto::types::Marking* Lane::mutable_markings(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Lane.markings)
  return markings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Marking >*
Lane::mutable_markings() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Lane.markings)
  return &markings_;
}
inline const ::metamoto::types::Marking& Lane::markings(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Lane.markings)
  return markings_.Get(index);
}
inline ::metamoto::types::Marking* Lane::add_markings() {
  // @@protoc_insertion_point(field_add:metamoto.types.Lane.markings)
  return markings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Marking >&
Lane::markings() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Lane.markings)
  return markings_;
}

// -------------------------------------------------------------------

// LaneLink

// int32 from_lane_index = 1;
inline void LaneLink::clear_from_lane_index() {
  from_lane_index_ = 0;
}
inline ::google::protobuf::int32 LaneLink::from_lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.from_lane_index)
  return from_lane_index_;
}
inline void LaneLink::set_from_lane_index(::google::protobuf::int32 value) {
  
  from_lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.from_lane_index)
}

// int32 to_lane_index = 2;
inline void LaneLink::clear_to_lane_index() {
  to_lane_index_ = 0;
}
inline ::google::protobuf::int32 LaneLink::to_lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.to_lane_index)
  return to_lane_index_;
}
inline void LaneLink::set_to_lane_index(::google::protobuf::int32 value) {
  
  to_lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.to_lane_index)
}

// string from_lane_id = 3;
inline void LaneLink::clear_from_lane_id() {
  from_lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LaneLink::from_lane_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.from_lane_id)
  return from_lane_id_.GetNoArena();
}
inline void LaneLink::set_from_lane_id(const ::std::string& value) {
  
  from_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.from_lane_id)
}
#if LANG_CXX11
inline void LaneLink::set_from_lane_id(::std::string&& value) {
  
  from_lane_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.LaneLink.from_lane_id)
}
#endif
inline void LaneLink::set_from_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.LaneLink.from_lane_id)
}
inline void LaneLink::set_from_lane_id(const char* value, size_t size) {
  
  from_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.LaneLink.from_lane_id)
}
inline ::std::string* LaneLink::mutable_from_lane_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.LaneLink.from_lane_id)
  return from_lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneLink::release_from_lane_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.LaneLink.from_lane_id)
  
  return from_lane_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneLink::set_allocated_from_lane_id(::std::string* from_lane_id) {
  if (from_lane_id != NULL) {
    
  } else {
    
  }
  from_lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_lane_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.LaneLink.from_lane_id)
}

// string to_lane_id = 4;
inline void LaneLink::clear_to_lane_id() {
  to_lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LaneLink::to_lane_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.to_lane_id)
  return to_lane_id_.GetNoArena();
}
inline void LaneLink::set_to_lane_id(const ::std::string& value) {
  
  to_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.to_lane_id)
}
#if LANG_CXX11
inline void LaneLink::set_to_lane_id(::std::string&& value) {
  
  to_lane_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.LaneLink.to_lane_id)
}
#endif
inline void LaneLink::set_to_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.LaneLink.to_lane_id)
}
inline void LaneLink::set_to_lane_id(const char* value, size_t size) {
  
  to_lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.LaneLink.to_lane_id)
}
inline ::std::string* LaneLink::mutable_to_lane_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.LaneLink.to_lane_id)
  return to_lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneLink::release_to_lane_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.LaneLink.to_lane_id)
  
  return to_lane_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneLink::set_allocated_to_lane_id(::std::string* to_lane_id) {
  if (to_lane_id != NULL) {
    
  } else {
    
  }
  to_lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_lane_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.LaneLink.to_lane_id)
}

// int32 lane_index = 5;
inline void LaneLink::clear_lane_index() {
  lane_index_ = 0;
}
inline ::google::protobuf::int32 LaneLink::lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.lane_index)
  return lane_index_;
}
inline void LaneLink::set_lane_index(::google::protobuf::int32 value) {
  
  lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.lane_index)
}

// string lane_id = 6;
inline void LaneLink::clear_lane_id() {
  lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LaneLink::lane_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneLink.lane_id)
  return lane_id_.GetNoArena();
}
inline void LaneLink::set_lane_id(const ::std::string& value) {
  
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.LaneLink.lane_id)
}
#if LANG_CXX11
inline void LaneLink::set_lane_id(::std::string&& value) {
  
  lane_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.LaneLink.lane_id)
}
#endif
inline void LaneLink::set_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.LaneLink.lane_id)
}
inline void LaneLink::set_lane_id(const char* value, size_t size) {
  
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.LaneLink.lane_id)
}
inline ::std::string* LaneLink::mutable_lane_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.LaneLink.lane_id)
  return lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LaneLink::release_lane_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.LaneLink.lane_id)
  
  return lane_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LaneLink::set_allocated_lane_id(::std::string* lane_id) {
  if (lane_id != NULL) {
    
  } else {
    
  }
  lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lane_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.LaneLink.lane_id)
}

// -------------------------------------------------------------------

// Signal_LaneValidity

// int32 from_lane_index = 1;
inline void Signal_LaneValidity::clear_from_lane_index() {
  from_lane_index_ = 0;
}
inline ::google::protobuf::int32 Signal_LaneValidity::from_lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.LaneValidity.from_lane_index)
  return from_lane_index_;
}
inline void Signal_LaneValidity::set_from_lane_index(::google::protobuf::int32 value) {
  
  from_lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Signal.LaneValidity.from_lane_index)
}

// int32 to_lane_index = 2;
inline void Signal_LaneValidity::clear_to_lane_index() {
  to_lane_index_ = 0;
}
inline ::google::protobuf::int32 Signal_LaneValidity::to_lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.LaneValidity.to_lane_index)
  return to_lane_index_;
}
inline void Signal_LaneValidity::set_to_lane_index(::google::protobuf::int32 value) {
  
  to_lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Signal.LaneValidity.to_lane_index)
}

// -------------------------------------------------------------------

// Signal

// string id = 1;
inline void Signal::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signal::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.id)
  return id_.GetNoArena();
}
inline void Signal::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Signal.id)
}
#if LANG_CXX11
inline void Signal::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Signal.id)
}
#endif
inline void Signal::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Signal.id)
}
inline void Signal::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Signal.id)
}
inline ::std::string* Signal::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Signal.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Signal.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Signal.id)
}

// .metamoto.types.Signal.Type type = 2;
inline void Signal::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::Signal_Type Signal::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.type)
  return static_cast< ::metamoto::types::Signal_Type >(type_);
}
inline void Signal::set_type(::metamoto::types::Signal_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Signal.type)
}

// float s = 3;
inline void Signal::clear_s() {
  s_ = 0;
}
inline float Signal::s() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.s)
  return s_;
}
inline void Signal::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Signal.s)
}

// .metamoto.types.Signal.LaneValidity lane_validity = 4;
inline bool Signal::has_lane_validity() const {
  return this != internal_default_instance() && lane_validity_ != NULL;
}
inline void Signal::clear_lane_validity() {
  if (GetArenaNoVirtual() == NULL && lane_validity_ != NULL) {
    delete lane_validity_;
  }
  lane_validity_ = NULL;
}
inline const ::metamoto::types::Signal_LaneValidity& Signal::_internal_lane_validity() const {
  return *lane_validity_;
}
inline const ::metamoto::types::Signal_LaneValidity& Signal::lane_validity() const {
  const ::metamoto::types::Signal_LaneValidity* p = lane_validity_;
  // @@protoc_insertion_point(field_get:metamoto.types.Signal.lane_validity)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Signal_LaneValidity*>(
      &::metamoto::types::_Signal_LaneValidity_default_instance_);
}
inline ::metamoto::types::Signal_LaneValidity* Signal::release_lane_validity() {
  // @@protoc_insertion_point(field_release:metamoto.types.Signal.lane_validity)
  
  ::metamoto::types::Signal_LaneValidity* temp = lane_validity_;
  lane_validity_ = NULL;
  return temp;
}
inline ::metamoto::types::Signal_LaneValidity* Signal::mutable_lane_validity() {
  
  if (lane_validity_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Signal_LaneValidity>(GetArenaNoVirtual());
    lane_validity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Signal.lane_validity)
  return lane_validity_;
}
inline void Signal::set_allocated_lane_validity(::metamoto::types::Signal_LaneValidity* lane_validity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_validity_;
  }
  if (lane_validity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_validity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_validity, submessage_arena);
    }
    
  } else {
    
  }
  lane_validity_ = lane_validity;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Signal.lane_validity)
}

// -------------------------------------------------------------------

// ConnectingRoad

// string in_junction_id = 1;
inline void ConnectingRoad::clear_in_junction_id() {
  in_junction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectingRoad::in_junction_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.ConnectingRoad.in_junction_id)
  return in_junction_id_.GetNoArena();
}
inline void ConnectingRoad::set_in_junction_id(const ::std::string& value) {
  
  in_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.ConnectingRoad.in_junction_id)
}
#if LANG_CXX11
inline void ConnectingRoad::set_in_junction_id(::std::string&& value) {
  
  in_junction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.ConnectingRoad.in_junction_id)
}
#endif
inline void ConnectingRoad::set_in_junction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  in_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.ConnectingRoad.in_junction_id)
}
inline void ConnectingRoad::set_in_junction_id(const char* value, size_t size) {
  
  in_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.ConnectingRoad.in_junction_id)
}
inline ::std::string* ConnectingRoad::mutable_in_junction_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.ConnectingRoad.in_junction_id)
  return in_junction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectingRoad::release_in_junction_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.ConnectingRoad.in_junction_id)
  
  return in_junction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectingRoad::set_allocated_in_junction_id(::std::string* in_junction_id) {
  if (in_junction_id != NULL) {
    
  } else {
    
  }
  in_junction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), in_junction_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.ConnectingRoad.in_junction_id)
}

// .metamoto.types.ConnectingRoad.Direction type = 2;
inline void ConnectingRoad::clear_type() {
  type_ = 0;
}
inline ::metamoto::types::ConnectingRoad_Direction ConnectingRoad::type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.ConnectingRoad.type)
  return static_cast< ::metamoto::types::ConnectingRoad_Direction >(type_);
}
inline void ConnectingRoad::set_type(::metamoto::types::ConnectingRoad_Direction value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.ConnectingRoad.type)
}

// repeated .metamoto.types.LaneLink lane_links = 3;
inline int ConnectingRoad::lane_links_size() const {
  return lane_links_.size();
}
inline void ConnectingRoad::clear_lane_links() {
  lane_links_.Clear();
}
inline ::metamoto::types::LaneLink* ConnectingRoad::mutable_lane_links(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.ConnectingRoad.lane_links)
  return lane_links_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneLink >*
ConnectingRoad::mutable_lane_links() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.ConnectingRoad.lane_links)
  return &lane_links_;
}
inline const ::metamoto::types::LaneLink& ConnectingRoad::lane_links(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.ConnectingRoad.lane_links)
  return lane_links_.Get(index);
}
inline ::metamoto::types::LaneLink* ConnectingRoad::add_lane_links() {
  // @@protoc_insertion_point(field_add:metamoto.types.ConnectingRoad.lane_links)
  return lane_links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneLink >&
ConnectingRoad::lane_links() const {
  // @@protoc_insertion_point(field_list:metamoto.types.ConnectingRoad.lane_links)
  return lane_links_;
}

// -------------------------------------------------------------------

// LaneSection

// float s0 = 1;
inline void LaneSection::clear_s0() {
  s0_ = 0;
}
inline float LaneSection::s0() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneSection.s0)
  return s0_;
}
inline void LaneSection::set_s0(float value) {
  
  s0_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.LaneSection.s0)
}

// float s1 = 2;
inline void LaneSection::clear_s1() {
  s1_ = 0;
}
inline float LaneSection::s1() const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneSection.s1)
  return s1_;
}
inline void LaneSection::set_s1(float value) {
  
  s1_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.LaneSection.s1)
}

// repeated .metamoto.types.Lane lanes = 3;
inline int LaneSection::lanes_size() const {
  return lanes_.size();
}
inline void LaneSection::clear_lanes() {
  lanes_.Clear();
}
inline ::metamoto::types::Lane* LaneSection::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.LaneSection.lanes)
  return lanes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Lane >*
LaneSection::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.LaneSection.lanes)
  return &lanes_;
}
inline const ::metamoto::types::Lane& LaneSection::lanes(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.LaneSection.lanes)
  return lanes_.Get(index);
}
inline ::metamoto::types::Lane* LaneSection::add_lanes() {
  // @@protoc_insertion_point(field_add:metamoto.types.LaneSection.lanes)
  return lanes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Lane >&
LaneSection::lanes() const {
  // @@protoc_insertion_point(field_list:metamoto.types.LaneSection.lanes)
  return lanes_;
}

// -------------------------------------------------------------------

// Road

// string id = 1;
inline void Road::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Road::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.id)
  return id_.GetNoArena();
}
inline void Road::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Road.id)
}
#if LANG_CXX11
inline void Road::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Road.id)
}
#endif
inline void Road::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Road.id)
}
inline void Road::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Road.id)
}
inline ::std::string* Road::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Road.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Road.id)
}

// float length = 2;
inline void Road::clear_length() {
  length_ = 0;
}
inline float Road::length() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.length)
  return length_;
}
inline void Road::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Road.length)
}

// float speed_limit = 3;
inline void Road::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float Road::speed_limit() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.speed_limit)
  return speed_limit_;
}
inline void Road::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Road.speed_limit)
}

// bool one_way = 4;
inline void Road::clear_one_way() {
  one_way_ = false;
}
inline bool Road::one_way() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.one_way)
  return one_way_;
}
inline void Road::set_one_way(bool value) {
  
  one_way_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Road.one_way)
}

// repeated .metamoto.types.Geometry geometries = 5;
inline int Road::geometries_size() const {
  return geometries_.size();
}
inline void Road::clear_geometries() {
  geometries_.Clear();
}
inline ::metamoto::types::Geometry* Road::mutable_geometries(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.geometries)
  return geometries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Geometry >*
Road::mutable_geometries() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.geometries)
  return &geometries_;
}
inline const ::metamoto::types::Geometry& Road::geometries(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.geometries)
  return geometries_.Get(index);
}
inline ::metamoto::types::Geometry* Road::add_geometries() {
  // @@protoc_insertion_point(field_add:metamoto.types.Road.geometries)
  return geometries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Geometry >&
Road::geometries() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.geometries)
  return geometries_;
}

// repeated .metamoto.types.LaneSection lane_sections = 6;
inline int Road::lane_sections_size() const {
  return lane_sections_.size();
}
inline void Road::clear_lane_sections() {
  lane_sections_.Clear();
}
inline ::metamoto::types::LaneSection* Road::mutable_lane_sections(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.lane_sections)
  return lane_sections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneSection >*
Road::mutable_lane_sections() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.lane_sections)
  return &lane_sections_;
}
inline const ::metamoto::types::LaneSection& Road::lane_sections(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.lane_sections)
  return lane_sections_.Get(index);
}
inline ::metamoto::types::LaneSection* Road::add_lane_sections() {
  // @@protoc_insertion_point(field_add:metamoto.types.Road.lane_sections)
  return lane_sections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::LaneSection >&
Road::lane_sections() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.lane_sections)
  return lane_sections_;
}

// repeated .metamoto.types.Signal signals = 7;
inline int Road::signals_size() const {
  return signals_.size();
}
inline void Road::clear_signals() {
  signals_.Clear();
}
inline ::metamoto::types::Signal* Road::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.signals)
  return signals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Signal >*
Road::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.signals)
  return &signals_;
}
inline const ::metamoto::types::Signal& Road::signals(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.signals)
  return signals_.Get(index);
}
inline ::metamoto::types::Signal* Road::add_signals() {
  // @@protoc_insertion_point(field_add:metamoto.types.Road.signals)
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Signal >&
Road::signals() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.signals)
  return signals_;
}

// .metamoto.types.ConnectingRoad connecting_road = 8;
inline bool Road::has_connecting_road() const {
  return this != internal_default_instance() && connecting_road_ != NULL;
}
inline void Road::clear_connecting_road() {
  if (GetArenaNoVirtual() == NULL && connecting_road_ != NULL) {
    delete connecting_road_;
  }
  connecting_road_ = NULL;
}
inline const ::metamoto::types::ConnectingRoad& Road::_internal_connecting_road() const {
  return *connecting_road_;
}
inline const ::metamoto::types::ConnectingRoad& Road::connecting_road() const {
  const ::metamoto::types::ConnectingRoad* p = connecting_road_;
  // @@protoc_insertion_point(field_get:metamoto.types.Road.connecting_road)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::ConnectingRoad*>(
      &::metamoto::types::_ConnectingRoad_default_instance_);
}
inline ::metamoto::types::ConnectingRoad* Road::release_connecting_road() {
  // @@protoc_insertion_point(field_release:metamoto.types.Road.connecting_road)
  
  ::metamoto::types::ConnectingRoad* temp = connecting_road_;
  connecting_road_ = NULL;
  return temp;
}
inline ::metamoto::types::ConnectingRoad* Road::mutable_connecting_road() {
  
  if (connecting_road_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::ConnectingRoad>(GetArenaNoVirtual());
    connecting_road_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.connecting_road)
  return connecting_road_;
}
inline void Road::set_allocated_connecting_road(::metamoto::types::ConnectingRoad* connecting_road) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connecting_road_;
  }
  if (connecting_road) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connecting_road = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connecting_road, submessage_arena);
    }
    
  } else {
    
  }
  connecting_road_ = connecting_road;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Road.connecting_road)
}

// repeated string predecessor_road_ids = 9;
inline int Road::predecessor_road_ids_size() const {
  return predecessor_road_ids_.size();
}
inline void Road::clear_predecessor_road_ids() {
  predecessor_road_ids_.Clear();
}
inline const ::std::string& Road::predecessor_road_ids(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.predecessor_road_ids)
  return predecessor_road_ids_.Get(index);
}
inline ::std::string* Road::mutable_predecessor_road_ids(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.predecessor_road_ids)
  return predecessor_road_ids_.Mutable(index);
}
inline void Road::set_predecessor_road_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Road.predecessor_road_ids)
  predecessor_road_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Road::set_predecessor_road_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Road.predecessor_road_ids)
  predecessor_road_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Road::set_predecessor_road_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  predecessor_road_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:metamoto.types.Road.predecessor_road_ids)
}
inline void Road::set_predecessor_road_ids(int index, const char* value, size_t size) {
  predecessor_road_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Road.predecessor_road_ids)
}
inline ::std::string* Road::add_predecessor_road_ids() {
  // @@protoc_insertion_point(field_add_mutable:metamoto.types.Road.predecessor_road_ids)
  return predecessor_road_ids_.Add();
}
inline void Road::add_predecessor_road_ids(const ::std::string& value) {
  predecessor_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:metamoto.types.Road.predecessor_road_ids)
}
#if LANG_CXX11
inline void Road::add_predecessor_road_ids(::std::string&& value) {
  predecessor_road_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:metamoto.types.Road.predecessor_road_ids)
}
#endif
inline void Road::add_predecessor_road_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  predecessor_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:metamoto.types.Road.predecessor_road_ids)
}
inline void Road::add_predecessor_road_ids(const char* value, size_t size) {
  predecessor_road_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:metamoto.types.Road.predecessor_road_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Road::predecessor_road_ids() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.predecessor_road_ids)
  return predecessor_road_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Road::mutable_predecessor_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.predecessor_road_ids)
  return &predecessor_road_ids_;
}

// repeated string successor_road_ids = 10;
inline int Road::successor_road_ids_size() const {
  return successor_road_ids_.size();
}
inline void Road::clear_successor_road_ids() {
  successor_road_ids_.Clear();
}
inline const ::std::string& Road::successor_road_ids(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.successor_road_ids)
  return successor_road_ids_.Get(index);
}
inline ::std::string* Road::mutable_successor_road_ids(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.successor_road_ids)
  return successor_road_ids_.Mutable(index);
}
inline void Road::set_successor_road_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Road.successor_road_ids)
  successor_road_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Road::set_successor_road_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:metamoto.types.Road.successor_road_ids)
  successor_road_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Road::set_successor_road_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  successor_road_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:metamoto.types.Road.successor_road_ids)
}
inline void Road::set_successor_road_ids(int index, const char* value, size_t size) {
  successor_road_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Road.successor_road_ids)
}
inline ::std::string* Road::add_successor_road_ids() {
  // @@protoc_insertion_point(field_add_mutable:metamoto.types.Road.successor_road_ids)
  return successor_road_ids_.Add();
}
inline void Road::add_successor_road_ids(const ::std::string& value) {
  successor_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:metamoto.types.Road.successor_road_ids)
}
#if LANG_CXX11
inline void Road::add_successor_road_ids(::std::string&& value) {
  successor_road_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:metamoto.types.Road.successor_road_ids)
}
#endif
inline void Road::add_successor_road_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  successor_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:metamoto.types.Road.successor_road_ids)
}
inline void Road::add_successor_road_ids(const char* value, size_t size) {
  successor_road_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:metamoto.types.Road.successor_road_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Road::successor_road_ids() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.successor_road_ids)
  return successor_road_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Road::mutable_successor_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.successor_road_ids)
  return &successor_road_ids_;
}

// string predecessor_junction_id = 11;
inline void Road::clear_predecessor_junction_id() {
  predecessor_junction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Road::predecessor_junction_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.predecessor_junction_id)
  return predecessor_junction_id_.GetNoArena();
}
inline void Road::set_predecessor_junction_id(const ::std::string& value) {
  
  predecessor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Road.predecessor_junction_id)
}
#if LANG_CXX11
inline void Road::set_predecessor_junction_id(::std::string&& value) {
  
  predecessor_junction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Road.predecessor_junction_id)
}
#endif
inline void Road::set_predecessor_junction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  predecessor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Road.predecessor_junction_id)
}
inline void Road::set_predecessor_junction_id(const char* value, size_t size) {
  
  predecessor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Road.predecessor_junction_id)
}
inline ::std::string* Road::mutable_predecessor_junction_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.predecessor_junction_id)
  return predecessor_junction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_predecessor_junction_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Road.predecessor_junction_id)
  
  return predecessor_junction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_predecessor_junction_id(::std::string* predecessor_junction_id) {
  if (predecessor_junction_id != NULL) {
    
  } else {
    
  }
  predecessor_junction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predecessor_junction_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Road.predecessor_junction_id)
}

// string successor_junction_id = 12;
inline void Road::clear_successor_junction_id() {
  successor_junction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Road::successor_junction_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.successor_junction_id)
  return successor_junction_id_.GetNoArena();
}
inline void Road::set_successor_junction_id(const ::std::string& value) {
  
  successor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Road.successor_junction_id)
}
#if LANG_CXX11
inline void Road::set_successor_junction_id(::std::string&& value) {
  
  successor_junction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Road.successor_junction_id)
}
#endif
inline void Road::set_successor_junction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  successor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Road.successor_junction_id)
}
inline void Road::set_successor_junction_id(const char* value, size_t size) {
  
  successor_junction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Road.successor_junction_id)
}
inline ::std::string* Road::mutable_successor_junction_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.successor_junction_id)
  return successor_junction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_successor_junction_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Road.successor_junction_id)
  
  return successor_junction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_successor_junction_id(::std::string* successor_junction_id) {
  if (successor_junction_id != NULL) {
    
  } else {
    
  }
  successor_junction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), successor_junction_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Road.successor_junction_id)
}

// repeated .metamoto.types.Elevation elevation = 13;
inline int Road::elevation_size() const {
  return elevation_.size();
}
inline void Road::clear_elevation() {
  elevation_.Clear();
}
inline ::metamoto::types::Elevation* Road::mutable_elevation(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Road.elevation)
  return elevation_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Elevation >*
Road::mutable_elevation() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Road.elevation)
  return &elevation_;
}
inline const ::metamoto::types::Elevation& Road::elevation(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Road.elevation)
  return elevation_.Get(index);
}
inline ::metamoto::types::Elevation* Road::add_elevation() {
  // @@protoc_insertion_point(field_add:metamoto.types.Road.elevation)
  return elevation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Elevation >&
Road::elevation() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Road.elevation)
  return elevation_;
}

// -------------------------------------------------------------------

// Junction_Connection_RoadLink

// string road_id = 1;
inline void Junction_Connection_RoadLink::clear_road_id() {
  road_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction_Connection_RoadLink::road_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.Connection.RoadLink.road_id)
  return road_id_.GetNoArena();
}
inline void Junction_Connection_RoadLink::set_road_id(const ::std::string& value) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Junction.Connection.RoadLink.road_id)
}
#if LANG_CXX11
inline void Junction_Connection_RoadLink::set_road_id(::std::string&& value) {
  
  road_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Junction.Connection.RoadLink.road_id)
}
#endif
inline void Junction_Connection_RoadLink::set_road_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Junction.Connection.RoadLink.road_id)
}
inline void Junction_Connection_RoadLink::set_road_id(const char* value, size_t size) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Junction.Connection.RoadLink.road_id)
}
inline ::std::string* Junction_Connection_RoadLink::mutable_road_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.Connection.RoadLink.road_id)
  return road_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction_Connection_RoadLink::release_road_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.Connection.RoadLink.road_id)
  
  return road_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction_Connection_RoadLink::set_allocated_road_id(::std::string* road_id) {
  if (road_id != NULL) {
    
  } else {
    
  }
  road_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), road_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.Connection.RoadLink.road_id)
}

// .metamoto.types.Junction.Connection.RoadLink.ContactType contact_type = 2;
inline void Junction_Connection_RoadLink::clear_contact_type() {
  contact_type_ = 0;
}
inline ::metamoto::types::Junction_Connection_RoadLink_ContactType Junction_Connection_RoadLink::contact_type() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.Connection.RoadLink.contact_type)
  return static_cast< ::metamoto::types::Junction_Connection_RoadLink_ContactType >(contact_type_);
}
inline void Junction_Connection_RoadLink::set_contact_type(::metamoto::types::Junction_Connection_RoadLink_ContactType value) {
  
  contact_type_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.Junction.Connection.RoadLink.contact_type)
}

// -------------------------------------------------------------------

// Junction_Connection

// .metamoto.types.Junction.Connection.RoadLink from_road = 1;
inline bool Junction_Connection::has_from_road() const {
  return this != internal_default_instance() && from_road_ != NULL;
}
inline void Junction_Connection::clear_from_road() {
  if (GetArenaNoVirtual() == NULL && from_road_ != NULL) {
    delete from_road_;
  }
  from_road_ = NULL;
}
inline const ::metamoto::types::Junction_Connection_RoadLink& Junction_Connection::_internal_from_road() const {
  return *from_road_;
}
inline const ::metamoto::types::Junction_Connection_RoadLink& Junction_Connection::from_road() const {
  const ::metamoto::types::Junction_Connection_RoadLink* p = from_road_;
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.Connection.from_road)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Junction_Connection_RoadLink*>(
      &::metamoto::types::_Junction_Connection_RoadLink_default_instance_);
}
inline ::metamoto::types::Junction_Connection_RoadLink* Junction_Connection::release_from_road() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.Connection.from_road)
  
  ::metamoto::types::Junction_Connection_RoadLink* temp = from_road_;
  from_road_ = NULL;
  return temp;
}
inline ::metamoto::types::Junction_Connection_RoadLink* Junction_Connection::mutable_from_road() {
  
  if (from_road_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Junction_Connection_RoadLink>(GetArenaNoVirtual());
    from_road_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.Connection.from_road)
  return from_road_;
}
inline void Junction_Connection::set_allocated_from_road(::metamoto::types::Junction_Connection_RoadLink* from_road) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete from_road_;
  }
  if (from_road) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      from_road = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from_road, submessage_arena);
    }
    
  } else {
    
  }
  from_road_ = from_road;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.Connection.from_road)
}

// .metamoto.types.Junction.Connection.RoadLink to_road = 2;
inline bool Junction_Connection::has_to_road() const {
  return this != internal_default_instance() && to_road_ != NULL;
}
inline void Junction_Connection::clear_to_road() {
  if (GetArenaNoVirtual() == NULL && to_road_ != NULL) {
    delete to_road_;
  }
  to_road_ = NULL;
}
inline const ::metamoto::types::Junction_Connection_RoadLink& Junction_Connection::_internal_to_road() const {
  return *to_road_;
}
inline const ::metamoto::types::Junction_Connection_RoadLink& Junction_Connection::to_road() const {
  const ::metamoto::types::Junction_Connection_RoadLink* p = to_road_;
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.Connection.to_road)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Junction_Connection_RoadLink*>(
      &::metamoto::types::_Junction_Connection_RoadLink_default_instance_);
}
inline ::metamoto::types::Junction_Connection_RoadLink* Junction_Connection::release_to_road() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.Connection.to_road)
  
  ::metamoto::types::Junction_Connection_RoadLink* temp = to_road_;
  to_road_ = NULL;
  return temp;
}
inline ::metamoto::types::Junction_Connection_RoadLink* Junction_Connection::mutable_to_road() {
  
  if (to_road_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Junction_Connection_RoadLink>(GetArenaNoVirtual());
    to_road_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.Connection.to_road)
  return to_road_;
}
inline void Junction_Connection::set_allocated_to_road(::metamoto::types::Junction_Connection_RoadLink* to_road) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete to_road_;
  }
  if (to_road) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      to_road = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, to_road, submessage_arena);
    }
    
  } else {
    
  }
  to_road_ = to_road;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.Connection.to_road)
}

// string connecting_road_id = 3;
inline void Junction_Connection::clear_connecting_road_id() {
  connecting_road_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction_Connection::connecting_road_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.Connection.connecting_road_id)
  return connecting_road_id_.GetNoArena();
}
inline void Junction_Connection::set_connecting_road_id(const ::std::string& value) {
  
  connecting_road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Junction.Connection.connecting_road_id)
}
#if LANG_CXX11
inline void Junction_Connection::set_connecting_road_id(::std::string&& value) {
  
  connecting_road_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Junction.Connection.connecting_road_id)
}
#endif
inline void Junction_Connection::set_connecting_road_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connecting_road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Junction.Connection.connecting_road_id)
}
inline void Junction_Connection::set_connecting_road_id(const char* value, size_t size) {
  
  connecting_road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Junction.Connection.connecting_road_id)
}
inline ::std::string* Junction_Connection::mutable_connecting_road_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.Connection.connecting_road_id)
  return connecting_road_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction_Connection::release_connecting_road_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.Connection.connecting_road_id)
  
  return connecting_road_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction_Connection::set_allocated_connecting_road_id(::std::string* connecting_road_id) {
  if (connecting_road_id != NULL) {
    
  } else {
    
  }
  connecting_road_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connecting_road_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.Connection.connecting_road_id)
}

// -------------------------------------------------------------------

// Junction

// string id = 1;
inline void Junction::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.id)
  return id_.GetNoArena();
}
inline void Junction::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Junction.id)
}
#if LANG_CXX11
inline void Junction::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Junction.id)
}
#endif
inline void Junction::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Junction.id)
}
inline void Junction::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Junction.id)
}
inline ::std::string* Junction::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.id)
}

// repeated .metamoto.types.Junction.Connection connections = 2;
inline int Junction::connections_size() const {
  return connections_.size();
}
inline void Junction::clear_connections() {
  connections_.Clear();
}
inline ::metamoto::types::Junction_Connection* Junction::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.connections)
  return connections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction_Connection >*
Junction::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.Junction.connections)
  return &connections_;
}
inline const ::metamoto::types::Junction_Connection& Junction::connections(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.connections)
  return connections_.Get(index);
}
inline ::metamoto::types::Junction_Connection* Junction::add_connections() {
  // @@protoc_insertion_point(field_add:metamoto.types.Junction.connections)
  return connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction_Connection >&
Junction::connections() const {
  // @@protoc_insertion_point(field_list:metamoto.types.Junction.connections)
  return connections_;
}

// .metamoto.types.Vector3 approx_location = 3;
inline bool Junction::has_approx_location() const {
  return this != internal_default_instance() && approx_location_ != NULL;
}
inline const ::metamoto::types::Vector3& Junction::_internal_approx_location() const {
  return *approx_location_;
}
inline const ::metamoto::types::Vector3& Junction::approx_location() const {
  const ::metamoto::types::Vector3* p = approx_location_;
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.approx_location)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* Junction::release_approx_location() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.approx_location)
  
  ::metamoto::types::Vector3* temp = approx_location_;
  approx_location_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* Junction::mutable_approx_location() {
  
  if (approx_location_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    approx_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.approx_location)
  return approx_location_;
}
inline void Junction::set_allocated_approx_location(::metamoto::types::Vector3* approx_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(approx_location_);
  }
  if (approx_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      approx_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, approx_location, submessage_arena);
    }
    
  } else {
    
  }
  approx_location_ = approx_location;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.approx_location)
}

// string vector_id = 4;
inline void Junction::clear_vector_id() {
  vector_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction::vector_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.Junction.vector_id)
  return vector_id_.GetNoArena();
}
inline void Junction::set_vector_id(const ::std::string& value) {
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.Junction.vector_id)
}
#if LANG_CXX11
inline void Junction::set_vector_id(::std::string&& value) {
  
  vector_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.Junction.vector_id)
}
#endif
inline void Junction::set_vector_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.Junction.vector_id)
}
inline void Junction::set_vector_id(const char* value, size_t size) {
  
  vector_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.Junction.vector_id)
}
inline ::std::string* Junction::mutable_vector_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.Junction.vector_id)
  return vector_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction::release_vector_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.Junction.vector_id)
  
  return vector_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction::set_allocated_vector_id(::std::string* vector_id) {
  if (vector_id != NULL) {
    
  } else {
    
  }
  vector_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vector_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.Junction.vector_id)
}

// -------------------------------------------------------------------

// RoadNetwork

// string id = 1;
inline void RoadNetwork::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadNetwork::id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadNetwork.id)
  return id_.GetNoArena();
}
inline void RoadNetwork::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.RoadNetwork.id)
}
#if LANG_CXX11
inline void RoadNetwork::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.RoadNetwork.id)
}
#endif
inline void RoadNetwork::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.RoadNetwork.id)
}
inline void RoadNetwork::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.RoadNetwork.id)
}
inline ::std::string* RoadNetwork::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadNetwork.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadNetwork::release_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.RoadNetwork.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadNetwork::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.RoadNetwork.id)
}

// repeated .metamoto.types.Road roads = 2;
inline int RoadNetwork::roads_size() const {
  return roads_.size();
}
inline void RoadNetwork::clear_roads() {
  roads_.Clear();
}
inline ::metamoto::types::Road* RoadNetwork::mutable_roads(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadNetwork.roads)
  return roads_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Road >*
RoadNetwork::mutable_roads() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.RoadNetwork.roads)
  return &roads_;
}
inline const ::metamoto::types::Road& RoadNetwork::roads(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadNetwork.roads)
  return roads_.Get(index);
}
inline ::metamoto::types::Road* RoadNetwork::add_roads() {
  // @@protoc_insertion_point(field_add:metamoto.types.RoadNetwork.roads)
  return roads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Road >&
RoadNetwork::roads() const {
  // @@protoc_insertion_point(field_list:metamoto.types.RoadNetwork.roads)
  return roads_;
}

// repeated .metamoto.types.Junction junctions = 3;
inline int RoadNetwork::junctions_size() const {
  return junctions_.size();
}
inline void RoadNetwork::clear_junctions() {
  junctions_.Clear();
}
inline ::metamoto::types::Junction* RoadNetwork::mutable_junctions(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadNetwork.junctions)
  return junctions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction >*
RoadNetwork::mutable_junctions() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.types.RoadNetwork.junctions)
  return &junctions_;
}
inline const ::metamoto::types::Junction& RoadNetwork::junctions(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadNetwork.junctions)
  return junctions_.Get(index);
}
inline ::metamoto::types::Junction* RoadNetwork::add_junctions() {
  // @@protoc_insertion_point(field_add:metamoto.types.RoadNetwork.junctions)
  return junctions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Junction >&
RoadNetwork::junctions() const {
  // @@protoc_insertion_point(field_list:metamoto.types.RoadNetwork.junctions)
  return junctions_;
}

// .metamoto.types.GeoCoordinates origin_coordinates = 4;
inline bool RoadNetwork::has_origin_coordinates() const {
  return this != internal_default_instance() && origin_coordinates_ != NULL;
}
inline const ::metamoto::types::GeoCoordinates& RoadNetwork::_internal_origin_coordinates() const {
  return *origin_coordinates_;
}
inline const ::metamoto::types::GeoCoordinates& RoadNetwork::origin_coordinates() const {
  const ::metamoto::types::GeoCoordinates* p = origin_coordinates_;
  // @@protoc_insertion_point(field_get:metamoto.types.RoadNetwork.origin_coordinates)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::GeoCoordinates*>(
      &::metamoto::types::_GeoCoordinates_default_instance_);
}
inline ::metamoto::types::GeoCoordinates* RoadNetwork::release_origin_coordinates() {
  // @@protoc_insertion_point(field_release:metamoto.types.RoadNetwork.origin_coordinates)
  
  ::metamoto::types::GeoCoordinates* temp = origin_coordinates_;
  origin_coordinates_ = NULL;
  return temp;
}
inline ::metamoto::types::GeoCoordinates* RoadNetwork::mutable_origin_coordinates() {
  
  if (origin_coordinates_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::GeoCoordinates>(GetArenaNoVirtual());
    origin_coordinates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadNetwork.origin_coordinates)
  return origin_coordinates_;
}
inline void RoadNetwork::set_allocated_origin_coordinates(::metamoto::types::GeoCoordinates* origin_coordinates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(origin_coordinates_);
  }
  if (origin_coordinates) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin_coordinates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin_coordinates, submessage_arena);
    }
    
  } else {
    
  }
  origin_coordinates_ = origin_coordinates;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.RoadNetwork.origin_coordinates)
}

// -------------------------------------------------------------------

// RoadPoint

// string road_id = 1;
inline void RoadPoint::clear_road_id() {
  road_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadPoint::road_id() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.road_id)
  return road_id_.GetNoArena();
}
inline void RoadPoint::set_road_id(const ::std::string& value) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.road_id)
}
#if LANG_CXX11
inline void RoadPoint::set_road_id(::std::string&& value) {
  
  road_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:metamoto.types.RoadPoint.road_id)
}
#endif
inline void RoadPoint::set_road_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:metamoto.types.RoadPoint.road_id)
}
inline void RoadPoint::set_road_id(const char* value, size_t size) {
  
  road_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:metamoto.types.RoadPoint.road_id)
}
inline ::std::string* RoadPoint::mutable_road_id() {
  
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadPoint.road_id)
  return road_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadPoint::release_road_id() {
  // @@protoc_insertion_point(field_release:metamoto.types.RoadPoint.road_id)
  
  return road_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadPoint::set_allocated_road_id(::std::string* road_id) {
  if (road_id != NULL) {
    
  } else {
    
  }
  road_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), road_id);
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.RoadPoint.road_id)
}

// int32 lane_section_index = 2;
inline void RoadPoint::clear_lane_section_index() {
  lane_section_index_ = 0;
}
inline ::google::protobuf::int32 RoadPoint::lane_section_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.lane_section_index)
  return lane_section_index_;
}
inline void RoadPoint::set_lane_section_index(::google::protobuf::int32 value) {
  
  lane_section_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.lane_section_index)
}

// int32 lane_index = 3;
inline void RoadPoint::clear_lane_index() {
  lane_index_ = 0;
}
inline ::google::protobuf::int32 RoadPoint::lane_index() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.lane_index)
  return lane_index_;
}
inline void RoadPoint::set_lane_index(::google::protobuf::int32 value) {
  
  lane_index_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.lane_index)
}

// float s = 4;
inline void RoadPoint::clear_s() {
  s_ = 0;
}
inline float RoadPoint::s() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.s)
  return s_;
}
inline void RoadPoint::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.s)
}

// float t = 5;
inline void RoadPoint::clear_t() {
  t_ = 0;
}
inline float RoadPoint::t() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.t)
  return t_;
}
inline void RoadPoint::set_t(float value) {
  
  t_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.t)
}

// float heading_offset = 6;
inline void RoadPoint::clear_heading_offset() {
  heading_offset_ = 0;
}
inline float RoadPoint::heading_offset() const {
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.heading_offset)
  return heading_offset_;
}
inline void RoadPoint::set_heading_offset(float value) {
  
  heading_offset_ = value;
  // @@protoc_insertion_point(field_set:metamoto.types.RoadPoint.heading_offset)
}

// .metamoto.types.Vector3 world_position = 7;
inline bool RoadPoint::has_world_position() const {
  return this != internal_default_instance() && world_position_ != NULL;
}
inline const ::metamoto::types::Vector3& RoadPoint::_internal_world_position() const {
  return *world_position_;
}
inline const ::metamoto::types::Vector3& RoadPoint::world_position() const {
  const ::metamoto::types::Vector3* p = world_position_;
  // @@protoc_insertion_point(field_get:metamoto.types.RoadPoint.world_position)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* RoadPoint::release_world_position() {
  // @@protoc_insertion_point(field_release:metamoto.types.RoadPoint.world_position)
  
  ::metamoto::types::Vector3* temp = world_position_;
  world_position_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* RoadPoint::mutable_world_position() {
  
  if (world_position_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    world_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.types.RoadPoint.world_position)
  return world_position_;
}
inline void RoadPoint::set_allocated_world_position(::metamoto::types::Vector3* world_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_position_);
  }
  if (world_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_position, submessage_arena);
    }
    
  } else {
    
  }
  world_position_ = world_position;
  // @@protoc_insertion_point(field_set_allocated:metamoto.types.RoadPoint.world_position)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace metamoto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::metamoto::types::Geometry_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Geometry_Type>() {
  return ::metamoto::types::Geometry_Type_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Marking_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Marking_Type>() {
  return ::metamoto::types::Marking_Type_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Marking_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Marking_Color>() {
  return ::metamoto::types::Marking_Color_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Lane_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Lane_Type>() {
  return ::metamoto::types::Lane_Type_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Signal_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Signal_Type>() {
  return ::metamoto::types::Signal_Type_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::ConnectingRoad_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::ConnectingRoad_Direction>() {
  return ::metamoto::types::ConnectingRoad_Direction_descriptor();
}
template <> struct is_proto_enum< ::metamoto::types::Junction_Connection_RoadLink_ContactType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::metamoto::types::Junction_Connection_RoadLink_ContactType>() {
  return ::metamoto::types::Junction_Connection_RoadLink_ContactType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_metamoto_2ftypes_2froads_2eproto
