// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metamoto/services/map.proto

#ifndef PROTOBUF_INCLUDED_metamoto_2fservices_2fmap_2eproto
#define PROTOBUF_INCLUDED_metamoto_2fservices_2fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "metamoto/types/roads.pb.h"
#include "metamoto/types/vector3.pb.h"
#include "metamoto/types/waypoint.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_metamoto_2fservices_2fmap_2eproto 

namespace protobuf_metamoto_2fservices_2fmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_metamoto_2fservices_2fmap_2eproto
namespace metamoto {
namespace services {
class MapGetHeadingReply;
class MapGetHeadingReplyDefaultTypeInternal;
extern MapGetHeadingReplyDefaultTypeInternal _MapGetHeadingReply_default_instance_;
class MapGetHeadingRequest;
class MapGetHeadingRequestDefaultTypeInternal;
extern MapGetHeadingRequestDefaultTypeInternal _MapGetHeadingRequest_default_instance_;
class MapGetPathReply;
class MapGetPathReplyDefaultTypeInternal;
extern MapGetPathReplyDefaultTypeInternal _MapGetPathReply_default_instance_;
class MapGetPathRequest;
class MapGetPathRequestDefaultTypeInternal;
extern MapGetPathRequestDefaultTypeInternal _MapGetPathRequest_default_instance_;
class MapGetRoadNetworkReply;
class MapGetRoadNetworkReplyDefaultTypeInternal;
extern MapGetRoadNetworkReplyDefaultTypeInternal _MapGetRoadNetworkReply_default_instance_;
class MapGetRoadNetworkRequest;
class MapGetRoadNetworkRequestDefaultTypeInternal;
extern MapGetRoadNetworkRequestDefaultTypeInternal _MapGetRoadNetworkRequest_default_instance_;
class MapToRoadPointReply;
class MapToRoadPointReplyDefaultTypeInternal;
extern MapToRoadPointReplyDefaultTypeInternal _MapToRoadPointReply_default_instance_;
class MapToRoadPointRequest;
class MapToRoadPointRequestDefaultTypeInternal;
extern MapToRoadPointRequestDefaultTypeInternal _MapToRoadPointRequest_default_instance_;
class MapToWorldPointReply;
class MapToWorldPointReplyDefaultTypeInternal;
extern MapToWorldPointReplyDefaultTypeInternal _MapToWorldPointReply_default_instance_;
class MapToWorldPointRequest;
class MapToWorldPointRequestDefaultTypeInternal;
extern MapToWorldPointRequestDefaultTypeInternal _MapToWorldPointRequest_default_instance_;
}  // namespace services
}  // namespace metamoto
namespace google {
namespace protobuf {
template<> ::metamoto::services::MapGetHeadingReply* Arena::CreateMaybeMessage<::metamoto::services::MapGetHeadingReply>(Arena*);
template<> ::metamoto::services::MapGetHeadingRequest* Arena::CreateMaybeMessage<::metamoto::services::MapGetHeadingRequest>(Arena*);
template<> ::metamoto::services::MapGetPathReply* Arena::CreateMaybeMessage<::metamoto::services::MapGetPathReply>(Arena*);
template<> ::metamoto::services::MapGetPathRequest* Arena::CreateMaybeMessage<::metamoto::services::MapGetPathRequest>(Arena*);
template<> ::metamoto::services::MapGetRoadNetworkReply* Arena::CreateMaybeMessage<::metamoto::services::MapGetRoadNetworkReply>(Arena*);
template<> ::metamoto::services::MapGetRoadNetworkRequest* Arena::CreateMaybeMessage<::metamoto::services::MapGetRoadNetworkRequest>(Arena*);
template<> ::metamoto::services::MapToRoadPointReply* Arena::CreateMaybeMessage<::metamoto::services::MapToRoadPointReply>(Arena*);
template<> ::metamoto::services::MapToRoadPointRequest* Arena::CreateMaybeMessage<::metamoto::services::MapToRoadPointRequest>(Arena*);
template<> ::metamoto::services::MapToWorldPointReply* Arena::CreateMaybeMessage<::metamoto::services::MapToWorldPointReply>(Arena*);
template<> ::metamoto::services::MapToWorldPointRequest* Arena::CreateMaybeMessage<::metamoto::services::MapToWorldPointRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace metamoto {
namespace services {

// ===================================================================

class MapGetRoadNetworkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetRoadNetworkRequest) */ {
 public:
  MapGetRoadNetworkRequest();
  virtual ~MapGetRoadNetworkRequest();

  MapGetRoadNetworkRequest(const MapGetRoadNetworkRequest& from);

  inline MapGetRoadNetworkRequest& operator=(const MapGetRoadNetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetRoadNetworkRequest(MapGetRoadNetworkRequest&& from) noexcept
    : MapGetRoadNetworkRequest() {
    *this = ::std::move(from);
  }

  inline MapGetRoadNetworkRequest& operator=(MapGetRoadNetworkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetRoadNetworkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetRoadNetworkRequest* internal_default_instance() {
    return reinterpret_cast<const MapGetRoadNetworkRequest*>(
               &_MapGetRoadNetworkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MapGetRoadNetworkRequest* other);
  friend void swap(MapGetRoadNetworkRequest& a, MapGetRoadNetworkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetRoadNetworkRequest* New() const final {
    return CreateMaybeMessage<MapGetRoadNetworkRequest>(NULL);
  }

  MapGetRoadNetworkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetRoadNetworkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetRoadNetworkRequest& from);
  void MergeFrom(const MapGetRoadNetworkRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetRoadNetworkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetRoadNetworkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapGetRoadNetworkReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetRoadNetworkReply) */ {
 public:
  MapGetRoadNetworkReply();
  virtual ~MapGetRoadNetworkReply();

  MapGetRoadNetworkReply(const MapGetRoadNetworkReply& from);

  inline MapGetRoadNetworkReply& operator=(const MapGetRoadNetworkReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetRoadNetworkReply(MapGetRoadNetworkReply&& from) noexcept
    : MapGetRoadNetworkReply() {
    *this = ::std::move(from);
  }

  inline MapGetRoadNetworkReply& operator=(MapGetRoadNetworkReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetRoadNetworkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetRoadNetworkReply* internal_default_instance() {
    return reinterpret_cast<const MapGetRoadNetworkReply*>(
               &_MapGetRoadNetworkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MapGetRoadNetworkReply* other);
  friend void swap(MapGetRoadNetworkReply& a, MapGetRoadNetworkReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetRoadNetworkReply* New() const final {
    return CreateMaybeMessage<MapGetRoadNetworkReply>(NULL);
  }

  MapGetRoadNetworkReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetRoadNetworkReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetRoadNetworkReply& from);
  void MergeFrom(const MapGetRoadNetworkReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetRoadNetworkReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.RoadNetwork road_network = 1;
  bool has_road_network() const;
  void clear_road_network();
  static const int kRoadNetworkFieldNumber = 1;
  private:
  const ::metamoto::types::RoadNetwork& _internal_road_network() const;
  public:
  const ::metamoto::types::RoadNetwork& road_network() const;
  ::metamoto::types::RoadNetwork* release_road_network();
  ::metamoto::types::RoadNetwork* mutable_road_network();
  void set_allocated_road_network(::metamoto::types::RoadNetwork* road_network);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetRoadNetworkReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::RoadNetwork* road_network_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapToRoadPointRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapToRoadPointRequest) */ {
 public:
  MapToRoadPointRequest();
  virtual ~MapToRoadPointRequest();

  MapToRoadPointRequest(const MapToRoadPointRequest& from);

  inline MapToRoadPointRequest& operator=(const MapToRoadPointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapToRoadPointRequest(MapToRoadPointRequest&& from) noexcept
    : MapToRoadPointRequest() {
    *this = ::std::move(from);
  }

  inline MapToRoadPointRequest& operator=(MapToRoadPointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapToRoadPointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapToRoadPointRequest* internal_default_instance() {
    return reinterpret_cast<const MapToRoadPointRequest*>(
               &_MapToRoadPointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MapToRoadPointRequest* other);
  friend void swap(MapToRoadPointRequest& a, MapToRoadPointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapToRoadPointRequest* New() const final {
    return CreateMaybeMessage<MapToRoadPointRequest>(NULL);
  }

  MapToRoadPointRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapToRoadPointRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapToRoadPointRequest& from);
  void MergeFrom(const MapToRoadPointRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapToRoadPointRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 world_point = 1;
  bool has_world_point() const;
  void clear_world_point();
  static const int kWorldPointFieldNumber = 1;
  private:
  const ::metamoto::types::Vector3& _internal_world_point() const;
  public:
  const ::metamoto::types::Vector3& world_point() const;
  ::metamoto::types::Vector3* release_world_point();
  ::metamoto::types::Vector3* mutable_world_point();
  void set_allocated_world_point(::metamoto::types::Vector3* world_point);

  // float vertical_tolerance = 2;
  void clear_vertical_tolerance();
  static const int kVerticalToleranceFieldNumber = 2;
  float vertical_tolerance() const;
  void set_vertical_tolerance(float value);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapToRoadPointRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* world_point_;
  float vertical_tolerance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapToRoadPointReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapToRoadPointReply) */ {
 public:
  MapToRoadPointReply();
  virtual ~MapToRoadPointReply();

  MapToRoadPointReply(const MapToRoadPointReply& from);

  inline MapToRoadPointReply& operator=(const MapToRoadPointReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapToRoadPointReply(MapToRoadPointReply&& from) noexcept
    : MapToRoadPointReply() {
    *this = ::std::move(from);
  }

  inline MapToRoadPointReply& operator=(MapToRoadPointReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapToRoadPointReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapToRoadPointReply* internal_default_instance() {
    return reinterpret_cast<const MapToRoadPointReply*>(
               &_MapToRoadPointReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MapToRoadPointReply* other);
  friend void swap(MapToRoadPointReply& a, MapToRoadPointReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapToRoadPointReply* New() const final {
    return CreateMaybeMessage<MapToRoadPointReply>(NULL);
  }

  MapToRoadPointReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapToRoadPointReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapToRoadPointReply& from);
  void MergeFrom(const MapToRoadPointReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapToRoadPointReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.RoadPoint road_points = 1;
  int road_points_size() const;
  void clear_road_points();
  static const int kRoadPointsFieldNumber = 1;
  ::metamoto::types::RoadPoint* mutable_road_points(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::RoadPoint >*
      mutable_road_points();
  const ::metamoto::types::RoadPoint& road_points(int index) const;
  ::metamoto::types::RoadPoint* add_road_points();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::RoadPoint >&
      road_points() const;

  // @@protoc_insertion_point(class_scope:metamoto.services.MapToRoadPointReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::RoadPoint > road_points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapToWorldPointRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapToWorldPointRequest) */ {
 public:
  MapToWorldPointRequest();
  virtual ~MapToWorldPointRequest();

  MapToWorldPointRequest(const MapToWorldPointRequest& from);

  inline MapToWorldPointRequest& operator=(const MapToWorldPointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapToWorldPointRequest(MapToWorldPointRequest&& from) noexcept
    : MapToWorldPointRequest() {
    *this = ::std::move(from);
  }

  inline MapToWorldPointRequest& operator=(MapToWorldPointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapToWorldPointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapToWorldPointRequest* internal_default_instance() {
    return reinterpret_cast<const MapToWorldPointRequest*>(
               &_MapToWorldPointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MapToWorldPointRequest* other);
  friend void swap(MapToWorldPointRequest& a, MapToWorldPointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapToWorldPointRequest* New() const final {
    return CreateMaybeMessage<MapToWorldPointRequest>(NULL);
  }

  MapToWorldPointRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapToWorldPointRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapToWorldPointRequest& from);
  void MergeFrom(const MapToWorldPointRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapToWorldPointRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.RoadPoint road_point = 1;
  bool has_road_point() const;
  void clear_road_point();
  static const int kRoadPointFieldNumber = 1;
  private:
  const ::metamoto::types::RoadPoint& _internal_road_point() const;
  public:
  const ::metamoto::types::RoadPoint& road_point() const;
  ::metamoto::types::RoadPoint* release_road_point();
  ::metamoto::types::RoadPoint* mutable_road_point();
  void set_allocated_road_point(::metamoto::types::RoadPoint* road_point);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapToWorldPointRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::RoadPoint* road_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapToWorldPointReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapToWorldPointReply) */ {
 public:
  MapToWorldPointReply();
  virtual ~MapToWorldPointReply();

  MapToWorldPointReply(const MapToWorldPointReply& from);

  inline MapToWorldPointReply& operator=(const MapToWorldPointReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapToWorldPointReply(MapToWorldPointReply&& from) noexcept
    : MapToWorldPointReply() {
    *this = ::std::move(from);
  }

  inline MapToWorldPointReply& operator=(MapToWorldPointReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapToWorldPointReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapToWorldPointReply* internal_default_instance() {
    return reinterpret_cast<const MapToWorldPointReply*>(
               &_MapToWorldPointReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MapToWorldPointReply* other);
  friend void swap(MapToWorldPointReply& a, MapToWorldPointReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapToWorldPointReply* New() const final {
    return CreateMaybeMessage<MapToWorldPointReply>(NULL);
  }

  MapToWorldPointReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapToWorldPointReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapToWorldPointReply& from);
  void MergeFrom(const MapToWorldPointReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapToWorldPointReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 world_point = 1;
  bool has_world_point() const;
  void clear_world_point();
  static const int kWorldPointFieldNumber = 1;
  private:
  const ::metamoto::types::Vector3& _internal_world_point() const;
  public:
  const ::metamoto::types::Vector3& world_point() const;
  ::metamoto::types::Vector3* release_world_point();
  ::metamoto::types::Vector3* mutable_world_point();
  void set_allocated_world_point(::metamoto::types::Vector3* world_point);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapToWorldPointReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* world_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapGetHeadingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetHeadingRequest) */ {
 public:
  MapGetHeadingRequest();
  virtual ~MapGetHeadingRequest();

  MapGetHeadingRequest(const MapGetHeadingRequest& from);

  inline MapGetHeadingRequest& operator=(const MapGetHeadingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetHeadingRequest(MapGetHeadingRequest&& from) noexcept
    : MapGetHeadingRequest() {
    *this = ::std::move(from);
  }

  inline MapGetHeadingRequest& operator=(MapGetHeadingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetHeadingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetHeadingRequest* internal_default_instance() {
    return reinterpret_cast<const MapGetHeadingRequest*>(
               &_MapGetHeadingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MapGetHeadingRequest* other);
  friend void swap(MapGetHeadingRequest& a, MapGetHeadingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetHeadingRequest* New() const final {
    return CreateMaybeMessage<MapGetHeadingRequest>(NULL);
  }

  MapGetHeadingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetHeadingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetHeadingRequest& from);
  void MergeFrom(const MapGetHeadingRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetHeadingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.RoadPoint road_point = 1;
  bool has_road_point() const;
  void clear_road_point();
  static const int kRoadPointFieldNumber = 1;
  private:
  const ::metamoto::types::RoadPoint& _internal_road_point() const;
  public:
  const ::metamoto::types::RoadPoint& road_point() const;
  ::metamoto::types::RoadPoint* release_road_point();
  ::metamoto::types::RoadPoint* mutable_road_point();
  void set_allocated_road_point(::metamoto::types::RoadPoint* road_point);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetHeadingRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::RoadPoint* road_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapGetHeadingReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetHeadingReply) */ {
 public:
  MapGetHeadingReply();
  virtual ~MapGetHeadingReply();

  MapGetHeadingReply(const MapGetHeadingReply& from);

  inline MapGetHeadingReply& operator=(const MapGetHeadingReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetHeadingReply(MapGetHeadingReply&& from) noexcept
    : MapGetHeadingReply() {
    *this = ::std::move(from);
  }

  inline MapGetHeadingReply& operator=(MapGetHeadingReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetHeadingReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetHeadingReply* internal_default_instance() {
    return reinterpret_cast<const MapGetHeadingReply*>(
               &_MapGetHeadingReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MapGetHeadingReply* other);
  friend void swap(MapGetHeadingReply& a, MapGetHeadingReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetHeadingReply* New() const final {
    return CreateMaybeMessage<MapGetHeadingReply>(NULL);
  }

  MapGetHeadingReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetHeadingReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetHeadingReply& from);
  void MergeFrom(const MapGetHeadingReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetHeadingReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Vector3 heading = 1;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 1;
  private:
  const ::metamoto::types::Vector3& _internal_heading() const;
  public:
  const ::metamoto::types::Vector3& heading() const;
  ::metamoto::types::Vector3* release_heading();
  ::metamoto::types::Vector3* mutable_heading();
  void set_allocated_heading(::metamoto::types::Vector3* heading);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetHeadingReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Vector3* heading_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapGetPathRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetPathRequest) */ {
 public:
  MapGetPathRequest();
  virtual ~MapGetPathRequest();

  MapGetPathRequest(const MapGetPathRequest& from);

  inline MapGetPathRequest& operator=(const MapGetPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetPathRequest(MapGetPathRequest&& from) noexcept
    : MapGetPathRequest() {
    *this = ::std::move(from);
  }

  inline MapGetPathRequest& operator=(MapGetPathRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetPathRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetPathRequest* internal_default_instance() {
    return reinterpret_cast<const MapGetPathRequest*>(
               &_MapGetPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MapGetPathRequest* other);
  friend void swap(MapGetPathRequest& a, MapGetPathRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetPathRequest* New() const final {
    return CreateMaybeMessage<MapGetPathRequest>(NULL);
  }

  MapGetPathRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetPathRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetPathRequest& from);
  void MergeFrom(const MapGetPathRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetPathRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metamoto.types.Waypoint from_point = 1;
  bool has_from_point() const;
  void clear_from_point();
  static const int kFromPointFieldNumber = 1;
  private:
  const ::metamoto::types::Waypoint& _internal_from_point() const;
  public:
  const ::metamoto::types::Waypoint& from_point() const;
  ::metamoto::types::Waypoint* release_from_point();
  ::metamoto::types::Waypoint* mutable_from_point();
  void set_allocated_from_point(::metamoto::types::Waypoint* from_point);

  // .metamoto.types.Waypoint to_point = 2;
  bool has_to_point() const;
  void clear_to_point();
  static const int kToPointFieldNumber = 2;
  private:
  const ::metamoto::types::Waypoint& _internal_to_point() const;
  public:
  const ::metamoto::types::Waypoint& to_point() const;
  ::metamoto::types::Waypoint* release_to_point();
  ::metamoto::types::Waypoint* mutable_to_point();
  void set_allocated_to_point(::metamoto::types::Waypoint* to_point);

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetPathRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metamoto::types::Waypoint* from_point_;
  ::metamoto::types::Waypoint* to_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapGetPathReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metamoto.services.MapGetPathReply) */ {
 public:
  MapGetPathReply();
  virtual ~MapGetPathReply();

  MapGetPathReply(const MapGetPathReply& from);

  inline MapGetPathReply& operator=(const MapGetPathReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGetPathReply(MapGetPathReply&& from) noexcept
    : MapGetPathReply() {
    *this = ::std::move(from);
  }

  inline MapGetPathReply& operator=(MapGetPathReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGetPathReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGetPathReply* internal_default_instance() {
    return reinterpret_cast<const MapGetPathReply*>(
               &_MapGetPathReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MapGetPathReply* other);
  friend void swap(MapGetPathReply& a, MapGetPathReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGetPathReply* New() const final {
    return CreateMaybeMessage<MapGetPathReply>(NULL);
  }

  MapGetPathReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapGetPathReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapGetPathReply& from);
  void MergeFrom(const MapGetPathReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapGetPathReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metamoto.types.Waypoint path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  ::metamoto::types::Waypoint* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
      mutable_path();
  const ::metamoto::types::Waypoint& path(int index) const;
  ::metamoto::types::Waypoint* add_path();
  const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
      path() const;

  // @@protoc_insertion_point(class_scope:metamoto.services.MapGetPathReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint > path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_metamoto_2fservices_2fmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MapGetRoadNetworkRequest

// -------------------------------------------------------------------

// MapGetRoadNetworkReply

// .metamoto.types.RoadNetwork road_network = 1;
inline bool MapGetRoadNetworkReply::has_road_network() const {
  return this != internal_default_instance() && road_network_ != NULL;
}
inline const ::metamoto::types::RoadNetwork& MapGetRoadNetworkReply::_internal_road_network() const {
  return *road_network_;
}
inline const ::metamoto::types::RoadNetwork& MapGetRoadNetworkReply::road_network() const {
  const ::metamoto::types::RoadNetwork* p = road_network_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetRoadNetworkReply.road_network)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::RoadNetwork*>(
      &::metamoto::types::_RoadNetwork_default_instance_);
}
inline ::metamoto::types::RoadNetwork* MapGetRoadNetworkReply::release_road_network() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapGetRoadNetworkReply.road_network)
  
  ::metamoto::types::RoadNetwork* temp = road_network_;
  road_network_ = NULL;
  return temp;
}
inline ::metamoto::types::RoadNetwork* MapGetRoadNetworkReply::mutable_road_network() {
  
  if (road_network_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::RoadNetwork>(GetArenaNoVirtual());
    road_network_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetRoadNetworkReply.road_network)
  return road_network_;
}
inline void MapGetRoadNetworkReply::set_allocated_road_network(::metamoto::types::RoadNetwork* road_network) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(road_network_);
  }
  if (road_network) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_network = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_network, submessage_arena);
    }
    
  } else {
    
  }
  road_network_ = road_network;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapGetRoadNetworkReply.road_network)
}

// -------------------------------------------------------------------

// MapToRoadPointRequest

// .metamoto.types.Vector3 world_point = 1;
inline bool MapToRoadPointRequest::has_world_point() const {
  return this != internal_default_instance() && world_point_ != NULL;
}
inline const ::metamoto::types::Vector3& MapToRoadPointRequest::_internal_world_point() const {
  return *world_point_;
}
inline const ::metamoto::types::Vector3& MapToRoadPointRequest::world_point() const {
  const ::metamoto::types::Vector3* p = world_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapToRoadPointRequest.world_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* MapToRoadPointRequest::release_world_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapToRoadPointRequest.world_point)
  
  ::metamoto::types::Vector3* temp = world_point_;
  world_point_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* MapToRoadPointRequest::mutable_world_point() {
  
  if (world_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    world_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapToRoadPointRequest.world_point)
  return world_point_;
}
inline void MapToRoadPointRequest::set_allocated_world_point(::metamoto::types::Vector3* world_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_point_);
  }
  if (world_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_point, submessage_arena);
    }
    
  } else {
    
  }
  world_point_ = world_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapToRoadPointRequest.world_point)
}

// float vertical_tolerance = 2;
inline void MapToRoadPointRequest::clear_vertical_tolerance() {
  vertical_tolerance_ = 0;
}
inline float MapToRoadPointRequest::vertical_tolerance() const {
  // @@protoc_insertion_point(field_get:metamoto.services.MapToRoadPointRequest.vertical_tolerance)
  return vertical_tolerance_;
}
inline void MapToRoadPointRequest::set_vertical_tolerance(float value) {
  
  vertical_tolerance_ = value;
  // @@protoc_insertion_point(field_set:metamoto.services.MapToRoadPointRequest.vertical_tolerance)
}

// -------------------------------------------------------------------

// MapToRoadPointReply

// repeated .metamoto.types.RoadPoint road_points = 1;
inline int MapToRoadPointReply::road_points_size() const {
  return road_points_.size();
}
inline ::metamoto::types::RoadPoint* MapToRoadPointReply::mutable_road_points(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapToRoadPointReply.road_points)
  return road_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::RoadPoint >*
MapToRoadPointReply::mutable_road_points() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.services.MapToRoadPointReply.road_points)
  return &road_points_;
}
inline const ::metamoto::types::RoadPoint& MapToRoadPointReply::road_points(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.services.MapToRoadPointReply.road_points)
  return road_points_.Get(index);
}
inline ::metamoto::types::RoadPoint* MapToRoadPointReply::add_road_points() {
  // @@protoc_insertion_point(field_add:metamoto.services.MapToRoadPointReply.road_points)
  return road_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::RoadPoint >&
MapToRoadPointReply::road_points() const {
  // @@protoc_insertion_point(field_list:metamoto.services.MapToRoadPointReply.road_points)
  return road_points_;
}

// -------------------------------------------------------------------

// MapToWorldPointRequest

// .metamoto.types.RoadPoint road_point = 1;
inline bool MapToWorldPointRequest::has_road_point() const {
  return this != internal_default_instance() && road_point_ != NULL;
}
inline const ::metamoto::types::RoadPoint& MapToWorldPointRequest::_internal_road_point() const {
  return *road_point_;
}
inline const ::metamoto::types::RoadPoint& MapToWorldPointRequest::road_point() const {
  const ::metamoto::types::RoadPoint* p = road_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapToWorldPointRequest.road_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::RoadPoint*>(
      &::metamoto::types::_RoadPoint_default_instance_);
}
inline ::metamoto::types::RoadPoint* MapToWorldPointRequest::release_road_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapToWorldPointRequest.road_point)
  
  ::metamoto::types::RoadPoint* temp = road_point_;
  road_point_ = NULL;
  return temp;
}
inline ::metamoto::types::RoadPoint* MapToWorldPointRequest::mutable_road_point() {
  
  if (road_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::RoadPoint>(GetArenaNoVirtual());
    road_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapToWorldPointRequest.road_point)
  return road_point_;
}
inline void MapToWorldPointRequest::set_allocated_road_point(::metamoto::types::RoadPoint* road_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(road_point_);
  }
  if (road_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_point, submessage_arena);
    }
    
  } else {
    
  }
  road_point_ = road_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapToWorldPointRequest.road_point)
}

// -------------------------------------------------------------------

// MapToWorldPointReply

// .metamoto.types.Vector3 world_point = 1;
inline bool MapToWorldPointReply::has_world_point() const {
  return this != internal_default_instance() && world_point_ != NULL;
}
inline const ::metamoto::types::Vector3& MapToWorldPointReply::_internal_world_point() const {
  return *world_point_;
}
inline const ::metamoto::types::Vector3& MapToWorldPointReply::world_point() const {
  const ::metamoto::types::Vector3* p = world_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapToWorldPointReply.world_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* MapToWorldPointReply::release_world_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapToWorldPointReply.world_point)
  
  ::metamoto::types::Vector3* temp = world_point_;
  world_point_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* MapToWorldPointReply::mutable_world_point() {
  
  if (world_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    world_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapToWorldPointReply.world_point)
  return world_point_;
}
inline void MapToWorldPointReply::set_allocated_world_point(::metamoto::types::Vector3* world_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_point_);
  }
  if (world_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_point, submessage_arena);
    }
    
  } else {
    
  }
  world_point_ = world_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapToWorldPointReply.world_point)
}

// -------------------------------------------------------------------

// MapGetHeadingRequest

// .metamoto.types.RoadPoint road_point = 1;
inline bool MapGetHeadingRequest::has_road_point() const {
  return this != internal_default_instance() && road_point_ != NULL;
}
inline const ::metamoto::types::RoadPoint& MapGetHeadingRequest::_internal_road_point() const {
  return *road_point_;
}
inline const ::metamoto::types::RoadPoint& MapGetHeadingRequest::road_point() const {
  const ::metamoto::types::RoadPoint* p = road_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetHeadingRequest.road_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::RoadPoint*>(
      &::metamoto::types::_RoadPoint_default_instance_);
}
inline ::metamoto::types::RoadPoint* MapGetHeadingRequest::release_road_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapGetHeadingRequest.road_point)
  
  ::metamoto::types::RoadPoint* temp = road_point_;
  road_point_ = NULL;
  return temp;
}
inline ::metamoto::types::RoadPoint* MapGetHeadingRequest::mutable_road_point() {
  
  if (road_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::RoadPoint>(GetArenaNoVirtual());
    road_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetHeadingRequest.road_point)
  return road_point_;
}
inline void MapGetHeadingRequest::set_allocated_road_point(::metamoto::types::RoadPoint* road_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(road_point_);
  }
  if (road_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_point, submessage_arena);
    }
    
  } else {
    
  }
  road_point_ = road_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapGetHeadingRequest.road_point)
}

// -------------------------------------------------------------------

// MapGetHeadingReply

// .metamoto.types.Vector3 heading = 1;
inline bool MapGetHeadingReply::has_heading() const {
  return this != internal_default_instance() && heading_ != NULL;
}
inline const ::metamoto::types::Vector3& MapGetHeadingReply::_internal_heading() const {
  return *heading_;
}
inline const ::metamoto::types::Vector3& MapGetHeadingReply::heading() const {
  const ::metamoto::types::Vector3* p = heading_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetHeadingReply.heading)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Vector3*>(
      &::metamoto::types::_Vector3_default_instance_);
}
inline ::metamoto::types::Vector3* MapGetHeadingReply::release_heading() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapGetHeadingReply.heading)
  
  ::metamoto::types::Vector3* temp = heading_;
  heading_ = NULL;
  return temp;
}
inline ::metamoto::types::Vector3* MapGetHeadingReply::mutable_heading() {
  
  if (heading_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Vector3>(GetArenaNoVirtual());
    heading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetHeadingReply.heading)
  return heading_;
}
inline void MapGetHeadingReply::set_allocated_heading(::metamoto::types::Vector3* heading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(heading_);
  }
  if (heading) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heading, submessage_arena);
    }
    
  } else {
    
  }
  heading_ = heading;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapGetHeadingReply.heading)
}

// -------------------------------------------------------------------

// MapGetPathRequest

// .metamoto.types.Waypoint from_point = 1;
inline bool MapGetPathRequest::has_from_point() const {
  return this != internal_default_instance() && from_point_ != NULL;
}
inline const ::metamoto::types::Waypoint& MapGetPathRequest::_internal_from_point() const {
  return *from_point_;
}
inline const ::metamoto::types::Waypoint& MapGetPathRequest::from_point() const {
  const ::metamoto::types::Waypoint* p = from_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetPathRequest.from_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Waypoint*>(
      &::metamoto::types::_Waypoint_default_instance_);
}
inline ::metamoto::types::Waypoint* MapGetPathRequest::release_from_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapGetPathRequest.from_point)
  
  ::metamoto::types::Waypoint* temp = from_point_;
  from_point_ = NULL;
  return temp;
}
inline ::metamoto::types::Waypoint* MapGetPathRequest::mutable_from_point() {
  
  if (from_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Waypoint>(GetArenaNoVirtual());
    from_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetPathRequest.from_point)
  return from_point_;
}
inline void MapGetPathRequest::set_allocated_from_point(::metamoto::types::Waypoint* from_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(from_point_);
  }
  if (from_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      from_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from_point, submessage_arena);
    }
    
  } else {
    
  }
  from_point_ = from_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapGetPathRequest.from_point)
}

// .metamoto.types.Waypoint to_point = 2;
inline bool MapGetPathRequest::has_to_point() const {
  return this != internal_default_instance() && to_point_ != NULL;
}
inline const ::metamoto::types::Waypoint& MapGetPathRequest::_internal_to_point() const {
  return *to_point_;
}
inline const ::metamoto::types::Waypoint& MapGetPathRequest::to_point() const {
  const ::metamoto::types::Waypoint* p = to_point_;
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetPathRequest.to_point)
  return p != NULL ? *p : *reinterpret_cast<const ::metamoto::types::Waypoint*>(
      &::metamoto::types::_Waypoint_default_instance_);
}
inline ::metamoto::types::Waypoint* MapGetPathRequest::release_to_point() {
  // @@protoc_insertion_point(field_release:metamoto.services.MapGetPathRequest.to_point)
  
  ::metamoto::types::Waypoint* temp = to_point_;
  to_point_ = NULL;
  return temp;
}
inline ::metamoto::types::Waypoint* MapGetPathRequest::mutable_to_point() {
  
  if (to_point_ == NULL) {
    auto* p = CreateMaybeMessage<::metamoto::types::Waypoint>(GetArenaNoVirtual());
    to_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetPathRequest.to_point)
  return to_point_;
}
inline void MapGetPathRequest::set_allocated_to_point(::metamoto::types::Waypoint* to_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(to_point_);
  }
  if (to_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      to_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, to_point, submessage_arena);
    }
    
  } else {
    
  }
  to_point_ = to_point;
  // @@protoc_insertion_point(field_set_allocated:metamoto.services.MapGetPathRequest.to_point)
}

// -------------------------------------------------------------------

// MapGetPathReply

// repeated .metamoto.types.Waypoint path = 1;
inline int MapGetPathReply::path_size() const {
  return path_.size();
}
inline ::metamoto::types::Waypoint* MapGetPathReply::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:metamoto.services.MapGetPathReply.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >*
MapGetPathReply::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:metamoto.services.MapGetPathReply.path)
  return &path_;
}
inline const ::metamoto::types::Waypoint& MapGetPathReply::path(int index) const {
  // @@protoc_insertion_point(field_get:metamoto.services.MapGetPathReply.path)
  return path_.Get(index);
}
inline ::metamoto::types::Waypoint* MapGetPathReply::add_path() {
  // @@protoc_insertion_point(field_add:metamoto.services.MapGetPathReply.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::metamoto::types::Waypoint >&
MapGetPathReply::path() const {
  // @@protoc_insertion_point(field_list:metamoto.services.MapGetPathReply.path)
  return path_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace services
}  // namespace metamoto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_metamoto_2fservices_2fmap_2eproto
