/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.metamoto = (function() {

    /**
     * Namespace metamoto.
     * @exports metamoto
     * @namespace
     */
    var metamoto = {};

    metamoto.types = (function() {

        /**
         * Namespace types.
         * @memberof metamoto
         * @namespace
         */
        var types = {};

        types.Acceleration = (function() {

            /**
             * Properties of an Acceleration.
             * @memberof metamoto.types
             * @interface IAcceleration
             * @property {metamoto.types.IVector3|null} [linear] Acceleration linear
             * @property {metamoto.types.IVector3|null} [angular] Acceleration angular
             */

            /**
             * Constructs a new Acceleration.
             * @memberof metamoto.types
             * @classdesc Represents an Acceleration.
             * @implements IAcceleration
             * @constructor
             * @param {metamoto.types.IAcceleration=} [properties] Properties to set
             */
            function Acceleration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Acceleration linear.
             * @member {metamoto.types.IVector3|null|undefined} linear
             * @memberof metamoto.types.Acceleration
             * @instance
             */
            Acceleration.prototype.linear = null;

            /**
             * Acceleration angular.
             * @member {metamoto.types.IVector3|null|undefined} angular
             * @memberof metamoto.types.Acceleration
             * @instance
             */
            Acceleration.prototype.angular = null;

            /**
             * Creates a new Acceleration instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {metamoto.types.IAcceleration=} [properties] Properties to set
             * @returns {metamoto.types.Acceleration} Acceleration instance
             */
            Acceleration.create = function create(properties) {
                return new Acceleration(properties);
            };

            /**
             * Encodes the specified Acceleration message. Does not implicitly {@link metamoto.types.Acceleration.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {metamoto.types.IAcceleration} message Acceleration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acceleration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.linear != null && message.hasOwnProperty("linear"))
                    $root.metamoto.types.Vector3.encode(message.linear, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.angular != null && message.hasOwnProperty("angular"))
                    $root.metamoto.types.Vector3.encode(message.angular, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Acceleration message, length delimited. Does not implicitly {@link metamoto.types.Acceleration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {metamoto.types.IAcceleration} message Acceleration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acceleration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Acceleration message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Acceleration} Acceleration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acceleration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Acceleration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.linear = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.angular = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Acceleration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Acceleration} Acceleration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acceleration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Acceleration message.
             * @function verify
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Acceleration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.linear != null && message.hasOwnProperty("linear")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linear);
                    if (error)
                        return "linear." + error;
                }
                if (message.angular != null && message.hasOwnProperty("angular")) {
                    var error = $root.metamoto.types.Vector3.verify(message.angular);
                    if (error)
                        return "angular." + error;
                }
                return null;
            };

            /**
             * Creates an Acceleration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Acceleration} Acceleration
             */
            Acceleration.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Acceleration)
                    return object;
                var message = new $root.metamoto.types.Acceleration();
                if (object.linear != null) {
                    if (typeof object.linear !== "object")
                        throw TypeError(".metamoto.types.Acceleration.linear: object expected");
                    message.linear = $root.metamoto.types.Vector3.fromObject(object.linear);
                }
                if (object.angular != null) {
                    if (typeof object.angular !== "object")
                        throw TypeError(".metamoto.types.Acceleration.angular: object expected");
                    message.angular = $root.metamoto.types.Vector3.fromObject(object.angular);
                }
                return message;
            };

            /**
             * Creates a plain object from an Acceleration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Acceleration
             * @static
             * @param {metamoto.types.Acceleration} message Acceleration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Acceleration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.linear = null;
                    object.angular = null;
                }
                if (message.linear != null && message.hasOwnProperty("linear"))
                    object.linear = $root.metamoto.types.Vector3.toObject(message.linear, options);
                if (message.angular != null && message.hasOwnProperty("angular"))
                    object.angular = $root.metamoto.types.Vector3.toObject(message.angular, options);
                return object;
            };

            /**
             * Converts this Acceleration to JSON.
             * @function toJSON
             * @memberof metamoto.types.Acceleration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Acceleration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Acceleration;
        })();

        types.Asset = (function() {

            /**
             * Properties of an Asset.
             * @memberof metamoto.types
             * @interface IAsset
             * @property {string|null} [name] Asset name
             * @property {string|null} [version] Asset version
             */

            /**
             * Constructs a new Asset.
             * @memberof metamoto.types
             * @classdesc Represents an Asset.
             * @implements IAsset
             * @constructor
             * @param {metamoto.types.IAsset=} [properties] Properties to set
             */
            function Asset(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Asset name.
             * @member {string} name
             * @memberof metamoto.types.Asset
             * @instance
             */
            Asset.prototype.name = "";

            /**
             * Asset version.
             * @member {string} version
             * @memberof metamoto.types.Asset
             * @instance
             */
            Asset.prototype.version = "";

            /**
             * Creates a new Asset instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Asset
             * @static
             * @param {metamoto.types.IAsset=} [properties] Properties to set
             * @returns {metamoto.types.Asset} Asset instance
             */
            Asset.create = function create(properties) {
                return new Asset(properties);
            };

            /**
             * Encodes the specified Asset message. Does not implicitly {@link metamoto.types.Asset.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Asset
             * @static
             * @param {metamoto.types.IAsset} message Asset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Asset.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                return writer;
            };

            /**
             * Encodes the specified Asset message, length delimited. Does not implicitly {@link metamoto.types.Asset.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Asset
             * @static
             * @param {metamoto.types.IAsset} message Asset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Asset.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Asset message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Asset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Asset} Asset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Asset.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Asset();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Asset message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Asset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Asset} Asset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Asset.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Asset message.
             * @function verify
             * @memberof metamoto.types.Asset
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Asset.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };

            /**
             * Creates an Asset message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Asset
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Asset} Asset
             */
            Asset.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Asset)
                    return object;
                var message = new $root.metamoto.types.Asset();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };

            /**
             * Creates a plain object from an Asset message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Asset
             * @static
             * @param {metamoto.types.Asset} message Asset
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Asset.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };

            /**
             * Converts this Asset to JSON.
             * @function toJSON
             * @memberof metamoto.types.Asset
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Asset.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Asset;
        })();

        types.BoundingBox = (function() {

            /**
             * Properties of a BoundingBox.
             * @memberof metamoto.types
             * @interface IBoundingBox
             * @property {metamoto.types.IVector3|null} [center] BoundingBox center
             * @property {metamoto.types.IVector3|null} [extents] BoundingBox extents
             * @property {metamoto.types.IQuaternion|null} [orientation] BoundingBox orientation
             * @property {string|null} [color] BoundingBox color
             */

            /**
             * Constructs a new BoundingBox.
             * @memberof metamoto.types
             * @classdesc Represents a BoundingBox.
             * @implements IBoundingBox
             * @constructor
             * @param {metamoto.types.IBoundingBox=} [properties] Properties to set
             */
            function BoundingBox(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoundingBox center.
             * @member {metamoto.types.IVector3|null|undefined} center
             * @memberof metamoto.types.BoundingBox
             * @instance
             */
            BoundingBox.prototype.center = null;

            /**
             * BoundingBox extents.
             * @member {metamoto.types.IVector3|null|undefined} extents
             * @memberof metamoto.types.BoundingBox
             * @instance
             */
            BoundingBox.prototype.extents = null;

            /**
             * BoundingBox orientation.
             * @member {metamoto.types.IQuaternion|null|undefined} orientation
             * @memberof metamoto.types.BoundingBox
             * @instance
             */
            BoundingBox.prototype.orientation = null;

            /**
             * BoundingBox color.
             * @member {string} color
             * @memberof metamoto.types.BoundingBox
             * @instance
             */
            BoundingBox.prototype.color = "";

            /**
             * Creates a new BoundingBox instance using the specified properties.
             * @function create
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {metamoto.types.IBoundingBox=} [properties] Properties to set
             * @returns {metamoto.types.BoundingBox} BoundingBox instance
             */
            BoundingBox.create = function create(properties) {
                return new BoundingBox(properties);
            };

            /**
             * Encodes the specified BoundingBox message. Does not implicitly {@link metamoto.types.BoundingBox.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {metamoto.types.IBoundingBox} message BoundingBox message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundingBox.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.center != null && message.hasOwnProperty("center"))
                    $root.metamoto.types.Vector3.encode(message.center, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.extents != null && message.hasOwnProperty("extents"))
                    $root.metamoto.types.Vector3.encode(message.extents, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    $root.metamoto.types.Quaternion.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.color != null && message.hasOwnProperty("color"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.color);
                return writer;
            };

            /**
             * Encodes the specified BoundingBox message, length delimited. Does not implicitly {@link metamoto.types.BoundingBox.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {metamoto.types.IBoundingBox} message BoundingBox message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundingBox.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoundingBox message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.BoundingBox} BoundingBox
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundingBox.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.BoundingBox();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.center = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.extents = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.orientation = $root.metamoto.types.Quaternion.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.color = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoundingBox message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.BoundingBox} BoundingBox
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundingBox.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoundingBox message.
             * @function verify
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoundingBox.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.center != null && message.hasOwnProperty("center")) {
                    var error = $root.metamoto.types.Vector3.verify(message.center);
                    if (error)
                        return "center." + error;
                }
                if (message.extents != null && message.hasOwnProperty("extents")) {
                    var error = $root.metamoto.types.Vector3.verify(message.extents);
                    if (error)
                        return "extents." + error;
                }
                if (message.orientation != null && message.hasOwnProperty("orientation")) {
                    var error = $root.metamoto.types.Quaternion.verify(message.orientation);
                    if (error)
                        return "orientation." + error;
                }
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isString(message.color))
                        return "color: string expected";
                return null;
            };

            /**
             * Creates a BoundingBox message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.BoundingBox} BoundingBox
             */
            BoundingBox.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.BoundingBox)
                    return object;
                var message = new $root.metamoto.types.BoundingBox();
                if (object.center != null) {
                    if (typeof object.center !== "object")
                        throw TypeError(".metamoto.types.BoundingBox.center: object expected");
                    message.center = $root.metamoto.types.Vector3.fromObject(object.center);
                }
                if (object.extents != null) {
                    if (typeof object.extents !== "object")
                        throw TypeError(".metamoto.types.BoundingBox.extents: object expected");
                    message.extents = $root.metamoto.types.Vector3.fromObject(object.extents);
                }
                if (object.orientation != null) {
                    if (typeof object.orientation !== "object")
                        throw TypeError(".metamoto.types.BoundingBox.orientation: object expected");
                    message.orientation = $root.metamoto.types.Quaternion.fromObject(object.orientation);
                }
                if (object.color != null)
                    message.color = String(object.color);
                return message;
            };

            /**
             * Creates a plain object from a BoundingBox message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.BoundingBox
             * @static
             * @param {metamoto.types.BoundingBox} message BoundingBox
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoundingBox.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.center = null;
                    object.extents = null;
                    object.orientation = null;
                    object.color = "";
                }
                if (message.center != null && message.hasOwnProperty("center"))
                    object.center = $root.metamoto.types.Vector3.toObject(message.center, options);
                if (message.extents != null && message.hasOwnProperty("extents"))
                    object.extents = $root.metamoto.types.Vector3.toObject(message.extents, options);
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    object.orientation = $root.metamoto.types.Quaternion.toObject(message.orientation, options);
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = message.color;
                return object;
            };

            /**
             * Converts this BoundingBox to JSON.
             * @function toJSON
             * @memberof metamoto.types.BoundingBox
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoundingBox.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoundingBox;
        })();

        types.CameraObject = (function() {

            /**
             * Properties of a CameraObject.
             * @memberof metamoto.types
             * @interface ICameraObject
             * @property {number|null} [objectId] CameraObject objectId
             * @property {metamoto.types.ObjectType|null} [objectType] CameraObject objectType
             * @property {metamoto.types.ReferenceFrame|null} [referenceFrame] CameraObject referenceFrame
             * @property {metamoto.types.IPose|null} [pose] CameraObject pose
             * @property {metamoto.types.IVelocity|null} [velocity] CameraObject velocity
             * @property {metamoto.types.IAcceleration|null} [acceleration] CameraObject acceleration
             * @property {metamoto.types.IShape|null} [shape] CameraObject shape
             * @property {number|null} [xLowerLeft] CameraObject xLowerLeft
             * @property {number|null} [yLowerLeft] CameraObject yLowerLeft
             * @property {number|null} [xUpperRight] CameraObject xUpperRight
             * @property {number|null} [yUpperRight] CameraObject yUpperRight
             * @property {number|null} [pixelCount] CameraObject pixelCount
             */

            /**
             * Constructs a new CameraObject.
             * @memberof metamoto.types
             * @classdesc Represents a CameraObject.
             * @implements ICameraObject
             * @constructor
             * @param {metamoto.types.ICameraObject=} [properties] Properties to set
             */
            function CameraObject(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CameraObject objectId.
             * @member {number} objectId
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.objectId = 0;

            /**
             * CameraObject objectType.
             * @member {metamoto.types.ObjectType} objectType
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.objectType = 0;

            /**
             * CameraObject referenceFrame.
             * @member {metamoto.types.ReferenceFrame} referenceFrame
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.referenceFrame = 0;

            /**
             * CameraObject pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.pose = null;

            /**
             * CameraObject velocity.
             * @member {metamoto.types.IVelocity|null|undefined} velocity
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.velocity = null;

            /**
             * CameraObject acceleration.
             * @member {metamoto.types.IAcceleration|null|undefined} acceleration
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.acceleration = null;

            /**
             * CameraObject shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.shape = null;

            /**
             * CameraObject xLowerLeft.
             * @member {number} xLowerLeft
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.xLowerLeft = 0;

            /**
             * CameraObject yLowerLeft.
             * @member {number} yLowerLeft
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.yLowerLeft = 0;

            /**
             * CameraObject xUpperRight.
             * @member {number} xUpperRight
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.xUpperRight = 0;

            /**
             * CameraObject yUpperRight.
             * @member {number} yUpperRight
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.yUpperRight = 0;

            /**
             * CameraObject pixelCount.
             * @member {number} pixelCount
             * @memberof metamoto.types.CameraObject
             * @instance
             */
            CameraObject.prototype.pixelCount = 0;

            /**
             * Creates a new CameraObject instance using the specified properties.
             * @function create
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {metamoto.types.ICameraObject=} [properties] Properties to set
             * @returns {metamoto.types.CameraObject} CameraObject instance
             */
            CameraObject.create = function create(properties) {
                return new CameraObject(properties);
            };

            /**
             * Encodes the specified CameraObject message. Does not implicitly {@link metamoto.types.CameraObject.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {metamoto.types.ICameraObject} message CameraObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CameraObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.objectId);
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.objectType);
                if (message.referenceFrame != null && message.hasOwnProperty("referenceFrame"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.referenceFrame);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    $root.metamoto.types.Velocity.encode(message.velocity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.metamoto.types.Acceleration.encode(message.acceleration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.xLowerLeft != null && message.hasOwnProperty("xLowerLeft"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.xLowerLeft);
                if (message.yLowerLeft != null && message.hasOwnProperty("yLowerLeft"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.yLowerLeft);
                if (message.xUpperRight != null && message.hasOwnProperty("xUpperRight"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.xUpperRight);
                if (message.yUpperRight != null && message.hasOwnProperty("yUpperRight"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.yUpperRight);
                if (message.pixelCount != null && message.hasOwnProperty("pixelCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.pixelCount);
                return writer;
            };

            /**
             * Encodes the specified CameraObject message, length delimited. Does not implicitly {@link metamoto.types.CameraObject.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {metamoto.types.ICameraObject} message CameraObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CameraObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CameraObject message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.CameraObject} CameraObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CameraObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.CameraObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.objectId = reader.uint32();
                        break;
                    case 2:
                        message.objectType = reader.int32();
                        break;
                    case 3:
                        message.referenceFrame = reader.int32();
                        break;
                    case 4:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.velocity = $root.metamoto.types.Velocity.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.acceleration = $root.metamoto.types.Acceleration.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.xLowerLeft = reader.uint32();
                        break;
                    case 9:
                        message.yLowerLeft = reader.uint32();
                        break;
                    case 10:
                        message.xUpperRight = reader.uint32();
                        break;
                    case 11:
                        message.yUpperRight = reader.uint32();
                        break;
                    case 12:
                        message.pixelCount = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CameraObject message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.CameraObject} CameraObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CameraObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CameraObject message.
             * @function verify
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CameraObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    if (!$util.isInteger(message.objectId))
                        return "objectId: integer expected";
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    switch (message.objectType) {
                    default:
                        return "objectType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.referenceFrame != null && message.hasOwnProperty("referenceFrame"))
                    switch (message.referenceFrame) {
                    default:
                        return "referenceFrame: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    var error = $root.metamoto.types.Velocity.verify(message.velocity);
                    if (error)
                        return "velocity." + error;
                }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.metamoto.types.Acceleration.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.xLowerLeft != null && message.hasOwnProperty("xLowerLeft"))
                    if (!$util.isInteger(message.xLowerLeft))
                        return "xLowerLeft: integer expected";
                if (message.yLowerLeft != null && message.hasOwnProperty("yLowerLeft"))
                    if (!$util.isInteger(message.yLowerLeft))
                        return "yLowerLeft: integer expected";
                if (message.xUpperRight != null && message.hasOwnProperty("xUpperRight"))
                    if (!$util.isInteger(message.xUpperRight))
                        return "xUpperRight: integer expected";
                if (message.yUpperRight != null && message.hasOwnProperty("yUpperRight"))
                    if (!$util.isInteger(message.yUpperRight))
                        return "yUpperRight: integer expected";
                if (message.pixelCount != null && message.hasOwnProperty("pixelCount"))
                    if (!$util.isInteger(message.pixelCount))
                        return "pixelCount: integer expected";
                return null;
            };

            /**
             * Creates a CameraObject message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.CameraObject} CameraObject
             */
            CameraObject.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.CameraObject)
                    return object;
                var message = new $root.metamoto.types.CameraObject();
                if (object.objectId != null)
                    message.objectId = object.objectId >>> 0;
                switch (object.objectType) {
                case "OBJECT_UNKNOWN":
                case 0:
                    message.objectType = 0;
                    break;
                case "OBJECT_OTHER":
                case 1:
                    message.objectType = 1;
                    break;
                case "OBJECT_CAR":
                case 2:
                    message.objectType = 2;
                    break;
                case "OBJECT_TRUCK":
                case 3:
                    message.objectType = 3;
                    break;
                case "OBJECT_BUS":
                case 4:
                    message.objectType = 4;
                    break;
                case "OBJECT_MOTORCYCLE":
                case 5:
                    message.objectType = 5;
                    break;
                case "OBJECT_BICYCLE":
                case 6:
                    message.objectType = 6;
                    break;
                case "OBJECT_TRAIN":
                case 7:
                    message.objectType = 7;
                    break;
                case "OBJECT_PEDESTRIAN":
                case 8:
                    message.objectType = 8;
                    break;
                case "OBJECT_ANIMAL":
                case 9:
                    message.objectType = 9;
                    break;
                case "OBJECT_TRAFFIC_LIGHT":
                case 10:
                    message.objectType = 10;
                    break;
                case "OBJECT_TRAFFIC_SIGN":
                case 11:
                    message.objectType = 11;
                    break;
                case "OBJECT_TRAFFIC_BARRIER":
                case 12:
                    message.objectType = 12;
                    break;
                case "OBJECT_TRAFFIC_CONE":
                case 13:
                    message.objectType = 13;
                    break;
                case "OBJECT_GROUND":
                case 14:
                    message.objectType = 14;
                    break;
                case "OBJECT_ROAD":
                case 15:
                    message.objectType = 15;
                    break;
                case "OBJECT_RAIL_TRACK":
                case 16:
                    message.objectType = 16;
                    break;
                case "OBJECT_SIDEWALK":
                case 17:
                    message.objectType = 17;
                    break;
                case "OBJECT_CURB":
                case 18:
                    message.objectType = 18;
                    break;
                case "OBJECT_STATIC_OBJECT":
                case 19:
                    message.objectType = 19;
                    break;
                case "OBJECT_SIGN":
                case 20:
                    message.objectType = 20;
                    break;
                case "OBJECT_POLE":
                case 21:
                    message.objectType = 21;
                    break;
                case "OBJECT_BUILDING":
                case 22:
                    message.objectType = 22;
                    break;
                case "OBJECT_WALL":
                case 23:
                    message.objectType = 23;
                    break;
                case "OBJECT_FENCE":
                case 24:
                    message.objectType = 24;
                    break;
                case "OBJECT_TREE":
                case 25:
                    message.objectType = 25;
                    break;
                case "OBJECT_VEGETATION":
                case 26:
                    message.objectType = 26;
                    break;
                }
                switch (object.referenceFrame) {
                case "REFERENCE_FRAME_UNKNOWN":
                case 0:
                    message.referenceFrame = 0;
                    break;
                case "REFERENCE_FRAME_OTHER":
                case 1:
                    message.referenceFrame = 1;
                    break;
                case "REFERENCE_FRAME_WORLD":
                case 2:
                    message.referenceFrame = 2;
                    break;
                case "REFERENCE_FRAME_VEHICLE":
                case 3:
                    message.referenceFrame = 3;
                    break;
                case "REFERENCE_FRAME_SENSOR":
                case 4:
                    message.referenceFrame = 4;
                    break;
                }
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.CameraObject.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.velocity != null) {
                    if (typeof object.velocity !== "object")
                        throw TypeError(".metamoto.types.CameraObject.velocity: object expected");
                    message.velocity = $root.metamoto.types.Velocity.fromObject(object.velocity);
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.types.CameraObject.acceleration: object expected");
                    message.acceleration = $root.metamoto.types.Acceleration.fromObject(object.acceleration);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.CameraObject.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                if (object.xLowerLeft != null)
                    message.xLowerLeft = object.xLowerLeft >>> 0;
                if (object.yLowerLeft != null)
                    message.yLowerLeft = object.yLowerLeft >>> 0;
                if (object.xUpperRight != null)
                    message.xUpperRight = object.xUpperRight >>> 0;
                if (object.yUpperRight != null)
                    message.yUpperRight = object.yUpperRight >>> 0;
                if (object.pixelCount != null)
                    message.pixelCount = object.pixelCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a CameraObject message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.CameraObject
             * @static
             * @param {metamoto.types.CameraObject} message CameraObject
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CameraObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.objectId = 0;
                    object.objectType = options.enums === String ? "OBJECT_UNKNOWN" : 0;
                    object.referenceFrame = options.enums === String ? "REFERENCE_FRAME_UNKNOWN" : 0;
                    object.pose = null;
                    object.velocity = null;
                    object.acceleration = null;
                    object.shape = null;
                    object.xLowerLeft = 0;
                    object.yLowerLeft = 0;
                    object.xUpperRight = 0;
                    object.yUpperRight = 0;
                    object.pixelCount = 0;
                }
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    object.objectId = message.objectId;
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    object.objectType = options.enums === String ? $root.metamoto.types.ObjectType[message.objectType] : message.objectType;
                if (message.referenceFrame != null && message.hasOwnProperty("referenceFrame"))
                    object.referenceFrame = options.enums === String ? $root.metamoto.types.ReferenceFrame[message.referenceFrame] : message.referenceFrame;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = $root.metamoto.types.Velocity.toObject(message.velocity, options);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.metamoto.types.Acceleration.toObject(message.acceleration, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.xLowerLeft != null && message.hasOwnProperty("xLowerLeft"))
                    object.xLowerLeft = message.xLowerLeft;
                if (message.yLowerLeft != null && message.hasOwnProperty("yLowerLeft"))
                    object.yLowerLeft = message.yLowerLeft;
                if (message.xUpperRight != null && message.hasOwnProperty("xUpperRight"))
                    object.xUpperRight = message.xUpperRight;
                if (message.yUpperRight != null && message.hasOwnProperty("yUpperRight"))
                    object.yUpperRight = message.yUpperRight;
                if (message.pixelCount != null && message.hasOwnProperty("pixelCount"))
                    object.pixelCount = message.pixelCount;
                return object;
            };

            /**
             * Converts this CameraObject to JSON.
             * @function toJSON
             * @memberof metamoto.types.CameraObject
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CameraObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CameraObject;
        })();

        types.SystemUnderTest = (function() {

            /**
             * Properties of a SystemUnderTest.
             * @memberof metamoto.types
             * @interface ISystemUnderTest
             * @property {string|null} [host] SystemUnderTest host
             * @property {number|null} [port] SystemUnderTest port
             * @property {string|null} [image] SystemUnderTest image
             * @property {Array.<string>|null} [command] SystemUnderTest command
             * @property {Array.<string>|null} [hosts] SystemUnderTest hosts
             * @property {Array.<number>|null} [ports] SystemUnderTest ports
             * @property {Array.<metamoto.types.SystemUnderTest.IContainer>|null} [containers] SystemUnderTest containers
             */

            /**
             * Constructs a new SystemUnderTest.
             * @memberof metamoto.types
             * @classdesc Represents a SystemUnderTest.
             * @implements ISystemUnderTest
             * @constructor
             * @param {metamoto.types.ISystemUnderTest=} [properties] Properties to set
             */
            function SystemUnderTest(properties) {
                this.command = [];
                this.hosts = [];
                this.ports = [];
                this.containers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SystemUnderTest host.
             * @member {string} host
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.host = "";

            /**
             * SystemUnderTest port.
             * @member {number} port
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.port = 0;

            /**
             * SystemUnderTest image.
             * @member {string} image
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.image = "";

            /**
             * SystemUnderTest command.
             * @member {Array.<string>} command
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.command = $util.emptyArray;

            /**
             * SystemUnderTest hosts.
             * @member {Array.<string>} hosts
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.hosts = $util.emptyArray;

            /**
             * SystemUnderTest ports.
             * @member {Array.<number>} ports
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.ports = $util.emptyArray;

            /**
             * SystemUnderTest containers.
             * @member {Array.<metamoto.types.SystemUnderTest.IContainer>} containers
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             */
            SystemUnderTest.prototype.containers = $util.emptyArray;

            /**
             * Creates a new SystemUnderTest instance using the specified properties.
             * @function create
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {metamoto.types.ISystemUnderTest=} [properties] Properties to set
             * @returns {metamoto.types.SystemUnderTest} SystemUnderTest instance
             */
            SystemUnderTest.create = function create(properties) {
                return new SystemUnderTest(properties);
            };

            /**
             * Encodes the specified SystemUnderTest message. Does not implicitly {@link metamoto.types.SystemUnderTest.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {metamoto.types.ISystemUnderTest} message SystemUnderTest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemUnderTest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
                if (message.image != null && message.hasOwnProperty("image"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.image);
                if (message.command != null && message.command.length)
                    for (var i = 0; i < message.command.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.command[i]);
                if (message.hosts != null && message.hosts.length)
                    for (var i = 0; i < message.hosts.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.hosts[i]);
                if (message.ports != null && message.ports.length) {
                    writer.uint32(/* id 6, wireType 2 =*/50).fork();
                    for (var i = 0; i < message.ports.length; ++i)
                        writer.int32(message.ports[i]);
                    writer.ldelim();
                }
                if (message.containers != null && message.containers.length)
                    for (var i = 0; i < message.containers.length; ++i)
                        $root.metamoto.types.SystemUnderTest.Container.encode(message.containers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SystemUnderTest message, length delimited. Does not implicitly {@link metamoto.types.SystemUnderTest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {metamoto.types.ISystemUnderTest} message SystemUnderTest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemUnderTest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SystemUnderTest message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.SystemUnderTest} SystemUnderTest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemUnderTest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SystemUnderTest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.int32();
                        break;
                    case 3:
                        message.image = reader.string();
                        break;
                    case 4:
                        if (!(message.command && message.command.length))
                            message.command = [];
                        message.command.push(reader.string());
                        break;
                    case 5:
                        if (!(message.hosts && message.hosts.length))
                            message.hosts = [];
                        message.hosts.push(reader.string());
                        break;
                    case 6:
                        if (!(message.ports && message.ports.length))
                            message.ports = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ports.push(reader.int32());
                        } else
                            message.ports.push(reader.int32());
                        break;
                    case 7:
                        if (!(message.containers && message.containers.length))
                            message.containers = [];
                        message.containers.push($root.metamoto.types.SystemUnderTest.Container.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SystemUnderTest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.SystemUnderTest} SystemUnderTest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemUnderTest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SystemUnderTest message.
             * @function verify
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SystemUnderTest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    if (!Array.isArray(message.command))
                        return "command: array expected";
                    for (var i = 0; i < message.command.length; ++i)
                        if (!$util.isString(message.command[i]))
                            return "command: string[] expected";
                }
                if (message.hosts != null && message.hasOwnProperty("hosts")) {
                    if (!Array.isArray(message.hosts))
                        return "hosts: array expected";
                    for (var i = 0; i < message.hosts.length; ++i)
                        if (!$util.isString(message.hosts[i]))
                            return "hosts: string[] expected";
                }
                if (message.ports != null && message.hasOwnProperty("ports")) {
                    if (!Array.isArray(message.ports))
                        return "ports: array expected";
                    for (var i = 0; i < message.ports.length; ++i)
                        if (!$util.isInteger(message.ports[i]))
                            return "ports: integer[] expected";
                }
                if (message.containers != null && message.hasOwnProperty("containers")) {
                    if (!Array.isArray(message.containers))
                        return "containers: array expected";
                    for (var i = 0; i < message.containers.length; ++i) {
                        var error = $root.metamoto.types.SystemUnderTest.Container.verify(message.containers[i]);
                        if (error)
                            return "containers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SystemUnderTest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.SystemUnderTest} SystemUnderTest
             */
            SystemUnderTest.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.SystemUnderTest)
                    return object;
                var message = new $root.metamoto.types.SystemUnderTest();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.image != null)
                    message.image = String(object.image);
                if (object.command) {
                    if (!Array.isArray(object.command))
                        throw TypeError(".metamoto.types.SystemUnderTest.command: array expected");
                    message.command = [];
                    for (var i = 0; i < object.command.length; ++i)
                        message.command[i] = String(object.command[i]);
                }
                if (object.hosts) {
                    if (!Array.isArray(object.hosts))
                        throw TypeError(".metamoto.types.SystemUnderTest.hosts: array expected");
                    message.hosts = [];
                    for (var i = 0; i < object.hosts.length; ++i)
                        message.hosts[i] = String(object.hosts[i]);
                }
                if (object.ports) {
                    if (!Array.isArray(object.ports))
                        throw TypeError(".metamoto.types.SystemUnderTest.ports: array expected");
                    message.ports = [];
                    for (var i = 0; i < object.ports.length; ++i)
                        message.ports[i] = object.ports[i] | 0;
                }
                if (object.containers) {
                    if (!Array.isArray(object.containers))
                        throw TypeError(".metamoto.types.SystemUnderTest.containers: array expected");
                    message.containers = [];
                    for (var i = 0; i < object.containers.length; ++i) {
                        if (typeof object.containers[i] !== "object")
                            throw TypeError(".metamoto.types.SystemUnderTest.containers: object expected");
                        message.containers[i] = $root.metamoto.types.SystemUnderTest.Container.fromObject(object.containers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SystemUnderTest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.SystemUnderTest
             * @static
             * @param {metamoto.types.SystemUnderTest} message SystemUnderTest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SystemUnderTest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.command = [];
                    object.hosts = [];
                    object.ports = [];
                    object.containers = [];
                }
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                    object.image = "";
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                if (message.command && message.command.length) {
                    object.command = [];
                    for (var j = 0; j < message.command.length; ++j)
                        object.command[j] = message.command[j];
                }
                if (message.hosts && message.hosts.length) {
                    object.hosts = [];
                    for (var j = 0; j < message.hosts.length; ++j)
                        object.hosts[j] = message.hosts[j];
                }
                if (message.ports && message.ports.length) {
                    object.ports = [];
                    for (var j = 0; j < message.ports.length; ++j)
                        object.ports[j] = message.ports[j];
                }
                if (message.containers && message.containers.length) {
                    object.containers = [];
                    for (var j = 0; j < message.containers.length; ++j)
                        object.containers[j] = $root.metamoto.types.SystemUnderTest.Container.toObject(message.containers[j], options);
                }
                return object;
            };

            /**
             * Converts this SystemUnderTest to JSON.
             * @function toJSON
             * @memberof metamoto.types.SystemUnderTest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SystemUnderTest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SystemUnderTest.Container = (function() {

                /**
                 * Properties of a Container.
                 * @memberof metamoto.types.SystemUnderTest
                 * @interface IContainer
                 * @property {string|null} [image] Container image
                 * @property {Array.<string>|null} [command] Container command
                 */

                /**
                 * Constructs a new Container.
                 * @memberof metamoto.types.SystemUnderTest
                 * @classdesc Represents a Container.
                 * @implements IContainer
                 * @constructor
                 * @param {metamoto.types.SystemUnderTest.IContainer=} [properties] Properties to set
                 */
                function Container(properties) {
                    this.command = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Container image.
                 * @member {string} image
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @instance
                 */
                Container.prototype.image = "";

                /**
                 * Container command.
                 * @member {Array.<string>} command
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @instance
                 */
                Container.prototype.command = $util.emptyArray;

                /**
                 * Creates a new Container instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {metamoto.types.SystemUnderTest.IContainer=} [properties] Properties to set
                 * @returns {metamoto.types.SystemUnderTest.Container} Container instance
                 */
                Container.create = function create(properties) {
                    return new Container(properties);
                };

                /**
                 * Encodes the specified Container message. Does not implicitly {@link metamoto.types.SystemUnderTest.Container.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {metamoto.types.SystemUnderTest.IContainer} message Container message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Container.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.image != null && message.hasOwnProperty("image"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.image);
                    if (message.command != null && message.command.length)
                        for (var i = 0; i < message.command.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.command[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Container message, length delimited. Does not implicitly {@link metamoto.types.SystemUnderTest.Container.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {metamoto.types.SystemUnderTest.IContainer} message Container message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Container.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Container message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.SystemUnderTest.Container} Container
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Container.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SystemUnderTest.Container();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.image = reader.string();
                            break;
                        case 2:
                            if (!(message.command && message.command.length))
                                message.command = [];
                            message.command.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Container message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.SystemUnderTest.Container} Container
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Container.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Container message.
                 * @function verify
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Container.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.image != null && message.hasOwnProperty("image"))
                        if (!$util.isString(message.image))
                            return "image: string expected";
                    if (message.command != null && message.hasOwnProperty("command")) {
                        if (!Array.isArray(message.command))
                            return "command: array expected";
                        for (var i = 0; i < message.command.length; ++i)
                            if (!$util.isString(message.command[i]))
                                return "command: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Container message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.SystemUnderTest.Container} Container
                 */
                Container.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.SystemUnderTest.Container)
                        return object;
                    var message = new $root.metamoto.types.SystemUnderTest.Container();
                    if (object.image != null)
                        message.image = String(object.image);
                    if (object.command) {
                        if (!Array.isArray(object.command))
                            throw TypeError(".metamoto.types.SystemUnderTest.Container.command: array expected");
                        message.command = [];
                        for (var i = 0; i < object.command.length; ++i)
                            message.command[i] = String(object.command[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Container message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @static
                 * @param {metamoto.types.SystemUnderTest.Container} message Container
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Container.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.command = [];
                    if (options.defaults)
                        object.image = "";
                    if (message.image != null && message.hasOwnProperty("image"))
                        object.image = message.image;
                    if (message.command && message.command.length) {
                        object.command = [];
                        for (var j = 0; j < message.command.length; ++j)
                            object.command[j] = message.command[j];
                    }
                    return object;
                };

                /**
                 * Converts this Container to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.SystemUnderTest.Container
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Container.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Container;
            })();

            return SystemUnderTest;
        })();

        types.Controller = (function() {

            /**
             * Properties of a Controller.
             * @memberof metamoto.types
             * @interface IController
             * @property {string|null} [id] Controller id
             * @property {string|null} [displayName] Controller displayName
             * @property {string|null} [internalName] Controller internalName
             * @property {boolean|null} [readOnly] Controller readOnly
             * @property {metamoto.types.IVersion|null} [version] Controller version
             * @property {boolean|null} [disabled] Controller disabled
             * @property {metamoto.types.ISystemUnderTest|null} [sut] Controller sut
             * @property {Array.<string>|null} [publishTopics] Controller publishTopics
             * @property {metamoto.types.INormalDistribution|null} [dataLatency] Controller dataLatency
             * @property {google.protobuf.IStruct|null} [parameters] Controller parameters
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] Controller ranges
             */

            /**
             * Constructs a new Controller.
             * @memberof metamoto.types
             * @classdesc Represents a Controller.
             * @implements IController
             * @constructor
             * @param {metamoto.types.IController=} [properties] Properties to set
             */
            function Controller(properties) {
                this.publishTopics = [];
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Controller id.
             * @member {string} id
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.id = "";

            /**
             * Controller displayName.
             * @member {string} displayName
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.displayName = "";

            /**
             * Controller internalName.
             * @member {string} internalName
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.internalName = "";

            /**
             * Controller readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.readOnly = false;

            /**
             * Controller version.
             * @member {metamoto.types.IVersion|null|undefined} version
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.version = null;

            /**
             * Controller disabled.
             * @member {boolean} disabled
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.disabled = false;

            /**
             * Controller sut.
             * @member {metamoto.types.ISystemUnderTest|null|undefined} sut
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.sut = null;

            /**
             * Controller publishTopics.
             * @member {Array.<string>} publishTopics
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.publishTopics = $util.emptyArray;

            /**
             * Controller dataLatency.
             * @member {metamoto.types.INormalDistribution|null|undefined} dataLatency
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.dataLatency = null;

            /**
             * Controller parameters.
             * @member {google.protobuf.IStruct|null|undefined} parameters
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.parameters = null;

            /**
             * Controller ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.Controller
             * @instance
             */
            Controller.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new Controller instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Controller
             * @static
             * @param {metamoto.types.IController=} [properties] Properties to set
             * @returns {metamoto.types.Controller} Controller instance
             */
            Controller.create = function create(properties) {
                return new Controller(properties);
            };

            /**
             * Encodes the specified Controller message. Does not implicitly {@link metamoto.types.Controller.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Controller
             * @static
             * @param {metamoto.types.IController} message Controller message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Controller.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.internalName);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.readOnly);
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.metamoto.types.Version.encode(message.version, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
                if (message.sut != null && message.hasOwnProperty("sut"))
                    $root.metamoto.types.SystemUnderTest.encode(message.sut, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.publishTopics != null && message.publishTopics.length)
                    for (var i = 0; i < message.publishTopics.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.publishTopics[i]);
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency"))
                    $root.metamoto.types.NormalDistribution.encode(message.dataLatency, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    $root.google.protobuf.Struct.encode(message.parameters, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Controller message, length delimited. Does not implicitly {@link metamoto.types.Controller.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Controller
             * @static
             * @param {metamoto.types.IController} message Controller message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Controller.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Controller message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Controller
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Controller} Controller
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Controller.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Controller(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 3:
                        message.internalName = reader.string();
                        break;
                    case 4:
                        message.readOnly = reader.bool();
                        break;
                    case 5:
                        message.version = $root.metamoto.types.Version.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.disabled = reader.bool();
                        break;
                    case 7:
                        message.sut = $root.metamoto.types.SystemUnderTest.decode(reader, reader.uint32());
                        break;
                    case 8:
                        if (!(message.publishTopics && message.publishTopics.length))
                            message.publishTopics = [];
                        message.publishTopics.push(reader.string());
                        break;
                    case 9:
                        message.dataLatency = $root.metamoto.types.NormalDistribution.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.parameters = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Controller message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Controller
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Controller} Controller
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Controller.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Controller message.
             * @function verify
             * @memberof metamoto.types.Controller
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Controller.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    if (!$util.isString(message.internalName))
                        return "internalName: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.metamoto.types.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.sut != null && message.hasOwnProperty("sut")) {
                    var error = $root.metamoto.types.SystemUnderTest.verify(message.sut);
                    if (error)
                        return "sut." + error;
                }
                if (message.publishTopics != null && message.hasOwnProperty("publishTopics")) {
                    if (!Array.isArray(message.publishTopics))
                        return "publishTopics: array expected";
                    for (var i = 0; i < message.publishTopics.length; ++i)
                        if (!$util.isString(message.publishTopics[i]))
                            return "publishTopics: string[] expected";
                }
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency")) {
                    var error = $root.metamoto.types.NormalDistribution.verify(message.dataLatency);
                    if (error)
                        return "dataLatency." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    var error = $root.google.protobuf.Struct.verify(message.parameters);
                    if (error)
                        return "parameters." + error;
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Controller message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Controller
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Controller} Controller
             */
            Controller.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Controller)
                    return object;
                var message = new $root.metamoto.types.Controller();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.internalName != null)
                    message.internalName = String(object.internalName);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".metamoto.types.Controller.version: object expected");
                    message.version = $root.metamoto.types.Version.fromObject(object.version);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.sut != null) {
                    if (typeof object.sut !== "object")
                        throw TypeError(".metamoto.types.Controller.sut: object expected");
                    message.sut = $root.metamoto.types.SystemUnderTest.fromObject(object.sut);
                }
                if (object.publishTopics) {
                    if (!Array.isArray(object.publishTopics))
                        throw TypeError(".metamoto.types.Controller.publishTopics: array expected");
                    message.publishTopics = [];
                    for (var i = 0; i < object.publishTopics.length; ++i)
                        message.publishTopics[i] = String(object.publishTopics[i]);
                }
                if (object.dataLatency != null) {
                    if (typeof object.dataLatency !== "object")
                        throw TypeError(".metamoto.types.Controller.dataLatency: object expected");
                    message.dataLatency = $root.metamoto.types.NormalDistribution.fromObject(object.dataLatency);
                }
                if (object.parameters != null) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".metamoto.types.Controller.parameters: object expected");
                    message.parameters = $root.google.protobuf.Struct.fromObject(object.parameters);
                }
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.Controller.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.Controller.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Controller message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Controller
             * @static
             * @param {metamoto.types.Controller} message Controller
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Controller.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.publishTopics = [];
                if (options.objects || options.defaults)
                    object.ranges = {};
                if (options.defaults) {
                    object.id = "";
                    object.displayName = "";
                    object.internalName = "";
                    object.readOnly = false;
                    object.version = null;
                    object.disabled = false;
                    object.sut = null;
                    object.dataLatency = null;
                    object.parameters = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    object.internalName = message.internalName;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.metamoto.types.Version.toObject(message.version, options);
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.sut != null && message.hasOwnProperty("sut"))
                    object.sut = $root.metamoto.types.SystemUnderTest.toObject(message.sut, options);
                if (message.publishTopics && message.publishTopics.length) {
                    object.publishTopics = [];
                    for (var j = 0; j < message.publishTopics.length; ++j)
                        object.publishTopics[j] = message.publishTopics[j];
                }
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency"))
                    object.dataLatency = $root.metamoto.types.NormalDistribution.toObject(message.dataLatency, options);
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    object.parameters = $root.google.protobuf.Struct.toObject(message.parameters, options);
                var keys2;
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Controller to JSON.
             * @function toJSON
             * @memberof metamoto.types.Controller
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Controller.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Controller;
        })();

        types.Sensor = (function() {

            /**
             * Properties of a Sensor.
             * @memberof metamoto.types
             * @interface ISensor
             * @property {string|null} [id] Sensor id
             * @property {string|null} [displayName] Sensor displayName
             * @property {string|null} [internalName] Sensor internalName
             * @property {string|null} [prefabName] Sensor prefabName
             * @property {boolean|null} [readOnly] Sensor readOnly
             * @property {metamoto.types.IVersion|null} [version] Sensor version
             * @property {boolean|null} [disabled] Sensor disabled
             * @property {metamoto.types.IPose|null} [pose] Sensor pose
             * @property {string|null} [sensorMountId] Sensor sensorMountId
             * @property {string|null} [mountPointId] Sensor mountPointId
             * @property {metamoto.types.ISystemUnderTest|null} [sut] Sensor sut
             * @property {Array.<string>|null} [publishTopics] Sensor publishTopics
             * @property {metamoto.types.INormalDistribution|null} [dataLatency] Sensor dataLatency
             * @property {google.protobuf.IStruct|null} [parameters] Sensor parameters
             * @property {number|null} [priority] Sensor priority
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] Sensor ranges
             */

            /**
             * Constructs a new Sensor.
             * @memberof metamoto.types
             * @classdesc Represents a Sensor.
             * @implements ISensor
             * @constructor
             * @param {metamoto.types.ISensor=} [properties] Properties to set
             */
            function Sensor(properties) {
                this.publishTopics = [];
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sensor id.
             * @member {string} id
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.id = "";

            /**
             * Sensor displayName.
             * @member {string} displayName
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.displayName = "";

            /**
             * Sensor internalName.
             * @member {string} internalName
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.internalName = "";

            /**
             * Sensor prefabName.
             * @member {string} prefabName
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.prefabName = "";

            /**
             * Sensor readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.readOnly = false;

            /**
             * Sensor version.
             * @member {metamoto.types.IVersion|null|undefined} version
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.version = null;

            /**
             * Sensor disabled.
             * @member {boolean} disabled
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.disabled = false;

            /**
             * Sensor pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.pose = null;

            /**
             * Sensor sensorMountId.
             * @member {string} sensorMountId
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.sensorMountId = "";

            /**
             * Sensor mountPointId.
             * @member {string} mountPointId
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.mountPointId = "";

            /**
             * Sensor sut.
             * @member {metamoto.types.ISystemUnderTest|null|undefined} sut
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.sut = null;

            /**
             * Sensor publishTopics.
             * @member {Array.<string>} publishTopics
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.publishTopics = $util.emptyArray;

            /**
             * Sensor dataLatency.
             * @member {metamoto.types.INormalDistribution|null|undefined} dataLatency
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.dataLatency = null;

            /**
             * Sensor parameters.
             * @member {google.protobuf.IStruct|null|undefined} parameters
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.parameters = null;

            /**
             * Sensor priority.
             * @member {number} priority
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.priority = 0;

            /**
             * Sensor ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.Sensor
             * @instance
             */
            Sensor.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new Sensor instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Sensor
             * @static
             * @param {metamoto.types.ISensor=} [properties] Properties to set
             * @returns {metamoto.types.Sensor} Sensor instance
             */
            Sensor.create = function create(properties) {
                return new Sensor(properties);
            };

            /**
             * Encodes the specified Sensor message. Does not implicitly {@link metamoto.types.Sensor.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Sensor
             * @static
             * @param {metamoto.types.ISensor} message Sensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sensor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.internalName);
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.prefabName);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.readOnly);
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.metamoto.types.Version.encode(message.version, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sensorMountId != null && message.hasOwnProperty("sensorMountId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.sensorMountId);
                if (message.mountPointId != null && message.hasOwnProperty("mountPointId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.mountPointId);
                if (message.sut != null && message.hasOwnProperty("sut"))
                    $root.metamoto.types.SystemUnderTest.encode(message.sut, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.publishTopics != null && message.publishTopics.length)
                    for (var i = 0; i < message.publishTopics.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.publishTopics[i]);
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency"))
                    $root.metamoto.types.NormalDistribution.encode(message.dataLatency, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    $root.google.protobuf.Struct.encode(message.parameters, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.priority != null && message.hasOwnProperty("priority"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.priority);
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Sensor message, length delimited. Does not implicitly {@link metamoto.types.Sensor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Sensor
             * @static
             * @param {metamoto.types.ISensor} message Sensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sensor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sensor message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Sensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Sensor} Sensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sensor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Sensor(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 3:
                        message.internalName = reader.string();
                        break;
                    case 4:
                        message.prefabName = reader.string();
                        break;
                    case 5:
                        message.readOnly = reader.bool();
                        break;
                    case 6:
                        message.version = $root.metamoto.types.Version.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.disabled = reader.bool();
                        break;
                    case 8:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sensorMountId = reader.string();
                        break;
                    case 10:
                        message.mountPointId = reader.string();
                        break;
                    case 11:
                        message.sut = $root.metamoto.types.SystemUnderTest.decode(reader, reader.uint32());
                        break;
                    case 12:
                        if (!(message.publishTopics && message.publishTopics.length))
                            message.publishTopics = [];
                        message.publishTopics.push(reader.string());
                        break;
                    case 13:
                        message.dataLatency = $root.metamoto.types.NormalDistribution.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.parameters = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.priority = reader.uint32();
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sensor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Sensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Sensor} Sensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sensor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sensor message.
             * @function verify
             * @memberof metamoto.types.Sensor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sensor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    if (!$util.isString(message.internalName))
                        return "internalName: string expected";
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    if (!$util.isString(message.prefabName))
                        return "prefabName: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.metamoto.types.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.sensorMountId != null && message.hasOwnProperty("sensorMountId"))
                    if (!$util.isString(message.sensorMountId))
                        return "sensorMountId: string expected";
                if (message.mountPointId != null && message.hasOwnProperty("mountPointId"))
                    if (!$util.isString(message.mountPointId))
                        return "mountPointId: string expected";
                if (message.sut != null && message.hasOwnProperty("sut")) {
                    var error = $root.metamoto.types.SystemUnderTest.verify(message.sut);
                    if (error)
                        return "sut." + error;
                }
                if (message.publishTopics != null && message.hasOwnProperty("publishTopics")) {
                    if (!Array.isArray(message.publishTopics))
                        return "publishTopics: array expected";
                    for (var i = 0; i < message.publishTopics.length; ++i)
                        if (!$util.isString(message.publishTopics[i]))
                            return "publishTopics: string[] expected";
                }
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency")) {
                    var error = $root.metamoto.types.NormalDistribution.verify(message.dataLatency);
                    if (error)
                        return "dataLatency." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    var error = $root.google.protobuf.Struct.verify(message.parameters);
                    if (error)
                        return "parameters." + error;
                }
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Sensor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Sensor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Sensor} Sensor
             */
            Sensor.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Sensor)
                    return object;
                var message = new $root.metamoto.types.Sensor();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.internalName != null)
                    message.internalName = String(object.internalName);
                if (object.prefabName != null)
                    message.prefabName = String(object.prefabName);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".metamoto.types.Sensor.version: object expected");
                    message.version = $root.metamoto.types.Version.fromObject(object.version);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.Sensor.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.sensorMountId != null)
                    message.sensorMountId = String(object.sensorMountId);
                if (object.mountPointId != null)
                    message.mountPointId = String(object.mountPointId);
                if (object.sut != null) {
                    if (typeof object.sut !== "object")
                        throw TypeError(".metamoto.types.Sensor.sut: object expected");
                    message.sut = $root.metamoto.types.SystemUnderTest.fromObject(object.sut);
                }
                if (object.publishTopics) {
                    if (!Array.isArray(object.publishTopics))
                        throw TypeError(".metamoto.types.Sensor.publishTopics: array expected");
                    message.publishTopics = [];
                    for (var i = 0; i < object.publishTopics.length; ++i)
                        message.publishTopics[i] = String(object.publishTopics[i]);
                }
                if (object.dataLatency != null) {
                    if (typeof object.dataLatency !== "object")
                        throw TypeError(".metamoto.types.Sensor.dataLatency: object expected");
                    message.dataLatency = $root.metamoto.types.NormalDistribution.fromObject(object.dataLatency);
                }
                if (object.parameters != null) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".metamoto.types.Sensor.parameters: object expected");
                    message.parameters = $root.google.protobuf.Struct.fromObject(object.parameters);
                }
                if (object.priority != null)
                    message.priority = object.priority >>> 0;
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.Sensor.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.Sensor.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Sensor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Sensor
             * @static
             * @param {metamoto.types.Sensor} message Sensor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sensor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.publishTopics = [];
                if (options.objects || options.defaults)
                    object.ranges = {};
                if (options.defaults) {
                    object.id = "";
                    object.displayName = "";
                    object.internalName = "";
                    object.prefabName = "";
                    object.readOnly = false;
                    object.version = null;
                    object.disabled = false;
                    object.pose = null;
                    object.sensorMountId = "";
                    object.mountPointId = "";
                    object.sut = null;
                    object.dataLatency = null;
                    object.parameters = null;
                    object.priority = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    object.internalName = message.internalName;
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    object.prefabName = message.prefabName;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.metamoto.types.Version.toObject(message.version, options);
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.sensorMountId != null && message.hasOwnProperty("sensorMountId"))
                    object.sensorMountId = message.sensorMountId;
                if (message.mountPointId != null && message.hasOwnProperty("mountPointId"))
                    object.mountPointId = message.mountPointId;
                if (message.sut != null && message.hasOwnProperty("sut"))
                    object.sut = $root.metamoto.types.SystemUnderTest.toObject(message.sut, options);
                if (message.publishTopics && message.publishTopics.length) {
                    object.publishTopics = [];
                    for (var j = 0; j < message.publishTopics.length; ++j)
                        object.publishTopics[j] = message.publishTopics[j];
                }
                if (message.dataLatency != null && message.hasOwnProperty("dataLatency"))
                    object.dataLatency = $root.metamoto.types.NormalDistribution.toObject(message.dataLatency, options);
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    object.parameters = $root.google.protobuf.Struct.toObject(message.parameters, options);
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                var keys2;
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Sensor to JSON.
             * @function toJSON
             * @memberof metamoto.types.Sensor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sensor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sensor;
        })();

        types.SensorMount = (function() {

            /**
             * Properties of a SensorMount.
             * @memberof metamoto.types
             * @interface ISensorMount
             * @property {string|null} [id] SensorMount id
             * @property {string|null} [displayName] SensorMount displayName
             * @property {string|null} [prefabName] SensorMount prefabName
             * @property {boolean|null} [readOnly] SensorMount readOnly
             * @property {Array.<metamoto.types.SensorMount.IMountPoint>|null} [mountPoints] SensorMount mountPoints
             * @property {metamoto.types.IPose|null} [pose] SensorMount pose
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] SensorMount ranges
             */

            /**
             * Constructs a new SensorMount.
             * @memberof metamoto.types
             * @classdesc Represents a SensorMount.
             * @implements ISensorMount
             * @constructor
             * @param {metamoto.types.ISensorMount=} [properties] Properties to set
             */
            function SensorMount(properties) {
                this.mountPoints = [];
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SensorMount id.
             * @member {string} id
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.id = "";

            /**
             * SensorMount displayName.
             * @member {string} displayName
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.displayName = "";

            /**
             * SensorMount prefabName.
             * @member {string} prefabName
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.prefabName = "";

            /**
             * SensorMount readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.readOnly = false;

            /**
             * SensorMount mountPoints.
             * @member {Array.<metamoto.types.SensorMount.IMountPoint>} mountPoints
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.mountPoints = $util.emptyArray;

            /**
             * SensorMount pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.pose = null;

            /**
             * SensorMount ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.SensorMount
             * @instance
             */
            SensorMount.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new SensorMount instance using the specified properties.
             * @function create
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {metamoto.types.ISensorMount=} [properties] Properties to set
             * @returns {metamoto.types.SensorMount} SensorMount instance
             */
            SensorMount.create = function create(properties) {
                return new SensorMount(properties);
            };

            /**
             * Encodes the specified SensorMount message. Does not implicitly {@link metamoto.types.SensorMount.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {metamoto.types.ISensorMount} message SensorMount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SensorMount.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.prefabName);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.readOnly);
                if (message.mountPoints != null && message.mountPoints.length)
                    for (var i = 0; i < message.mountPoints.length; ++i)
                        $root.metamoto.types.SensorMount.MountPoint.encode(message.mountPoints[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified SensorMount message, length delimited. Does not implicitly {@link metamoto.types.SensorMount.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {metamoto.types.ISensorMount} message SensorMount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SensorMount.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SensorMount message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.SensorMount} SensorMount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SensorMount.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SensorMount(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 3:
                        message.prefabName = reader.string();
                        break;
                    case 4:
                        message.readOnly = reader.bool();
                        break;
                    case 5:
                        if (!(message.mountPoints && message.mountPoints.length))
                            message.mountPoints = [];
                        message.mountPoints.push($root.metamoto.types.SensorMount.MountPoint.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SensorMount message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.SensorMount} SensorMount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SensorMount.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SensorMount message.
             * @function verify
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SensorMount.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    if (!$util.isString(message.prefabName))
                        return "prefabName: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.mountPoints != null && message.hasOwnProperty("mountPoints")) {
                    if (!Array.isArray(message.mountPoints))
                        return "mountPoints: array expected";
                    for (var i = 0; i < message.mountPoints.length; ++i) {
                        var error = $root.metamoto.types.SensorMount.MountPoint.verify(message.mountPoints[i]);
                        if (error)
                            return "mountPoints." + error;
                    }
                }
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SensorMount message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.SensorMount} SensorMount
             */
            SensorMount.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.SensorMount)
                    return object;
                var message = new $root.metamoto.types.SensorMount();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.prefabName != null)
                    message.prefabName = String(object.prefabName);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.mountPoints) {
                    if (!Array.isArray(object.mountPoints))
                        throw TypeError(".metamoto.types.SensorMount.mountPoints: array expected");
                    message.mountPoints = [];
                    for (var i = 0; i < object.mountPoints.length; ++i) {
                        if (typeof object.mountPoints[i] !== "object")
                            throw TypeError(".metamoto.types.SensorMount.mountPoints: object expected");
                        message.mountPoints[i] = $root.metamoto.types.SensorMount.MountPoint.fromObject(object.mountPoints[i]);
                    }
                }
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.SensorMount.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.SensorMount.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.SensorMount.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SensorMount message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.SensorMount
             * @static
             * @param {metamoto.types.SensorMount} message SensorMount
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SensorMount.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.mountPoints = [];
                if (options.objects || options.defaults)
                    object.ranges = {};
                if (options.defaults) {
                    object.id = "";
                    object.displayName = "";
                    object.prefabName = "";
                    object.readOnly = false;
                    object.pose = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.prefabName != null && message.hasOwnProperty("prefabName"))
                    object.prefabName = message.prefabName;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.mountPoints && message.mountPoints.length) {
                    object.mountPoints = [];
                    for (var j = 0; j < message.mountPoints.length; ++j)
                        object.mountPoints[j] = $root.metamoto.types.SensorMount.MountPoint.toObject(message.mountPoints[j], options);
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                var keys2;
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this SensorMount to JSON.
             * @function toJSON
             * @memberof metamoto.types.SensorMount
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SensorMount.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SensorMount.MountPoint = (function() {

                /**
                 * Properties of a MountPoint.
                 * @memberof metamoto.types.SensorMount
                 * @interface IMountPoint
                 * @property {string|null} [id] MountPoint id
                 * @property {metamoto.types.SensorMount.MountPoint.Type|null} [type] MountPoint type
                 * @property {metamoto.types.IPose|null} [pose] MountPoint pose
                 */

                /**
                 * Constructs a new MountPoint.
                 * @memberof metamoto.types.SensorMount
                 * @classdesc Represents a MountPoint.
                 * @implements IMountPoint
                 * @constructor
                 * @param {metamoto.types.SensorMount.IMountPoint=} [properties] Properties to set
                 */
                function MountPoint(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MountPoint id.
                 * @member {string} id
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @instance
                 */
                MountPoint.prototype.id = "";

                /**
                 * MountPoint type.
                 * @member {metamoto.types.SensorMount.MountPoint.Type} type
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @instance
                 */
                MountPoint.prototype.type = 0;

                /**
                 * MountPoint pose.
                 * @member {metamoto.types.IPose|null|undefined} pose
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @instance
                 */
                MountPoint.prototype.pose = null;

                /**
                 * Creates a new MountPoint instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {metamoto.types.SensorMount.IMountPoint=} [properties] Properties to set
                 * @returns {metamoto.types.SensorMount.MountPoint} MountPoint instance
                 */
                MountPoint.create = function create(properties) {
                    return new MountPoint(properties);
                };

                /**
                 * Encodes the specified MountPoint message. Does not implicitly {@link metamoto.types.SensorMount.MountPoint.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {metamoto.types.SensorMount.IMountPoint} message MountPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MountPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.pose != null && message.hasOwnProperty("pose"))
                        $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MountPoint message, length delimited. Does not implicitly {@link metamoto.types.SensorMount.MountPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {metamoto.types.SensorMount.IMountPoint} message MountPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MountPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MountPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.SensorMount.MountPoint} MountPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MountPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SensorMount.MountPoint();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MountPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.SensorMount.MountPoint} MountPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MountPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MountPoint message.
                 * @function verify
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MountPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.pose != null && message.hasOwnProperty("pose")) {
                        var error = $root.metamoto.types.Pose.verify(message.pose);
                        if (error)
                            return "pose." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MountPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.SensorMount.MountPoint} MountPoint
                 */
                MountPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.SensorMount.MountPoint)
                        return object;
                    var message = new $root.metamoto.types.SensorMount.MountPoint();
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.type) {
                    case "UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "OTHER":
                    case 1:
                        message.type = 1;
                        break;
                    case "CAMERA":
                    case 2:
                        message.type = 2;
                        break;
                    case "LIDAR":
                    case 3:
                        message.type = 3;
                        break;
                    case "RADAR":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.pose != null) {
                        if (typeof object.pose !== "object")
                            throw TypeError(".metamoto.types.SensorMount.MountPoint.pose: object expected");
                        message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MountPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @static
                 * @param {metamoto.types.SensorMount.MountPoint} message MountPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MountPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.type = options.enums === String ? "UNKNOWN" : 0;
                        object.pose = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.metamoto.types.SensorMount.MountPoint.Type[message.type] : message.type;
                    if (message.pose != null && message.hasOwnProperty("pose"))
                        object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                    return object;
                };

                /**
                 * Converts this MountPoint to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.SensorMount.MountPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MountPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name metamoto.types.SensorMount.MountPoint.Type
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} OTHER=1 OTHER value
                 * @property {number} CAMERA=2 CAMERA value
                 * @property {number} LIDAR=3 LIDAR value
                 * @property {number} RADAR=4 RADAR value
                 */
                MountPoint.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "OTHER"] = 1;
                    values[valuesById[2] = "CAMERA"] = 2;
                    values[valuesById[3] = "LIDAR"] = 3;
                    values[valuesById[4] = "RADAR"] = 4;
                    return values;
                })();

                return MountPoint;
            })();

            return SensorMount;
        })();

        types.VehicleDynamics = (function() {

            /**
             * Properties of a VehicleDynamics.
             * @memberof metamoto.types
             * @interface IVehicleDynamics
             * @property {string|null} [id] VehicleDynamics id
             * @property {string|null} [displayName] VehicleDynamics displayName
             * @property {string|null} [internalName] VehicleDynamics internalName
             * @property {boolean|null} [readOnly] VehicleDynamics readOnly
             * @property {string|null} [version] VehicleDynamics version
             * @property {boolean|null} [disabled] VehicleDynamics disabled
             * @property {metamoto.types.ISystemUnderTest|null} [sut] VehicleDynamics sut
             * @property {google.protobuf.IStruct|null} [parameters] VehicleDynamics parameters
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] VehicleDynamics ranges
             */

            /**
             * Constructs a new VehicleDynamics.
             * @memberof metamoto.types
             * @classdesc Represents a VehicleDynamics.
             * @implements IVehicleDynamics
             * @constructor
             * @param {metamoto.types.IVehicleDynamics=} [properties] Properties to set
             */
            function VehicleDynamics(properties) {
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleDynamics id.
             * @member {string} id
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.id = "";

            /**
             * VehicleDynamics displayName.
             * @member {string} displayName
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.displayName = "";

            /**
             * VehicleDynamics internalName.
             * @member {string} internalName
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.internalName = "";

            /**
             * VehicleDynamics readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.readOnly = false;

            /**
             * VehicleDynamics version.
             * @member {string} version
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.version = "";

            /**
             * VehicleDynamics disabled.
             * @member {boolean} disabled
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.disabled = false;

            /**
             * VehicleDynamics sut.
             * @member {metamoto.types.ISystemUnderTest|null|undefined} sut
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.sut = null;

            /**
             * VehicleDynamics parameters.
             * @member {google.protobuf.IStruct|null|undefined} parameters
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.parameters = null;

            /**
             * VehicleDynamics ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             */
            VehicleDynamics.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new VehicleDynamics instance using the specified properties.
             * @function create
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {metamoto.types.IVehicleDynamics=} [properties] Properties to set
             * @returns {metamoto.types.VehicleDynamics} VehicleDynamics instance
             */
            VehicleDynamics.create = function create(properties) {
                return new VehicleDynamics(properties);
            };

            /**
             * Encodes the specified VehicleDynamics message. Does not implicitly {@link metamoto.types.VehicleDynamics.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {metamoto.types.IVehicleDynamics} message VehicleDynamics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleDynamics.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.internalName);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.readOnly);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
                if (message.sut != null && message.hasOwnProperty("sut"))
                    $root.metamoto.types.SystemUnderTest.encode(message.sut, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    $root.google.protobuf.Struct.encode(message.parameters, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified VehicleDynamics message, length delimited. Does not implicitly {@link metamoto.types.VehicleDynamics.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {metamoto.types.IVehicleDynamics} message VehicleDynamics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleDynamics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleDynamics message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.VehicleDynamics} VehicleDynamics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleDynamics.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VehicleDynamics(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 3:
                        message.internalName = reader.string();
                        break;
                    case 4:
                        message.readOnly = reader.bool();
                        break;
                    case 5:
                        message.version = reader.string();
                        break;
                    case 6:
                        message.disabled = reader.bool();
                        break;
                    case 7:
                        message.sut = $root.metamoto.types.SystemUnderTest.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.parameters = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleDynamics message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.VehicleDynamics} VehicleDynamics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleDynamics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleDynamics message.
             * @function verify
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleDynamics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    if (!$util.isString(message.internalName))
                        return "internalName: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.sut != null && message.hasOwnProperty("sut")) {
                    var error = $root.metamoto.types.SystemUnderTest.verify(message.sut);
                    if (error)
                        return "sut." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    var error = $root.google.protobuf.Struct.verify(message.parameters);
                    if (error)
                        return "parameters." + error;
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VehicleDynamics message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.VehicleDynamics} VehicleDynamics
             */
            VehicleDynamics.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.VehicleDynamics)
                    return object;
                var message = new $root.metamoto.types.VehicleDynamics();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.internalName != null)
                    message.internalName = String(object.internalName);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.sut != null) {
                    if (typeof object.sut !== "object")
                        throw TypeError(".metamoto.types.VehicleDynamics.sut: object expected");
                    message.sut = $root.metamoto.types.SystemUnderTest.fromObject(object.sut);
                }
                if (object.parameters != null) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".metamoto.types.VehicleDynamics.parameters: object expected");
                    message.parameters = $root.google.protobuf.Struct.fromObject(object.parameters);
                }
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.VehicleDynamics.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.VehicleDynamics.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleDynamics message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.VehicleDynamics
             * @static
             * @param {metamoto.types.VehicleDynamics} message VehicleDynamics
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleDynamics.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.ranges = {};
                if (options.defaults) {
                    object.id = "";
                    object.displayName = "";
                    object.internalName = "";
                    object.readOnly = false;
                    object.version = "";
                    object.disabled = false;
                    object.sut = null;
                    object.parameters = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.internalName != null && message.hasOwnProperty("internalName"))
                    object.internalName = message.internalName;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.sut != null && message.hasOwnProperty("sut"))
                    object.sut = $root.metamoto.types.SystemUnderTest.toObject(message.sut, options);
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    object.parameters = $root.google.protobuf.Struct.toObject(message.parameters, options);
                var keys2;
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this VehicleDynamics to JSON.
             * @function toJSON
             * @memberof metamoto.types.VehicleDynamics
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleDynamics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VehicleDynamics;
        })();

        types.EgoVehicle = (function() {

            /**
             * Properties of an EgoVehicle.
             * @memberof metamoto.types
             * @interface IEgoVehicle
             * @property {string|null} [id] EgoVehicle id
             * @property {string|null} [displayName] EgoVehicle displayName
             * @property {string|null} [modelName] EgoVehicle modelName
             * @property {boolean|null} [readOnly] EgoVehicle readOnly
             * @property {metamoto.types.IVersion|null} [version] EgoVehicle version
             * @property {metamoto.types.VehicleInstance.IBody|null} [body] EgoVehicle body
             * @property {Array.<metamoto.types.IController>|null} [controllers] EgoVehicle controllers
             * @property {Array.<metamoto.types.ISensor>|null} [sensors] EgoVehicle sensors
             * @property {Array.<metamoto.types.ISensorMount>|null} [sensorMounts] EgoVehicle sensorMounts
             * @property {metamoto.types.IVehicleDynamics|null} [vehicleDynamics] EgoVehicle vehicleDynamics
             * @property {Array.<metamoto.types.IAsset>|null} [assets] EgoVehicle assets
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] EgoVehicle ranges
             */

            /**
             * Constructs a new EgoVehicle.
             * @memberof metamoto.types
             * @classdesc Represents an EgoVehicle.
             * @implements IEgoVehicle
             * @constructor
             * @param {metamoto.types.IEgoVehicle=} [properties] Properties to set
             */
            function EgoVehicle(properties) {
                this.controllers = [];
                this.sensors = [];
                this.sensorMounts = [];
                this.assets = [];
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EgoVehicle id.
             * @member {string} id
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.id = "";

            /**
             * EgoVehicle displayName.
             * @member {string} displayName
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.displayName = "";

            /**
             * EgoVehicle modelName.
             * @member {string} modelName
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.modelName = "";

            /**
             * EgoVehicle readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.readOnly = false;

            /**
             * EgoVehicle version.
             * @member {metamoto.types.IVersion|null|undefined} version
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.version = null;

            /**
             * EgoVehicle body.
             * @member {metamoto.types.VehicleInstance.IBody|null|undefined} body
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.body = null;

            /**
             * EgoVehicle controllers.
             * @member {Array.<metamoto.types.IController>} controllers
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.controllers = $util.emptyArray;

            /**
             * EgoVehicle sensors.
             * @member {Array.<metamoto.types.ISensor>} sensors
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.sensors = $util.emptyArray;

            /**
             * EgoVehicle sensorMounts.
             * @member {Array.<metamoto.types.ISensorMount>} sensorMounts
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.sensorMounts = $util.emptyArray;

            /**
             * EgoVehicle vehicleDynamics.
             * @member {metamoto.types.IVehicleDynamics|null|undefined} vehicleDynamics
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.vehicleDynamics = null;

            /**
             * EgoVehicle assets.
             * @member {Array.<metamoto.types.IAsset>} assets
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.assets = $util.emptyArray;

            /**
             * EgoVehicle ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.EgoVehicle
             * @instance
             */
            EgoVehicle.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new EgoVehicle instance using the specified properties.
             * @function create
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {metamoto.types.IEgoVehicle=} [properties] Properties to set
             * @returns {metamoto.types.EgoVehicle} EgoVehicle instance
             */
            EgoVehicle.create = function create(properties) {
                return new EgoVehicle(properties);
            };

            /**
             * Encodes the specified EgoVehicle message. Does not implicitly {@link metamoto.types.EgoVehicle.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {metamoto.types.IEgoVehicle} message EgoVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EgoVehicle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.modelName != null && message.hasOwnProperty("modelName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modelName);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.readOnly);
                if (message.body != null && message.hasOwnProperty("body"))
                    $root.metamoto.types.VehicleInstance.Body.encode(message.body, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.controllers != null && message.controllers.length)
                    for (var i = 0; i < message.controllers.length; ++i)
                        $root.metamoto.types.Controller.encode(message.controllers[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.sensors != null && message.sensors.length)
                    for (var i = 0; i < message.sensors.length; ++i)
                        $root.metamoto.types.Sensor.encode(message.sensors[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.sensorMounts != null && message.sensorMounts.length)
                    for (var i = 0; i < message.sensorMounts.length; ++i)
                        $root.metamoto.types.SensorMount.encode(message.sensorMounts[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.vehicleDynamics != null && message.hasOwnProperty("vehicleDynamics"))
                    $root.metamoto.types.VehicleDynamics.encode(message.vehicleDynamics, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.assets != null && message.assets.length)
                    for (var i = 0; i < message.assets.length; ++i)
                        $root.metamoto.types.Asset.encode(message.assets[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.metamoto.types.Version.encode(message.version, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified EgoVehicle message, length delimited. Does not implicitly {@link metamoto.types.EgoVehicle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {metamoto.types.IEgoVehicle} message EgoVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EgoVehicle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EgoVehicle message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.EgoVehicle} EgoVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EgoVehicle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.EgoVehicle(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 3:
                        message.modelName = reader.string();
                        break;
                    case 4:
                        message.readOnly = reader.bool();
                        break;
                    case 11:
                        message.version = $root.metamoto.types.Version.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.body = $root.metamoto.types.VehicleInstance.Body.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.controllers && message.controllers.length))
                            message.controllers = [];
                        message.controllers.push($root.metamoto.types.Controller.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.sensors && message.sensors.length))
                            message.sensors = [];
                        message.sensors.push($root.metamoto.types.Sensor.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.sensorMounts && message.sensorMounts.length))
                            message.sensorMounts = [];
                        message.sensorMounts.push($root.metamoto.types.SensorMount.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.vehicleDynamics = $root.metamoto.types.VehicleDynamics.decode(reader, reader.uint32());
                        break;
                    case 10:
                        if (!(message.assets && message.assets.length))
                            message.assets = [];
                        message.assets.push($root.metamoto.types.Asset.decode(reader, reader.uint32()));
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EgoVehicle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.EgoVehicle} EgoVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EgoVehicle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EgoVehicle message.
             * @function verify
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EgoVehicle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.modelName != null && message.hasOwnProperty("modelName"))
                    if (!$util.isString(message.modelName))
                        return "modelName: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.metamoto.types.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                    var error = $root.metamoto.types.VehicleInstance.Body.verify(message.body);
                    if (error)
                        return "body." + error;
                }
                if (message.controllers != null && message.hasOwnProperty("controllers")) {
                    if (!Array.isArray(message.controllers))
                        return "controllers: array expected";
                    for (var i = 0; i < message.controllers.length; ++i) {
                        var error = $root.metamoto.types.Controller.verify(message.controllers[i]);
                        if (error)
                            return "controllers." + error;
                    }
                }
                if (message.sensors != null && message.hasOwnProperty("sensors")) {
                    if (!Array.isArray(message.sensors))
                        return "sensors: array expected";
                    for (var i = 0; i < message.sensors.length; ++i) {
                        var error = $root.metamoto.types.Sensor.verify(message.sensors[i]);
                        if (error)
                            return "sensors." + error;
                    }
                }
                if (message.sensorMounts != null && message.hasOwnProperty("sensorMounts")) {
                    if (!Array.isArray(message.sensorMounts))
                        return "sensorMounts: array expected";
                    for (var i = 0; i < message.sensorMounts.length; ++i) {
                        var error = $root.metamoto.types.SensorMount.verify(message.sensorMounts[i]);
                        if (error)
                            return "sensorMounts." + error;
                    }
                }
                if (message.vehicleDynamics != null && message.hasOwnProperty("vehicleDynamics")) {
                    var error = $root.metamoto.types.VehicleDynamics.verify(message.vehicleDynamics);
                    if (error)
                        return "vehicleDynamics." + error;
                }
                if (message.assets != null && message.hasOwnProperty("assets")) {
                    if (!Array.isArray(message.assets))
                        return "assets: array expected";
                    for (var i = 0; i < message.assets.length; ++i) {
                        var error = $root.metamoto.types.Asset.verify(message.assets[i]);
                        if (error)
                            return "assets." + error;
                    }
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EgoVehicle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.EgoVehicle} EgoVehicle
             */
            EgoVehicle.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.EgoVehicle)
                    return object;
                var message = new $root.metamoto.types.EgoVehicle();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.modelName != null)
                    message.modelName = String(object.modelName);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".metamoto.types.EgoVehicle.version: object expected");
                    message.version = $root.metamoto.types.Version.fromObject(object.version);
                }
                if (object.body != null) {
                    if (typeof object.body !== "object")
                        throw TypeError(".metamoto.types.EgoVehicle.body: object expected");
                    message.body = $root.metamoto.types.VehicleInstance.Body.fromObject(object.body);
                }
                if (object.controllers) {
                    if (!Array.isArray(object.controllers))
                        throw TypeError(".metamoto.types.EgoVehicle.controllers: array expected");
                    message.controllers = [];
                    for (var i = 0; i < object.controllers.length; ++i) {
                        if (typeof object.controllers[i] !== "object")
                            throw TypeError(".metamoto.types.EgoVehicle.controllers: object expected");
                        message.controllers[i] = $root.metamoto.types.Controller.fromObject(object.controllers[i]);
                    }
                }
                if (object.sensors) {
                    if (!Array.isArray(object.sensors))
                        throw TypeError(".metamoto.types.EgoVehicle.sensors: array expected");
                    message.sensors = [];
                    for (var i = 0; i < object.sensors.length; ++i) {
                        if (typeof object.sensors[i] !== "object")
                            throw TypeError(".metamoto.types.EgoVehicle.sensors: object expected");
                        message.sensors[i] = $root.metamoto.types.Sensor.fromObject(object.sensors[i]);
                    }
                }
                if (object.sensorMounts) {
                    if (!Array.isArray(object.sensorMounts))
                        throw TypeError(".metamoto.types.EgoVehicle.sensorMounts: array expected");
                    message.sensorMounts = [];
                    for (var i = 0; i < object.sensorMounts.length; ++i) {
                        if (typeof object.sensorMounts[i] !== "object")
                            throw TypeError(".metamoto.types.EgoVehicle.sensorMounts: object expected");
                        message.sensorMounts[i] = $root.metamoto.types.SensorMount.fromObject(object.sensorMounts[i]);
                    }
                }
                if (object.vehicleDynamics != null) {
                    if (typeof object.vehicleDynamics !== "object")
                        throw TypeError(".metamoto.types.EgoVehicle.vehicleDynamics: object expected");
                    message.vehicleDynamics = $root.metamoto.types.VehicleDynamics.fromObject(object.vehicleDynamics);
                }
                if (object.assets) {
                    if (!Array.isArray(object.assets))
                        throw TypeError(".metamoto.types.EgoVehicle.assets: array expected");
                    message.assets = [];
                    for (var i = 0; i < object.assets.length; ++i) {
                        if (typeof object.assets[i] !== "object")
                            throw TypeError(".metamoto.types.EgoVehicle.assets: object expected");
                        message.assets[i] = $root.metamoto.types.Asset.fromObject(object.assets[i]);
                    }
                }
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.EgoVehicle.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.EgoVehicle.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EgoVehicle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.EgoVehicle
             * @static
             * @param {metamoto.types.EgoVehicle} message EgoVehicle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EgoVehicle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.controllers = [];
                    object.sensors = [];
                    object.sensorMounts = [];
                    object.assets = [];
                }
                if (options.objects || options.defaults)
                    object.ranges = {};
                if (options.defaults) {
                    object.id = "";
                    object.displayName = "";
                    object.modelName = "";
                    object.readOnly = false;
                    object.body = null;
                    object.vehicleDynamics = null;
                    object.version = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.modelName != null && message.hasOwnProperty("modelName"))
                    object.modelName = message.modelName;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = $root.metamoto.types.VehicleInstance.Body.toObject(message.body, options);
                if (message.controllers && message.controllers.length) {
                    object.controllers = [];
                    for (var j = 0; j < message.controllers.length; ++j)
                        object.controllers[j] = $root.metamoto.types.Controller.toObject(message.controllers[j], options);
                }
                if (message.sensors && message.sensors.length) {
                    object.sensors = [];
                    for (var j = 0; j < message.sensors.length; ++j)
                        object.sensors[j] = $root.metamoto.types.Sensor.toObject(message.sensors[j], options);
                }
                if (message.sensorMounts && message.sensorMounts.length) {
                    object.sensorMounts = [];
                    for (var j = 0; j < message.sensorMounts.length; ++j)
                        object.sensorMounts[j] = $root.metamoto.types.SensorMount.toObject(message.sensorMounts[j], options);
                }
                if (message.vehicleDynamics != null && message.hasOwnProperty("vehicleDynamics"))
                    object.vehicleDynamics = $root.metamoto.types.VehicleDynamics.toObject(message.vehicleDynamics, options);
                if (message.assets && message.assets.length) {
                    object.assets = [];
                    for (var j = 0; j < message.assets.length; ++j)
                        object.assets[j] = $root.metamoto.types.Asset.toObject(message.assets[j], options);
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.metamoto.types.Version.toObject(message.version, options);
                var keys2;
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this EgoVehicle to JSON.
             * @function toJSON
             * @memberof metamoto.types.EgoVehicle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EgoVehicle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EgoVehicle;
        })();

        /**
         * ObjectType enum.
         * @name metamoto.types.ObjectType
         * @enum {string}
         * @property {number} OBJECT_UNKNOWN=0 OBJECT_UNKNOWN value
         * @property {number} OBJECT_OTHER=1 OBJECT_OTHER value
         * @property {number} OBJECT_CAR=2 OBJECT_CAR value
         * @property {number} OBJECT_TRUCK=3 OBJECT_TRUCK value
         * @property {number} OBJECT_BUS=4 OBJECT_BUS value
         * @property {number} OBJECT_MOTORCYCLE=5 OBJECT_MOTORCYCLE value
         * @property {number} OBJECT_BICYCLE=6 OBJECT_BICYCLE value
         * @property {number} OBJECT_TRAIN=7 OBJECT_TRAIN value
         * @property {number} OBJECT_PEDESTRIAN=8 OBJECT_PEDESTRIAN value
         * @property {number} OBJECT_ANIMAL=9 OBJECT_ANIMAL value
         * @property {number} OBJECT_TRAFFIC_LIGHT=10 OBJECT_TRAFFIC_LIGHT value
         * @property {number} OBJECT_TRAFFIC_SIGN=11 OBJECT_TRAFFIC_SIGN value
         * @property {number} OBJECT_TRAFFIC_BARRIER=12 OBJECT_TRAFFIC_BARRIER value
         * @property {number} OBJECT_TRAFFIC_CONE=13 OBJECT_TRAFFIC_CONE value
         * @property {number} OBJECT_GROUND=14 OBJECT_GROUND value
         * @property {number} OBJECT_ROAD=15 OBJECT_ROAD value
         * @property {number} OBJECT_RAIL_TRACK=16 OBJECT_RAIL_TRACK value
         * @property {number} OBJECT_SIDEWALK=17 OBJECT_SIDEWALK value
         * @property {number} OBJECT_CURB=18 OBJECT_CURB value
         * @property {number} OBJECT_STATIC_OBJECT=19 OBJECT_STATIC_OBJECT value
         * @property {number} OBJECT_SIGN=20 OBJECT_SIGN value
         * @property {number} OBJECT_POLE=21 OBJECT_POLE value
         * @property {number} OBJECT_BUILDING=22 OBJECT_BUILDING value
         * @property {number} OBJECT_WALL=23 OBJECT_WALL value
         * @property {number} OBJECT_FENCE=24 OBJECT_FENCE value
         * @property {number} OBJECT_TREE=25 OBJECT_TREE value
         * @property {number} OBJECT_VEGETATION=26 OBJECT_VEGETATION value
         */
        types.ObjectType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OBJECT_UNKNOWN"] = 0;
            values[valuesById[1] = "OBJECT_OTHER"] = 1;
            values[valuesById[2] = "OBJECT_CAR"] = 2;
            values[valuesById[3] = "OBJECT_TRUCK"] = 3;
            values[valuesById[4] = "OBJECT_BUS"] = 4;
            values[valuesById[5] = "OBJECT_MOTORCYCLE"] = 5;
            values[valuesById[6] = "OBJECT_BICYCLE"] = 6;
            values[valuesById[7] = "OBJECT_TRAIN"] = 7;
            values[valuesById[8] = "OBJECT_PEDESTRIAN"] = 8;
            values[valuesById[9] = "OBJECT_ANIMAL"] = 9;
            values[valuesById[10] = "OBJECT_TRAFFIC_LIGHT"] = 10;
            values[valuesById[11] = "OBJECT_TRAFFIC_SIGN"] = 11;
            values[valuesById[12] = "OBJECT_TRAFFIC_BARRIER"] = 12;
            values[valuesById[13] = "OBJECT_TRAFFIC_CONE"] = 13;
            values[valuesById[14] = "OBJECT_GROUND"] = 14;
            values[valuesById[15] = "OBJECT_ROAD"] = 15;
            values[valuesById[16] = "OBJECT_RAIL_TRACK"] = 16;
            values[valuesById[17] = "OBJECT_SIDEWALK"] = 17;
            values[valuesById[18] = "OBJECT_CURB"] = 18;
            values[valuesById[19] = "OBJECT_STATIC_OBJECT"] = 19;
            values[valuesById[20] = "OBJECT_SIGN"] = 20;
            values[valuesById[21] = "OBJECT_POLE"] = 21;
            values[valuesById[22] = "OBJECT_BUILDING"] = 22;
            values[valuesById[23] = "OBJECT_WALL"] = 23;
            values[valuesById[24] = "OBJECT_FENCE"] = 24;
            values[valuesById[25] = "OBJECT_TREE"] = 25;
            values[valuesById[26] = "OBJECT_VEGETATION"] = 26;
            return values;
        })();

        /**
         * MaterialType enum.
         * @name metamoto.types.MaterialType
         * @enum {string}
         * @property {number} MATERIAL_UNKNOWN=0 MATERIAL_UNKNOWN value
         * @property {number} MATERIAL_OTHER=1 MATERIAL_OTHER value
         * @property {number} MATERIAL_ASPHALT=2 MATERIAL_ASPHALT value
         * @property {number} MATERIAL_GRAVEL=3 MATERIAL_GRAVEL value
         * @property {number} MATERIAL_ROCK=4 MATERIAL_ROCK value
         * @property {number} MATERIAL_SOIL=5 MATERIAL_SOIL value
         * @property {number} MATERIAL_SAND=6 MATERIAL_SAND value
         * @property {number} MATERIAL_GRASS=7 MATERIAL_GRASS value
         * @property {number} MATERIAL_WATER=8 MATERIAL_WATER value
         * @property {number} MATERIAL_SNOW=9 MATERIAL_SNOW value
         * @property {number} MATERIAL_CONCRETE=10 MATERIAL_CONCRETE value
         * @property {number} MATERIAL_STUCCO=11 MATERIAL_STUCCO value
         * @property {number} MATERIAL_STONE=12 MATERIAL_STONE value
         * @property {number} MATERIAL_BRICK=13 MATERIAL_BRICK value
         * @property {number} MATERIAL_WOOD=14 MATERIAL_WOOD value
         * @property {number} MATERIAL_GLASS=15 MATERIAL_GLASS value
         * @property {number} MATERIAL_MIRROR=16 MATERIAL_MIRROR value
         * @property {number} MATERIAL_CERAMIC=17 MATERIAL_CERAMIC value
         * @property {number} MATERIAL_METAL=18 MATERIAL_METAL value
         * @property {number} MATERIAL_CARBON_FIBER=19 MATERIAL_CARBON_FIBER value
         * @property {number} MATERIAL_LEATHER=20 MATERIAL_LEATHER value
         * @property {number} MATERIAL_PLASTIC=21 MATERIAL_PLASTIC value
         * @property {number} MATERIAL_RUBBER=22 MATERIAL_RUBBER value
         * @property {number} MATERIAL_PAPER=23 MATERIAL_PAPER value
         * @property {number} MATERIAL_LEAF=24 MATERIAL_LEAF value
         * @property {number} MATERIAL_SKIN=25 MATERIAL_SKIN value
         * @property {number} MATERIAL_FABRIC=26 MATERIAL_FABRIC value
         * @property {number} MATERIAL_RETROREFLECTOR=27 MATERIAL_RETROREFLECTOR value
         * @property {number} MATERIAL_TAR=28 MATERIAL_TAR value
         * @property {number} MATERIAL_RETROREFLECTIVE_PAINT=29 MATERIAL_RETROREFLECTIVE_PAINT value
         * @property {number} MATERIAL_FIBERGLASS=30 MATERIAL_FIBERGLASS value
         * @property {number} MATERIAL_CHROME=31 MATERIAL_CHROME value
         */
        types.MaterialType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MATERIAL_UNKNOWN"] = 0;
            values[valuesById[1] = "MATERIAL_OTHER"] = 1;
            values[valuesById[2] = "MATERIAL_ASPHALT"] = 2;
            values[valuesById[3] = "MATERIAL_GRAVEL"] = 3;
            values[valuesById[4] = "MATERIAL_ROCK"] = 4;
            values[valuesById[5] = "MATERIAL_SOIL"] = 5;
            values[valuesById[6] = "MATERIAL_SAND"] = 6;
            values[valuesById[7] = "MATERIAL_GRASS"] = 7;
            values[valuesById[8] = "MATERIAL_WATER"] = 8;
            values[valuesById[9] = "MATERIAL_SNOW"] = 9;
            values[valuesById[10] = "MATERIAL_CONCRETE"] = 10;
            values[valuesById[11] = "MATERIAL_STUCCO"] = 11;
            values[valuesById[12] = "MATERIAL_STONE"] = 12;
            values[valuesById[13] = "MATERIAL_BRICK"] = 13;
            values[valuesById[14] = "MATERIAL_WOOD"] = 14;
            values[valuesById[15] = "MATERIAL_GLASS"] = 15;
            values[valuesById[16] = "MATERIAL_MIRROR"] = 16;
            values[valuesById[17] = "MATERIAL_CERAMIC"] = 17;
            values[valuesById[18] = "MATERIAL_METAL"] = 18;
            values[valuesById[19] = "MATERIAL_CARBON_FIBER"] = 19;
            values[valuesById[20] = "MATERIAL_LEATHER"] = 20;
            values[valuesById[21] = "MATERIAL_PLASTIC"] = 21;
            values[valuesById[22] = "MATERIAL_RUBBER"] = 22;
            values[valuesById[23] = "MATERIAL_PAPER"] = 23;
            values[valuesById[24] = "MATERIAL_LEAF"] = 24;
            values[valuesById[25] = "MATERIAL_SKIN"] = 25;
            values[valuesById[26] = "MATERIAL_FABRIC"] = 26;
            values[valuesById[27] = "MATERIAL_RETROREFLECTOR"] = 27;
            values[valuesById[28] = "MATERIAL_TAR"] = 28;
            values[valuesById[29] = "MATERIAL_RETROREFLECTIVE_PAINT"] = 29;
            values[valuesById[30] = "MATERIAL_FIBERGLASS"] = 30;
            values[valuesById[31] = "MATERIAL_CHROME"] = 31;
            return values;
        })();

        /**
         * ReferenceFrame enum.
         * @name metamoto.types.ReferenceFrame
         * @enum {string}
         * @property {number} REFERENCE_FRAME_UNKNOWN=0 REFERENCE_FRAME_UNKNOWN value
         * @property {number} REFERENCE_FRAME_OTHER=1 REFERENCE_FRAME_OTHER value
         * @property {number} REFERENCE_FRAME_WORLD=2 REFERENCE_FRAME_WORLD value
         * @property {number} REFERENCE_FRAME_VEHICLE=3 REFERENCE_FRAME_VEHICLE value
         * @property {number} REFERENCE_FRAME_SENSOR=4 REFERENCE_FRAME_SENSOR value
         */
        types.ReferenceFrame = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REFERENCE_FRAME_UNKNOWN"] = 0;
            values[valuesById[1] = "REFERENCE_FRAME_OTHER"] = 1;
            values[valuesById[2] = "REFERENCE_FRAME_WORLD"] = 2;
            values[valuesById[3] = "REFERENCE_FRAME_VEHICLE"] = 3;
            values[valuesById[4] = "REFERENCE_FRAME_SENSOR"] = 4;
            return values;
        })();

        /**
         * Action enum.
         * @name metamoto.types.Action
         * @enum {string}
         * @property {number} ACTION_UNKNOWN=0 ACTION_UNKNOWN value
         * @property {number} ACTION_PASS=1 ACTION_PASS value
         * @property {number} ACTION_WARN=2 ACTION_WARN value
         * @property {number} ACTION_FAIL=3 ACTION_FAIL value
         * @property {number} ACTION_STOP=4 ACTION_STOP value
         */
        types.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ACTION_UNKNOWN"] = 0;
            values[valuesById[1] = "ACTION_PASS"] = 1;
            values[valuesById[2] = "ACTION_WARN"] = 2;
            values[valuesById[3] = "ACTION_FAIL"] = 3;
            values[valuesById[4] = "ACTION_STOP"] = 4;
            return values;
        })();

        types.Environment = (function() {

            /**
             * Properties of an Environment.
             * @memberof metamoto.types
             * @interface IEnvironment
             * @property {metamoto.types.Environment.IWeather|null} [weather] Environment weather
             * @property {number|null} [timeOfDay] Environment timeOfDay
             * @property {Array.<metamoto.types.Environment.IRoadConditions>|null} [roadConditions] Environment roadConditions
             * @property {metamoto.types.Environment.ILighting|null} [lighting] Environment lighting
             */

            /**
             * Constructs a new Environment.
             * @memberof metamoto.types
             * @classdesc Represents an Environment.
             * @implements IEnvironment
             * @constructor
             * @param {metamoto.types.IEnvironment=} [properties] Properties to set
             */
            function Environment(properties) {
                this.roadConditions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Environment weather.
             * @member {metamoto.types.Environment.IWeather|null|undefined} weather
             * @memberof metamoto.types.Environment
             * @instance
             */
            Environment.prototype.weather = null;

            /**
             * Environment timeOfDay.
             * @member {number} timeOfDay
             * @memberof metamoto.types.Environment
             * @instance
             */
            Environment.prototype.timeOfDay = 0;

            /**
             * Environment roadConditions.
             * @member {Array.<metamoto.types.Environment.IRoadConditions>} roadConditions
             * @memberof metamoto.types.Environment
             * @instance
             */
            Environment.prototype.roadConditions = $util.emptyArray;

            /**
             * Environment lighting.
             * @member {metamoto.types.Environment.ILighting|null|undefined} lighting
             * @memberof metamoto.types.Environment
             * @instance
             */
            Environment.prototype.lighting = null;

            /**
             * Creates a new Environment instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Environment
             * @static
             * @param {metamoto.types.IEnvironment=} [properties] Properties to set
             * @returns {metamoto.types.Environment} Environment instance
             */
            Environment.create = function create(properties) {
                return new Environment(properties);
            };

            /**
             * Encodes the specified Environment message. Does not implicitly {@link metamoto.types.Environment.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Environment
             * @static
             * @param {metamoto.types.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.weather != null && message.hasOwnProperty("weather"))
                    $root.metamoto.types.Environment.Weather.encode(message.weather, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.timeOfDay);
                if (message.roadConditions != null && message.roadConditions.length)
                    for (var i = 0; i < message.roadConditions.length; ++i)
                        $root.metamoto.types.Environment.RoadConditions.encode(message.roadConditions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.lighting != null && message.hasOwnProperty("lighting"))
                    $root.metamoto.types.Environment.Lighting.encode(message.lighting, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Environment message, length delimited. Does not implicitly {@link metamoto.types.Environment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Environment
             * @static
             * @param {metamoto.types.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Environment message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Environment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.weather = $root.metamoto.types.Environment.Weather.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.timeOfDay = reader.float();
                        break;
                    case 3:
                        if (!(message.roadConditions && message.roadConditions.length))
                            message.roadConditions = [];
                        message.roadConditions.push($root.metamoto.types.Environment.RoadConditions.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.lighting = $root.metamoto.types.Environment.Lighting.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Environment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Environment message.
             * @function verify
             * @memberof metamoto.types.Environment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Environment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    var error = $root.metamoto.types.Environment.Weather.verify(message.weather);
                    if (error)
                        return "weather." + error;
                }
                if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                    if (typeof message.timeOfDay !== "number")
                        return "timeOfDay: number expected";
                if (message.roadConditions != null && message.hasOwnProperty("roadConditions")) {
                    if (!Array.isArray(message.roadConditions))
                        return "roadConditions: array expected";
                    for (var i = 0; i < message.roadConditions.length; ++i) {
                        var error = $root.metamoto.types.Environment.RoadConditions.verify(message.roadConditions[i]);
                        if (error)
                            return "roadConditions." + error;
                    }
                }
                if (message.lighting != null && message.hasOwnProperty("lighting")) {
                    var error = $root.metamoto.types.Environment.Lighting.verify(message.lighting);
                    if (error)
                        return "lighting." + error;
                }
                return null;
            };

            /**
             * Creates an Environment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Environment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Environment} Environment
             */
            Environment.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Environment)
                    return object;
                var message = new $root.metamoto.types.Environment();
                if (object.weather != null) {
                    if (typeof object.weather !== "object")
                        throw TypeError(".metamoto.types.Environment.weather: object expected");
                    message.weather = $root.metamoto.types.Environment.Weather.fromObject(object.weather);
                }
                if (object.timeOfDay != null)
                    message.timeOfDay = Number(object.timeOfDay);
                if (object.roadConditions) {
                    if (!Array.isArray(object.roadConditions))
                        throw TypeError(".metamoto.types.Environment.roadConditions: array expected");
                    message.roadConditions = [];
                    for (var i = 0; i < object.roadConditions.length; ++i) {
                        if (typeof object.roadConditions[i] !== "object")
                            throw TypeError(".metamoto.types.Environment.roadConditions: object expected");
                        message.roadConditions[i] = $root.metamoto.types.Environment.RoadConditions.fromObject(object.roadConditions[i]);
                    }
                }
                if (object.lighting != null) {
                    if (typeof object.lighting !== "object")
                        throw TypeError(".metamoto.types.Environment.lighting: object expected");
                    message.lighting = $root.metamoto.types.Environment.Lighting.fromObject(object.lighting);
                }
                return message;
            };

            /**
             * Creates a plain object from an Environment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Environment
             * @static
             * @param {metamoto.types.Environment} message Environment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Environment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.roadConditions = [];
                if (options.defaults) {
                    object.weather = null;
                    object.timeOfDay = 0;
                    object.lighting = null;
                }
                if (message.weather != null && message.hasOwnProperty("weather"))
                    object.weather = $root.metamoto.types.Environment.Weather.toObject(message.weather, options);
                if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                    object.timeOfDay = options.json && !isFinite(message.timeOfDay) ? String(message.timeOfDay) : message.timeOfDay;
                if (message.roadConditions && message.roadConditions.length) {
                    object.roadConditions = [];
                    for (var j = 0; j < message.roadConditions.length; ++j)
                        object.roadConditions[j] = $root.metamoto.types.Environment.RoadConditions.toObject(message.roadConditions[j], options);
                }
                if (message.lighting != null && message.hasOwnProperty("lighting"))
                    object.lighting = $root.metamoto.types.Environment.Lighting.toObject(message.lighting, options);
                return object;
            };

            /**
             * Converts this Environment to JSON.
             * @function toJSON
             * @memberof metamoto.types.Environment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Environment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Environment.Weather = (function() {

                /**
                 * Properties of a Weather.
                 * @memberof metamoto.types.Environment
                 * @interface IWeather
                 * @property {number|null} [clouds] Weather clouds
                 * @property {number|null} [overcast] Weather overcast
                 * @property {number|null} [wind] Weather wind
                 * @property {number|null} [rain] Weather rain
                 * @property {number|null} [snow] Weather snow
                 * @property {number|null} [hail] Weather hail
                 * @property {number|null} [fog] Weather fog
                 * @property {number|null} [temperature] Weather temperature
                 */

                /**
                 * Constructs a new Weather.
                 * @memberof metamoto.types.Environment
                 * @classdesc Represents a Weather.
                 * @implements IWeather
                 * @constructor
                 * @param {metamoto.types.Environment.IWeather=} [properties] Properties to set
                 */
                function Weather(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Weather clouds.
                 * @member {number} clouds
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.clouds = 0;

                /**
                 * Weather overcast.
                 * @member {number} overcast
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.overcast = 0;

                /**
                 * Weather wind.
                 * @member {number} wind
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.wind = 0;

                /**
                 * Weather rain.
                 * @member {number} rain
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.rain = 0;

                /**
                 * Weather snow.
                 * @member {number} snow
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.snow = 0;

                /**
                 * Weather hail.
                 * @member {number} hail
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.hail = 0;

                /**
                 * Weather fog.
                 * @member {number} fog
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.fog = 0;

                /**
                 * Weather temperature.
                 * @member {number} temperature
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 */
                Weather.prototype.temperature = 0;

                /**
                 * Creates a new Weather instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {metamoto.types.Environment.IWeather=} [properties] Properties to set
                 * @returns {metamoto.types.Environment.Weather} Weather instance
                 */
                Weather.create = function create(properties) {
                    return new Weather(properties);
                };

                /**
                 * Encodes the specified Weather message. Does not implicitly {@link metamoto.types.Environment.Weather.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {metamoto.types.Environment.IWeather} message Weather message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Weather.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.clouds != null && message.hasOwnProperty("clouds"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.clouds);
                    if (message.overcast != null && message.hasOwnProperty("overcast"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.overcast);
                    if (message.wind != null && message.hasOwnProperty("wind"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.wind);
                    if (message.rain != null && message.hasOwnProperty("rain"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.rain);
                    if (message.snow != null && message.hasOwnProperty("snow"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.snow);
                    if (message.hail != null && message.hasOwnProperty("hail"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.hail);
                    if (message.fog != null && message.hasOwnProperty("fog"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.fog);
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.temperature);
                    return writer;
                };

                /**
                 * Encodes the specified Weather message, length delimited. Does not implicitly {@link metamoto.types.Environment.Weather.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {metamoto.types.Environment.IWeather} message Weather message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Weather.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Weather message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Environment.Weather} Weather
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Weather.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Environment.Weather();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.clouds = reader.float();
                            break;
                        case 2:
                            message.overcast = reader.float();
                            break;
                        case 3:
                            message.wind = reader.float();
                            break;
                        case 4:
                            message.rain = reader.float();
                            break;
                        case 5:
                            message.snow = reader.float();
                            break;
                        case 6:
                            message.hail = reader.float();
                            break;
                        case 7:
                            message.fog = reader.float();
                            break;
                        case 8:
                            message.temperature = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Weather message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Environment.Weather} Weather
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Weather.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Weather message.
                 * @function verify
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Weather.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clouds != null && message.hasOwnProperty("clouds"))
                        if (typeof message.clouds !== "number")
                            return "clouds: number expected";
                    if (message.overcast != null && message.hasOwnProperty("overcast"))
                        if (typeof message.overcast !== "number")
                            return "overcast: number expected";
                    if (message.wind != null && message.hasOwnProperty("wind"))
                        if (typeof message.wind !== "number")
                            return "wind: number expected";
                    if (message.rain != null && message.hasOwnProperty("rain"))
                        if (typeof message.rain !== "number")
                            return "rain: number expected";
                    if (message.snow != null && message.hasOwnProperty("snow"))
                        if (typeof message.snow !== "number")
                            return "snow: number expected";
                    if (message.hail != null && message.hasOwnProperty("hail"))
                        if (typeof message.hail !== "number")
                            return "hail: number expected";
                    if (message.fog != null && message.hasOwnProperty("fog"))
                        if (typeof message.fog !== "number")
                            return "fog: number expected";
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        if (typeof message.temperature !== "number")
                            return "temperature: number expected";
                    return null;
                };

                /**
                 * Creates a Weather message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Environment.Weather} Weather
                 */
                Weather.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Environment.Weather)
                        return object;
                    var message = new $root.metamoto.types.Environment.Weather();
                    if (object.clouds != null)
                        message.clouds = Number(object.clouds);
                    if (object.overcast != null)
                        message.overcast = Number(object.overcast);
                    if (object.wind != null)
                        message.wind = Number(object.wind);
                    if (object.rain != null)
                        message.rain = Number(object.rain);
                    if (object.snow != null)
                        message.snow = Number(object.snow);
                    if (object.hail != null)
                        message.hail = Number(object.hail);
                    if (object.fog != null)
                        message.fog = Number(object.fog);
                    if (object.temperature != null)
                        message.temperature = Number(object.temperature);
                    return message;
                };

                /**
                 * Creates a plain object from a Weather message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Environment.Weather
                 * @static
                 * @param {metamoto.types.Environment.Weather} message Weather
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Weather.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.clouds = 0;
                        object.overcast = 0;
                        object.wind = 0;
                        object.rain = 0;
                        object.snow = 0;
                        object.hail = 0;
                        object.fog = 0;
                        object.temperature = 0;
                    }
                    if (message.clouds != null && message.hasOwnProperty("clouds"))
                        object.clouds = options.json && !isFinite(message.clouds) ? String(message.clouds) : message.clouds;
                    if (message.overcast != null && message.hasOwnProperty("overcast"))
                        object.overcast = options.json && !isFinite(message.overcast) ? String(message.overcast) : message.overcast;
                    if (message.wind != null && message.hasOwnProperty("wind"))
                        object.wind = options.json && !isFinite(message.wind) ? String(message.wind) : message.wind;
                    if (message.rain != null && message.hasOwnProperty("rain"))
                        object.rain = options.json && !isFinite(message.rain) ? String(message.rain) : message.rain;
                    if (message.snow != null && message.hasOwnProperty("snow"))
                        object.snow = options.json && !isFinite(message.snow) ? String(message.snow) : message.snow;
                    if (message.hail != null && message.hasOwnProperty("hail"))
                        object.hail = options.json && !isFinite(message.hail) ? String(message.hail) : message.hail;
                    if (message.fog != null && message.hasOwnProperty("fog"))
                        object.fog = options.json && !isFinite(message.fog) ? String(message.fog) : message.fog;
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                    return object;
                };

                /**
                 * Converts this Weather to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Environment.Weather
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Weather.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Weather;
            })();

            Environment.RoadConditions = (function() {

                /**
                 * Properties of a RoadConditions.
                 * @memberof metamoto.types.Environment
                 * @interface IRoadConditions
                 * @property {string|null} [roadId] RoadConditions roadId
                 * @property {number|null} [laneIndex] RoadConditions laneIndex
                 * @property {number|null} [sMin] RoadConditions sMin
                 * @property {number|null} [sMax] RoadConditions sMax
                 * @property {number|null} [wetness] RoadConditions wetness
                 * @property {number|null} [puddles] RoadConditions puddles
                 * @property {number|null} [markingsDeterioration] RoadConditions markingsDeterioration
                 * @property {number|null} [cracks] RoadConditions cracks
                 * @property {number|null} [tarSnakes] RoadConditions tarSnakes
                 * @property {number|null} [potHoles] RoadConditions potHoles
                 */

                /**
                 * Constructs a new RoadConditions.
                 * @memberof metamoto.types.Environment
                 * @classdesc Represents a RoadConditions.
                 * @implements IRoadConditions
                 * @constructor
                 * @param {metamoto.types.Environment.IRoadConditions=} [properties] Properties to set
                 */
                function RoadConditions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RoadConditions roadId.
                 * @member {string} roadId
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.roadId = "";

                /**
                 * RoadConditions laneIndex.
                 * @member {number} laneIndex
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.laneIndex = 0;

                /**
                 * RoadConditions sMin.
                 * @member {number} sMin
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.sMin = 0;

                /**
                 * RoadConditions sMax.
                 * @member {number} sMax
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.sMax = 0;

                /**
                 * RoadConditions wetness.
                 * @member {number} wetness
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.wetness = 0;

                /**
                 * RoadConditions puddles.
                 * @member {number} puddles
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.puddles = 0;

                /**
                 * RoadConditions markingsDeterioration.
                 * @member {number} markingsDeterioration
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.markingsDeterioration = 0;

                /**
                 * RoadConditions cracks.
                 * @member {number} cracks
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.cracks = 0;

                /**
                 * RoadConditions tarSnakes.
                 * @member {number} tarSnakes
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.tarSnakes = 0;

                /**
                 * RoadConditions potHoles.
                 * @member {number} potHoles
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 */
                RoadConditions.prototype.potHoles = 0;

                /**
                 * Creates a new RoadConditions instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {metamoto.types.Environment.IRoadConditions=} [properties] Properties to set
                 * @returns {metamoto.types.Environment.RoadConditions} RoadConditions instance
                 */
                RoadConditions.create = function create(properties) {
                    return new RoadConditions(properties);
                };

                /**
                 * Encodes the specified RoadConditions message. Does not implicitly {@link metamoto.types.Environment.RoadConditions.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {metamoto.types.Environment.IRoadConditions} message RoadConditions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RoadConditions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.roadId);
                    if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.laneIndex);
                    if (message.sMin != null && message.hasOwnProperty("sMin"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.sMin);
                    if (message.sMax != null && message.hasOwnProperty("sMax"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.sMax);
                    if (message.wetness != null && message.hasOwnProperty("wetness"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.wetness);
                    if (message.puddles != null && message.hasOwnProperty("puddles"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.puddles);
                    if (message.markingsDeterioration != null && message.hasOwnProperty("markingsDeterioration"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.markingsDeterioration);
                    if (message.cracks != null && message.hasOwnProperty("cracks"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.cracks);
                    if (message.tarSnakes != null && message.hasOwnProperty("tarSnakes"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.tarSnakes);
                    if (message.potHoles != null && message.hasOwnProperty("potHoles"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.potHoles);
                    return writer;
                };

                /**
                 * Encodes the specified RoadConditions message, length delimited. Does not implicitly {@link metamoto.types.Environment.RoadConditions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {metamoto.types.Environment.IRoadConditions} message RoadConditions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RoadConditions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RoadConditions message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Environment.RoadConditions} RoadConditions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RoadConditions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Environment.RoadConditions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.roadId = reader.string();
                            break;
                        case 2:
                            message.laneIndex = reader.int32();
                            break;
                        case 3:
                            message.sMin = reader.float();
                            break;
                        case 4:
                            message.sMax = reader.float();
                            break;
                        case 5:
                            message.wetness = reader.float();
                            break;
                        case 6:
                            message.puddles = reader.float();
                            break;
                        case 7:
                            message.markingsDeterioration = reader.float();
                            break;
                        case 8:
                            message.cracks = reader.float();
                            break;
                        case 9:
                            message.tarSnakes = reader.float();
                            break;
                        case 10:
                            message.potHoles = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RoadConditions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Environment.RoadConditions} RoadConditions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RoadConditions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RoadConditions message.
                 * @function verify
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RoadConditions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        if (!$util.isString(message.roadId))
                            return "roadId: string expected";
                    if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                        if (!$util.isInteger(message.laneIndex))
                            return "laneIndex: integer expected";
                    if (message.sMin != null && message.hasOwnProperty("sMin"))
                        if (typeof message.sMin !== "number")
                            return "sMin: number expected";
                    if (message.sMax != null && message.hasOwnProperty("sMax"))
                        if (typeof message.sMax !== "number")
                            return "sMax: number expected";
                    if (message.wetness != null && message.hasOwnProperty("wetness"))
                        if (typeof message.wetness !== "number")
                            return "wetness: number expected";
                    if (message.puddles != null && message.hasOwnProperty("puddles"))
                        if (typeof message.puddles !== "number")
                            return "puddles: number expected";
                    if (message.markingsDeterioration != null && message.hasOwnProperty("markingsDeterioration"))
                        if (typeof message.markingsDeterioration !== "number")
                            return "markingsDeterioration: number expected";
                    if (message.cracks != null && message.hasOwnProperty("cracks"))
                        if (typeof message.cracks !== "number")
                            return "cracks: number expected";
                    if (message.tarSnakes != null && message.hasOwnProperty("tarSnakes"))
                        if (typeof message.tarSnakes !== "number")
                            return "tarSnakes: number expected";
                    if (message.potHoles != null && message.hasOwnProperty("potHoles"))
                        if (typeof message.potHoles !== "number")
                            return "potHoles: number expected";
                    return null;
                };

                /**
                 * Creates a RoadConditions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Environment.RoadConditions} RoadConditions
                 */
                RoadConditions.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Environment.RoadConditions)
                        return object;
                    var message = new $root.metamoto.types.Environment.RoadConditions();
                    if (object.roadId != null)
                        message.roadId = String(object.roadId);
                    if (object.laneIndex != null)
                        message.laneIndex = object.laneIndex | 0;
                    if (object.sMin != null)
                        message.sMin = Number(object.sMin);
                    if (object.sMax != null)
                        message.sMax = Number(object.sMax);
                    if (object.wetness != null)
                        message.wetness = Number(object.wetness);
                    if (object.puddles != null)
                        message.puddles = Number(object.puddles);
                    if (object.markingsDeterioration != null)
                        message.markingsDeterioration = Number(object.markingsDeterioration);
                    if (object.cracks != null)
                        message.cracks = Number(object.cracks);
                    if (object.tarSnakes != null)
                        message.tarSnakes = Number(object.tarSnakes);
                    if (object.potHoles != null)
                        message.potHoles = Number(object.potHoles);
                    return message;
                };

                /**
                 * Creates a plain object from a RoadConditions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @static
                 * @param {metamoto.types.Environment.RoadConditions} message RoadConditions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RoadConditions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.roadId = "";
                        object.laneIndex = 0;
                        object.sMin = 0;
                        object.sMax = 0;
                        object.wetness = 0;
                        object.puddles = 0;
                        object.markingsDeterioration = 0;
                        object.cracks = 0;
                        object.tarSnakes = 0;
                        object.potHoles = 0;
                    }
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        object.roadId = message.roadId;
                    if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                        object.laneIndex = message.laneIndex;
                    if (message.sMin != null && message.hasOwnProperty("sMin"))
                        object.sMin = options.json && !isFinite(message.sMin) ? String(message.sMin) : message.sMin;
                    if (message.sMax != null && message.hasOwnProperty("sMax"))
                        object.sMax = options.json && !isFinite(message.sMax) ? String(message.sMax) : message.sMax;
                    if (message.wetness != null && message.hasOwnProperty("wetness"))
                        object.wetness = options.json && !isFinite(message.wetness) ? String(message.wetness) : message.wetness;
                    if (message.puddles != null && message.hasOwnProperty("puddles"))
                        object.puddles = options.json && !isFinite(message.puddles) ? String(message.puddles) : message.puddles;
                    if (message.markingsDeterioration != null && message.hasOwnProperty("markingsDeterioration"))
                        object.markingsDeterioration = options.json && !isFinite(message.markingsDeterioration) ? String(message.markingsDeterioration) : message.markingsDeterioration;
                    if (message.cracks != null && message.hasOwnProperty("cracks"))
                        object.cracks = options.json && !isFinite(message.cracks) ? String(message.cracks) : message.cracks;
                    if (message.tarSnakes != null && message.hasOwnProperty("tarSnakes"))
                        object.tarSnakes = options.json && !isFinite(message.tarSnakes) ? String(message.tarSnakes) : message.tarSnakes;
                    if (message.potHoles != null && message.hasOwnProperty("potHoles"))
                        object.potHoles = options.json && !isFinite(message.potHoles) ? String(message.potHoles) : message.potHoles;
                    return object;
                };

                /**
                 * Converts this RoadConditions to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Environment.RoadConditions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RoadConditions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RoadConditions;
            })();

            Environment.Lighting = (function() {

                /**
                 * Properties of a Lighting.
                 * @memberof metamoto.types.Environment
                 * @interface ILighting
                 * @property {number|null} [buildings] Lighting buildings
                 */

                /**
                 * Constructs a new Lighting.
                 * @memberof metamoto.types.Environment
                 * @classdesc Represents a Lighting.
                 * @implements ILighting
                 * @constructor
                 * @param {metamoto.types.Environment.ILighting=} [properties] Properties to set
                 */
                function Lighting(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Lighting buildings.
                 * @member {number} buildings
                 * @memberof metamoto.types.Environment.Lighting
                 * @instance
                 */
                Lighting.prototype.buildings = 0;

                /**
                 * Creates a new Lighting instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {metamoto.types.Environment.ILighting=} [properties] Properties to set
                 * @returns {metamoto.types.Environment.Lighting} Lighting instance
                 */
                Lighting.create = function create(properties) {
                    return new Lighting(properties);
                };

                /**
                 * Encodes the specified Lighting message. Does not implicitly {@link metamoto.types.Environment.Lighting.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {metamoto.types.Environment.ILighting} message Lighting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Lighting.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.buildings != null && message.hasOwnProperty("buildings"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.buildings);
                    return writer;
                };

                /**
                 * Encodes the specified Lighting message, length delimited. Does not implicitly {@link metamoto.types.Environment.Lighting.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {metamoto.types.Environment.ILighting} message Lighting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Lighting.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Lighting message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Environment.Lighting} Lighting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Lighting.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Environment.Lighting();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.buildings = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Lighting message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Environment.Lighting} Lighting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Lighting.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Lighting message.
                 * @function verify
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Lighting.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.buildings != null && message.hasOwnProperty("buildings"))
                        if (typeof message.buildings !== "number")
                            return "buildings: number expected";
                    return null;
                };

                /**
                 * Creates a Lighting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Environment.Lighting} Lighting
                 */
                Lighting.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Environment.Lighting)
                        return object;
                    var message = new $root.metamoto.types.Environment.Lighting();
                    if (object.buildings != null)
                        message.buildings = Number(object.buildings);
                    return message;
                };

                /**
                 * Creates a plain object from a Lighting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Environment.Lighting
                 * @static
                 * @param {metamoto.types.Environment.Lighting} message Lighting
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Lighting.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.buildings = 0;
                    if (message.buildings != null && message.hasOwnProperty("buildings"))
                        object.buildings = options.json && !isFinite(message.buildings) ? String(message.buildings) : message.buildings;
                    return object;
                };

                /**
                 * Converts this Lighting to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Environment.Lighting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Lighting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Lighting;
            })();

            return Environment;
        })();

        types.GeoCoordinates = (function() {

            /**
             * Properties of a GeoCoordinates.
             * @memberof metamoto.types
             * @interface IGeoCoordinates
             * @property {number|null} [latitude] GeoCoordinates latitude
             * @property {number|null} [longitude] GeoCoordinates longitude
             * @property {number|null} [altitude] GeoCoordinates altitude
             */

            /**
             * Constructs a new GeoCoordinates.
             * @memberof metamoto.types
             * @classdesc Represents a GeoCoordinates.
             * @implements IGeoCoordinates
             * @constructor
             * @param {metamoto.types.IGeoCoordinates=} [properties] Properties to set
             */
            function GeoCoordinates(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoCoordinates latitude.
             * @member {number} latitude
             * @memberof metamoto.types.GeoCoordinates
             * @instance
             */
            GeoCoordinates.prototype.latitude = 0;

            /**
             * GeoCoordinates longitude.
             * @member {number} longitude
             * @memberof metamoto.types.GeoCoordinates
             * @instance
             */
            GeoCoordinates.prototype.longitude = 0;

            /**
             * GeoCoordinates altitude.
             * @member {number} altitude
             * @memberof metamoto.types.GeoCoordinates
             * @instance
             */
            GeoCoordinates.prototype.altitude = 0;

            /**
             * Creates a new GeoCoordinates instance using the specified properties.
             * @function create
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {metamoto.types.IGeoCoordinates=} [properties] Properties to set
             * @returns {metamoto.types.GeoCoordinates} GeoCoordinates instance
             */
            GeoCoordinates.create = function create(properties) {
                return new GeoCoordinates(properties);
            };

            /**
             * Encodes the specified GeoCoordinates message. Does not implicitly {@link metamoto.types.GeoCoordinates.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {metamoto.types.IGeoCoordinates} message GeoCoordinates message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoCoordinates.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.latitude != null && message.hasOwnProperty("latitude"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.latitude);
                if (message.longitude != null && message.hasOwnProperty("longitude"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.longitude);
                if (message.altitude != null && message.hasOwnProperty("altitude"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.altitude);
                return writer;
            };

            /**
             * Encodes the specified GeoCoordinates message, length delimited. Does not implicitly {@link metamoto.types.GeoCoordinates.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {metamoto.types.IGeoCoordinates} message GeoCoordinates message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoCoordinates.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoCoordinates message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.GeoCoordinates} GeoCoordinates
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoCoordinates.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.GeoCoordinates();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.latitude = reader.float();
                        break;
                    case 2:
                        message.longitude = reader.float();
                        break;
                    case 3:
                        message.altitude = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoCoordinates message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.GeoCoordinates} GeoCoordinates
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoCoordinates.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoCoordinates message.
             * @function verify
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoCoordinates.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.latitude != null && message.hasOwnProperty("latitude"))
                    if (typeof message.latitude !== "number")
                        return "latitude: number expected";
                if (message.longitude != null && message.hasOwnProperty("longitude"))
                    if (typeof message.longitude !== "number")
                        return "longitude: number expected";
                if (message.altitude != null && message.hasOwnProperty("altitude"))
                    if (typeof message.altitude !== "number")
                        return "altitude: number expected";
                return null;
            };

            /**
             * Creates a GeoCoordinates message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.GeoCoordinates} GeoCoordinates
             */
            GeoCoordinates.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.GeoCoordinates)
                    return object;
                var message = new $root.metamoto.types.GeoCoordinates();
                if (object.latitude != null)
                    message.latitude = Number(object.latitude);
                if (object.longitude != null)
                    message.longitude = Number(object.longitude);
                if (object.altitude != null)
                    message.altitude = Number(object.altitude);
                return message;
            };

            /**
             * Creates a plain object from a GeoCoordinates message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.GeoCoordinates
             * @static
             * @param {metamoto.types.GeoCoordinates} message GeoCoordinates
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoCoordinates.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.latitude = 0;
                    object.longitude = 0;
                    object.altitude = 0;
                }
                if (message.latitude != null && message.hasOwnProperty("latitude"))
                    object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
                if (message.longitude != null && message.hasOwnProperty("longitude"))
                    object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
                if (message.altitude != null && message.hasOwnProperty("altitude"))
                    object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                return object;
            };

            /**
             * Converts this GeoCoordinates to JSON.
             * @function toJSON
             * @memberof metamoto.types.GeoCoordinates
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoCoordinates.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoCoordinates;
        })();

        types.Image = (function() {

            /**
             * Properties of an Image.
             * @memberof metamoto.types
             * @interface IImage
             * @property {number|null} [width] Image width
             * @property {number|null} [height] Image height
             * @property {number|null} [step] Image step
             * @property {string|null} [encoding] Image encoding
             * @property {Uint8Array|null} [data] Image data
             */

            /**
             * Constructs a new Image.
             * @memberof metamoto.types
             * @classdesc Represents an Image.
             * @implements IImage
             * @constructor
             * @param {metamoto.types.IImage=} [properties] Properties to set
             */
            function Image(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Image width.
             * @member {number} width
             * @memberof metamoto.types.Image
             * @instance
             */
            Image.prototype.width = 0;

            /**
             * Image height.
             * @member {number} height
             * @memberof metamoto.types.Image
             * @instance
             */
            Image.prototype.height = 0;

            /**
             * Image step.
             * @member {number} step
             * @memberof metamoto.types.Image
             * @instance
             */
            Image.prototype.step = 0;

            /**
             * Image encoding.
             * @member {string} encoding
             * @memberof metamoto.types.Image
             * @instance
             */
            Image.prototype.encoding = "";

            /**
             * Image data.
             * @member {Uint8Array} data
             * @memberof metamoto.types.Image
             * @instance
             */
            Image.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new Image instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Image
             * @static
             * @param {metamoto.types.IImage=} [properties] Properties to set
             * @returns {metamoto.types.Image} Image instance
             */
            Image.create = function create(properties) {
                return new Image(properties);
            };

            /**
             * Encodes the specified Image message. Does not implicitly {@link metamoto.types.Image.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Image
             * @static
             * @param {metamoto.types.IImage} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.width != null && message.hasOwnProperty("width"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.width);
                if (message.height != null && message.hasOwnProperty("height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.height);
                if (message.step != null && message.hasOwnProperty("step"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.step);
                if (message.encoding != null && message.hasOwnProperty("encoding"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.encoding);
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified Image message, length delimited. Does not implicitly {@link metamoto.types.Image.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Image
             * @static
             * @param {metamoto.types.IImage} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Image message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Image
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Image();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.width = reader.uint32();
                        break;
                    case 2:
                        message.height = reader.uint32();
                        break;
                    case 3:
                        message.step = reader.uint32();
                        break;
                    case 4:
                        message.encoding = reader.string();
                        break;
                    case 5:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Image message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Image
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Image message.
             * @function verify
             * @memberof metamoto.types.Image
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Image.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height))
                        return "height: integer expected";
                if (message.step != null && message.hasOwnProperty("step"))
                    if (!$util.isInteger(message.step))
                        return "step: integer expected";
                if (message.encoding != null && message.hasOwnProperty("encoding"))
                    if (!$util.isString(message.encoding))
                        return "encoding: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Image
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Image} Image
             */
            Image.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Image)
                    return object;
                var message = new $root.metamoto.types.Image();
                if (object.width != null)
                    message.width = object.width >>> 0;
                if (object.height != null)
                    message.height = object.height >>> 0;
                if (object.step != null)
                    message.step = object.step >>> 0;
                if (object.encoding != null)
                    message.encoding = String(object.encoding);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from an Image message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Image
             * @static
             * @param {metamoto.types.Image} message Image
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Image.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.width = 0;
                    object.height = 0;
                    object.step = 0;
                    object.encoding = "";
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = message.height;
                if (message.step != null && message.hasOwnProperty("step"))
                    object.step = message.step;
                if (message.encoding != null && message.hasOwnProperty("encoding"))
                    object.encoding = message.encoding;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this Image to JSON.
             * @function toJSON
             * @memberof metamoto.types.Image
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Image.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Image;
        })();

        types.LaserReturn = (function() {

            /**
             * Properties of a LaserReturn.
             * @memberof metamoto.types
             * @interface ILaserReturn
             * @property {number|null} [elevationAngle] LaserReturn elevationAngle
             * @property {Array.<number>|null} [ranges] LaserReturn ranges
             * @property {Array.<number>|null} [intensities] LaserReturn intensities
             * @property {Array.<number>|null} [objectIds] LaserReturn objectIds
             * @property {Array.<metamoto.types.ObjectType>|null} [objectTypes] LaserReturn objectTypes
             */

            /**
             * Constructs a new LaserReturn.
             * @memberof metamoto.types
             * @classdesc Represents a LaserReturn.
             * @implements ILaserReturn
             * @constructor
             * @param {metamoto.types.ILaserReturn=} [properties] Properties to set
             */
            function LaserReturn(properties) {
                this.ranges = [];
                this.intensities = [];
                this.objectIds = [];
                this.objectTypes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaserReturn elevationAngle.
             * @member {number} elevationAngle
             * @memberof metamoto.types.LaserReturn
             * @instance
             */
            LaserReturn.prototype.elevationAngle = 0;

            /**
             * LaserReturn ranges.
             * @member {Array.<number>} ranges
             * @memberof metamoto.types.LaserReturn
             * @instance
             */
            LaserReturn.prototype.ranges = $util.emptyArray;

            /**
             * LaserReturn intensities.
             * @member {Array.<number>} intensities
             * @memberof metamoto.types.LaserReturn
             * @instance
             */
            LaserReturn.prototype.intensities = $util.emptyArray;

            /**
             * LaserReturn objectIds.
             * @member {Array.<number>} objectIds
             * @memberof metamoto.types.LaserReturn
             * @instance
             */
            LaserReturn.prototype.objectIds = $util.emptyArray;

            /**
             * LaserReturn objectTypes.
             * @member {Array.<metamoto.types.ObjectType>} objectTypes
             * @memberof metamoto.types.LaserReturn
             * @instance
             */
            LaserReturn.prototype.objectTypes = $util.emptyArray;

            /**
             * Creates a new LaserReturn instance using the specified properties.
             * @function create
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {metamoto.types.ILaserReturn=} [properties] Properties to set
             * @returns {metamoto.types.LaserReturn} LaserReturn instance
             */
            LaserReturn.create = function create(properties) {
                return new LaserReturn(properties);
            };

            /**
             * Encodes the specified LaserReturn message. Does not implicitly {@link metamoto.types.LaserReturn.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {metamoto.types.ILaserReturn} message LaserReturn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaserReturn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.elevationAngle);
                if (message.ranges != null && message.ranges.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.ranges.length; ++i)
                        writer.float(message.ranges[i]);
                    writer.ldelim();
                }
                if (message.intensities != null && message.intensities.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.intensities.length; ++i)
                        writer.float(message.intensities[i]);
                    writer.ldelim();
                }
                if (message.objectIds != null && message.objectIds.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.objectIds.length; ++i)
                        writer.uint32(message.objectIds[i]);
                    writer.ldelim();
                }
                if (message.objectTypes != null && message.objectTypes.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (var i = 0; i < message.objectTypes.length; ++i)
                        writer.int32(message.objectTypes[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified LaserReturn message, length delimited. Does not implicitly {@link metamoto.types.LaserReturn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {metamoto.types.ILaserReturn} message LaserReturn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaserReturn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaserReturn message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.LaserReturn} LaserReturn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaserReturn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.LaserReturn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.elevationAngle = reader.float();
                        break;
                    case 2:
                        if (!(message.ranges && message.ranges.length))
                            message.ranges = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ranges.push(reader.float());
                        } else
                            message.ranges.push(reader.float());
                        break;
                    case 3:
                        if (!(message.intensities && message.intensities.length))
                            message.intensities = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.intensities.push(reader.float());
                        } else
                            message.intensities.push(reader.float());
                        break;
                    case 4:
                        if (!(message.objectIds && message.objectIds.length))
                            message.objectIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.objectIds.push(reader.uint32());
                        } else
                            message.objectIds.push(reader.uint32());
                        break;
                    case 5:
                        if (!(message.objectTypes && message.objectTypes.length))
                            message.objectTypes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.objectTypes.push(reader.int32());
                        } else
                            message.objectTypes.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaserReturn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.LaserReturn} LaserReturn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaserReturn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaserReturn message.
             * @function verify
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaserReturn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    if (typeof message.elevationAngle !== "number")
                        return "elevationAngle: number expected";
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!Array.isArray(message.ranges))
                        return "ranges: array expected";
                    for (var i = 0; i < message.ranges.length; ++i)
                        if (typeof message.ranges[i] !== "number")
                            return "ranges: number[] expected";
                }
                if (message.intensities != null && message.hasOwnProperty("intensities")) {
                    if (!Array.isArray(message.intensities))
                        return "intensities: array expected";
                    for (var i = 0; i < message.intensities.length; ++i)
                        if (typeof message.intensities[i] !== "number")
                            return "intensities: number[] expected";
                }
                if (message.objectIds != null && message.hasOwnProperty("objectIds")) {
                    if (!Array.isArray(message.objectIds))
                        return "objectIds: array expected";
                    for (var i = 0; i < message.objectIds.length; ++i)
                        if (!$util.isInteger(message.objectIds[i]))
                            return "objectIds: integer[] expected";
                }
                if (message.objectTypes != null && message.hasOwnProperty("objectTypes")) {
                    if (!Array.isArray(message.objectTypes))
                        return "objectTypes: array expected";
                    for (var i = 0; i < message.objectTypes.length; ++i)
                        switch (message.objectTypes[i]) {
                        default:
                            return "objectTypes: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                            break;
                        }
                }
                return null;
            };

            /**
             * Creates a LaserReturn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.LaserReturn} LaserReturn
             */
            LaserReturn.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.LaserReturn)
                    return object;
                var message = new $root.metamoto.types.LaserReturn();
                if (object.elevationAngle != null)
                    message.elevationAngle = Number(object.elevationAngle);
                if (object.ranges) {
                    if (!Array.isArray(object.ranges))
                        throw TypeError(".metamoto.types.LaserReturn.ranges: array expected");
                    message.ranges = [];
                    for (var i = 0; i < object.ranges.length; ++i)
                        message.ranges[i] = Number(object.ranges[i]);
                }
                if (object.intensities) {
                    if (!Array.isArray(object.intensities))
                        throw TypeError(".metamoto.types.LaserReturn.intensities: array expected");
                    message.intensities = [];
                    for (var i = 0; i < object.intensities.length; ++i)
                        message.intensities[i] = Number(object.intensities[i]);
                }
                if (object.objectIds) {
                    if (!Array.isArray(object.objectIds))
                        throw TypeError(".metamoto.types.LaserReturn.objectIds: array expected");
                    message.objectIds = [];
                    for (var i = 0; i < object.objectIds.length; ++i)
                        message.objectIds[i] = object.objectIds[i] >>> 0;
                }
                if (object.objectTypes) {
                    if (!Array.isArray(object.objectTypes))
                        throw TypeError(".metamoto.types.LaserReturn.objectTypes: array expected");
                    message.objectTypes = [];
                    for (var i = 0; i < object.objectTypes.length; ++i)
                        switch (object.objectTypes[i]) {
                        default:
                        case "OBJECT_UNKNOWN":
                        case 0:
                            message.objectTypes[i] = 0;
                            break;
                        case "OBJECT_OTHER":
                        case 1:
                            message.objectTypes[i] = 1;
                            break;
                        case "OBJECT_CAR":
                        case 2:
                            message.objectTypes[i] = 2;
                            break;
                        case "OBJECT_TRUCK":
                        case 3:
                            message.objectTypes[i] = 3;
                            break;
                        case "OBJECT_BUS":
                        case 4:
                            message.objectTypes[i] = 4;
                            break;
                        case "OBJECT_MOTORCYCLE":
                        case 5:
                            message.objectTypes[i] = 5;
                            break;
                        case "OBJECT_BICYCLE":
                        case 6:
                            message.objectTypes[i] = 6;
                            break;
                        case "OBJECT_TRAIN":
                        case 7:
                            message.objectTypes[i] = 7;
                            break;
                        case "OBJECT_PEDESTRIAN":
                        case 8:
                            message.objectTypes[i] = 8;
                            break;
                        case "OBJECT_ANIMAL":
                        case 9:
                            message.objectTypes[i] = 9;
                            break;
                        case "OBJECT_TRAFFIC_LIGHT":
                        case 10:
                            message.objectTypes[i] = 10;
                            break;
                        case "OBJECT_TRAFFIC_SIGN":
                        case 11:
                            message.objectTypes[i] = 11;
                            break;
                        case "OBJECT_TRAFFIC_BARRIER":
                        case 12:
                            message.objectTypes[i] = 12;
                            break;
                        case "OBJECT_TRAFFIC_CONE":
                        case 13:
                            message.objectTypes[i] = 13;
                            break;
                        case "OBJECT_GROUND":
                        case 14:
                            message.objectTypes[i] = 14;
                            break;
                        case "OBJECT_ROAD":
                        case 15:
                            message.objectTypes[i] = 15;
                            break;
                        case "OBJECT_RAIL_TRACK":
                        case 16:
                            message.objectTypes[i] = 16;
                            break;
                        case "OBJECT_SIDEWALK":
                        case 17:
                            message.objectTypes[i] = 17;
                            break;
                        case "OBJECT_CURB":
                        case 18:
                            message.objectTypes[i] = 18;
                            break;
                        case "OBJECT_STATIC_OBJECT":
                        case 19:
                            message.objectTypes[i] = 19;
                            break;
                        case "OBJECT_SIGN":
                        case 20:
                            message.objectTypes[i] = 20;
                            break;
                        case "OBJECT_POLE":
                        case 21:
                            message.objectTypes[i] = 21;
                            break;
                        case "OBJECT_BUILDING":
                        case 22:
                            message.objectTypes[i] = 22;
                            break;
                        case "OBJECT_WALL":
                        case 23:
                            message.objectTypes[i] = 23;
                            break;
                        case "OBJECT_FENCE":
                        case 24:
                            message.objectTypes[i] = 24;
                            break;
                        case "OBJECT_TREE":
                        case 25:
                            message.objectTypes[i] = 25;
                            break;
                        case "OBJECT_VEGETATION":
                        case 26:
                            message.objectTypes[i] = 26;
                            break;
                        }
                }
                return message;
            };

            /**
             * Creates a plain object from a LaserReturn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.LaserReturn
             * @static
             * @param {metamoto.types.LaserReturn} message LaserReturn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaserReturn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.ranges = [];
                    object.intensities = [];
                    object.objectIds = [];
                    object.objectTypes = [];
                }
                if (options.defaults)
                    object.elevationAngle = 0;
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    object.elevationAngle = options.json && !isFinite(message.elevationAngle) ? String(message.elevationAngle) : message.elevationAngle;
                if (message.ranges && message.ranges.length) {
                    object.ranges = [];
                    for (var j = 0; j < message.ranges.length; ++j)
                        object.ranges[j] = options.json && !isFinite(message.ranges[j]) ? String(message.ranges[j]) : message.ranges[j];
                }
                if (message.intensities && message.intensities.length) {
                    object.intensities = [];
                    for (var j = 0; j < message.intensities.length; ++j)
                        object.intensities[j] = options.json && !isFinite(message.intensities[j]) ? String(message.intensities[j]) : message.intensities[j];
                }
                if (message.objectIds && message.objectIds.length) {
                    object.objectIds = [];
                    for (var j = 0; j < message.objectIds.length; ++j)
                        object.objectIds[j] = message.objectIds[j];
                }
                if (message.objectTypes && message.objectTypes.length) {
                    object.objectTypes = [];
                    for (var j = 0; j < message.objectTypes.length; ++j)
                        object.objectTypes[j] = options.enums === String ? $root.metamoto.types.ObjectType[message.objectTypes[j]] : message.objectTypes[j];
                }
                return object;
            };

            /**
             * Converts this LaserReturn to JSON.
             * @function toJSON
             * @memberof metamoto.types.LaserReturn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaserReturn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LaserReturn;
        })();

        types.LaserReturnGroup = (function() {

            /**
             * Properties of a LaserReturnGroup.
             * @memberof metamoto.types
             * @interface ILaserReturnGroup
             * @property {metamoto.types.IPose|null} [pose] LaserReturnGroup pose
             * @property {number|null} [azimuthAngle] LaserReturnGroup azimuthAngle
             * @property {Array.<metamoto.types.ILaserReturn>|null} [returns] LaserReturnGroup returns
             */

            /**
             * Constructs a new LaserReturnGroup.
             * @memberof metamoto.types
             * @classdesc Represents a LaserReturnGroup.
             * @implements ILaserReturnGroup
             * @constructor
             * @param {metamoto.types.ILaserReturnGroup=} [properties] Properties to set
             */
            function LaserReturnGroup(properties) {
                this.returns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaserReturnGroup pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.LaserReturnGroup
             * @instance
             */
            LaserReturnGroup.prototype.pose = null;

            /**
             * LaserReturnGroup azimuthAngle.
             * @member {number} azimuthAngle
             * @memberof metamoto.types.LaserReturnGroup
             * @instance
             */
            LaserReturnGroup.prototype.azimuthAngle = 0;

            /**
             * LaserReturnGroup returns.
             * @member {Array.<metamoto.types.ILaserReturn>} returns
             * @memberof metamoto.types.LaserReturnGroup
             * @instance
             */
            LaserReturnGroup.prototype.returns = $util.emptyArray;

            /**
             * Creates a new LaserReturnGroup instance using the specified properties.
             * @function create
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {metamoto.types.ILaserReturnGroup=} [properties] Properties to set
             * @returns {metamoto.types.LaserReturnGroup} LaserReturnGroup instance
             */
            LaserReturnGroup.create = function create(properties) {
                return new LaserReturnGroup(properties);
            };

            /**
             * Encodes the specified LaserReturnGroup message. Does not implicitly {@link metamoto.types.LaserReturnGroup.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {metamoto.types.ILaserReturnGroup} message LaserReturnGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaserReturnGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.azimuthAngle);
                if (message.returns != null && message.returns.length)
                    for (var i = 0; i < message.returns.length; ++i)
                        $root.metamoto.types.LaserReturn.encode(message.returns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LaserReturnGroup message, length delimited. Does not implicitly {@link metamoto.types.LaserReturnGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {metamoto.types.ILaserReturnGroup} message LaserReturnGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaserReturnGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaserReturnGroup message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.LaserReturnGroup} LaserReturnGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaserReturnGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.LaserReturnGroup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.azimuthAngle = reader.float();
                        break;
                    case 3:
                        if (!(message.returns && message.returns.length))
                            message.returns = [];
                        message.returns.push($root.metamoto.types.LaserReturn.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaserReturnGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.LaserReturnGroup} LaserReturnGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaserReturnGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaserReturnGroup message.
             * @function verify
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaserReturnGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    if (typeof message.azimuthAngle !== "number")
                        return "azimuthAngle: number expected";
                if (message.returns != null && message.hasOwnProperty("returns")) {
                    if (!Array.isArray(message.returns))
                        return "returns: array expected";
                    for (var i = 0; i < message.returns.length; ++i) {
                        var error = $root.metamoto.types.LaserReturn.verify(message.returns[i]);
                        if (error)
                            return "returns." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LaserReturnGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.LaserReturnGroup} LaserReturnGroup
             */
            LaserReturnGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.LaserReturnGroup)
                    return object;
                var message = new $root.metamoto.types.LaserReturnGroup();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.LaserReturnGroup.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.azimuthAngle != null)
                    message.azimuthAngle = Number(object.azimuthAngle);
                if (object.returns) {
                    if (!Array.isArray(object.returns))
                        throw TypeError(".metamoto.types.LaserReturnGroup.returns: array expected");
                    message.returns = [];
                    for (var i = 0; i < object.returns.length; ++i) {
                        if (typeof object.returns[i] !== "object")
                            throw TypeError(".metamoto.types.LaserReturnGroup.returns: object expected");
                        message.returns[i] = $root.metamoto.types.LaserReturn.fromObject(object.returns[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a LaserReturnGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.LaserReturnGroup
             * @static
             * @param {metamoto.types.LaserReturnGroup} message LaserReturnGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaserReturnGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.returns = [];
                if (options.defaults) {
                    object.pose = null;
                    object.azimuthAngle = 0;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    object.azimuthAngle = options.json && !isFinite(message.azimuthAngle) ? String(message.azimuthAngle) : message.azimuthAngle;
                if (message.returns && message.returns.length) {
                    object.returns = [];
                    for (var j = 0; j < message.returns.length; ++j)
                        object.returns[j] = $root.metamoto.types.LaserReturn.toObject(message.returns[j], options);
                }
                return object;
            };

            /**
             * Converts this LaserReturnGroup to JSON.
             * @function toJSON
             * @memberof metamoto.types.LaserReturnGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaserReturnGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LaserReturnGroup;
        })();

        types.NormalDistribution = (function() {

            /**
             * Properties of a NormalDistribution.
             * @memberof metamoto.types
             * @interface INormalDistribution
             * @property {number|null} [mean] NormalDistribution mean
             * @property {number|null} [stdDev] NormalDistribution stdDev
             */

            /**
             * Constructs a new NormalDistribution.
             * @memberof metamoto.types
             * @classdesc Represents a NormalDistribution.
             * @implements INormalDistribution
             * @constructor
             * @param {metamoto.types.INormalDistribution=} [properties] Properties to set
             */
            function NormalDistribution(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NormalDistribution mean.
             * @member {number} mean
             * @memberof metamoto.types.NormalDistribution
             * @instance
             */
            NormalDistribution.prototype.mean = 0;

            /**
             * NormalDistribution stdDev.
             * @member {number} stdDev
             * @memberof metamoto.types.NormalDistribution
             * @instance
             */
            NormalDistribution.prototype.stdDev = 0;

            /**
             * Creates a new NormalDistribution instance using the specified properties.
             * @function create
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {metamoto.types.INormalDistribution=} [properties] Properties to set
             * @returns {metamoto.types.NormalDistribution} NormalDistribution instance
             */
            NormalDistribution.create = function create(properties) {
                return new NormalDistribution(properties);
            };

            /**
             * Encodes the specified NormalDistribution message. Does not implicitly {@link metamoto.types.NormalDistribution.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {metamoto.types.INormalDistribution} message NormalDistribution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NormalDistribution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mean != null && message.hasOwnProperty("mean"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.mean);
                if (message.stdDev != null && message.hasOwnProperty("stdDev"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.stdDev);
                return writer;
            };

            /**
             * Encodes the specified NormalDistribution message, length delimited. Does not implicitly {@link metamoto.types.NormalDistribution.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {metamoto.types.INormalDistribution} message NormalDistribution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NormalDistribution.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NormalDistribution message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.NormalDistribution} NormalDistribution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NormalDistribution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.NormalDistribution();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mean = reader.double();
                        break;
                    case 2:
                        message.stdDev = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NormalDistribution message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.NormalDistribution} NormalDistribution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NormalDistribution.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NormalDistribution message.
             * @function verify
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NormalDistribution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mean != null && message.hasOwnProperty("mean"))
                    if (typeof message.mean !== "number")
                        return "mean: number expected";
                if (message.stdDev != null && message.hasOwnProperty("stdDev"))
                    if (typeof message.stdDev !== "number")
                        return "stdDev: number expected";
                return null;
            };

            /**
             * Creates a NormalDistribution message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.NormalDistribution} NormalDistribution
             */
            NormalDistribution.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.NormalDistribution)
                    return object;
                var message = new $root.metamoto.types.NormalDistribution();
                if (object.mean != null)
                    message.mean = Number(object.mean);
                if (object.stdDev != null)
                    message.stdDev = Number(object.stdDev);
                return message;
            };

            /**
             * Creates a plain object from a NormalDistribution message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.NormalDistribution
             * @static
             * @param {metamoto.types.NormalDistribution} message NormalDistribution
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NormalDistribution.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mean = 0;
                    object.stdDev = 0;
                }
                if (message.mean != null && message.hasOwnProperty("mean"))
                    object.mean = options.json && !isFinite(message.mean) ? String(message.mean) : message.mean;
                if (message.stdDev != null && message.hasOwnProperty("stdDev"))
                    object.stdDev = options.json && !isFinite(message.stdDev) ? String(message.stdDev) : message.stdDev;
                return object;
            };

            /**
             * Converts this NormalDistribution to JSON.
             * @function toJSON
             * @memberof metamoto.types.NormalDistribution
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NormalDistribution.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NormalDistribution;
        })();

        types.Pedestrian = (function() {

            /**
             * Properties of a Pedestrian.
             * @memberof metamoto.types
             * @interface IPedestrian
             * @property {string|null} [id] Pedestrian id
             * @property {metamoto.types.IPose|null} [pose] Pedestrian pose
             * @property {metamoto.types.IVelocity|null} [velocity] Pedestrian velocity
             * @property {metamoto.types.IAcceleration|null} [acceleration] Pedestrian acceleration
             * @property {metamoto.types.IShape|null} [shape] Pedestrian shape
             * @property {metamoto.types.Pedestrian.Type|null} [type] Pedestrian type
             */

            /**
             * Constructs a new Pedestrian.
             * @memberof metamoto.types
             * @classdesc Represents a Pedestrian.
             * @implements IPedestrian
             * @constructor
             * @param {metamoto.types.IPedestrian=} [properties] Properties to set
             */
            function Pedestrian(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pedestrian id.
             * @member {string} id
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.id = "";

            /**
             * Pedestrian pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.pose = null;

            /**
             * Pedestrian velocity.
             * @member {metamoto.types.IVelocity|null|undefined} velocity
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.velocity = null;

            /**
             * Pedestrian acceleration.
             * @member {metamoto.types.IAcceleration|null|undefined} acceleration
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.acceleration = null;

            /**
             * Pedestrian shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.shape = null;

            /**
             * Pedestrian type.
             * @member {metamoto.types.Pedestrian.Type} type
             * @memberof metamoto.types.Pedestrian
             * @instance
             */
            Pedestrian.prototype.type = 0;

            /**
             * Creates a new Pedestrian instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {metamoto.types.IPedestrian=} [properties] Properties to set
             * @returns {metamoto.types.Pedestrian} Pedestrian instance
             */
            Pedestrian.create = function create(properties) {
                return new Pedestrian(properties);
            };

            /**
             * Encodes the specified Pedestrian message. Does not implicitly {@link metamoto.types.Pedestrian.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {metamoto.types.IPedestrian} message Pedestrian message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pedestrian.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    $root.metamoto.types.Velocity.encode(message.velocity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.metamoto.types.Acceleration.encode(message.acceleration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified Pedestrian message, length delimited. Does not implicitly {@link metamoto.types.Pedestrian.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {metamoto.types.IPedestrian} message Pedestrian message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pedestrian.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pedestrian message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Pedestrian} Pedestrian
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pedestrian.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Pedestrian();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.velocity = $root.metamoto.types.Velocity.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.acceleration = $root.metamoto.types.Acceleration.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pedestrian message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Pedestrian} Pedestrian
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pedestrian.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pedestrian message.
             * @function verify
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pedestrian.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    var error = $root.metamoto.types.Velocity.verify(message.velocity);
                    if (error)
                        return "velocity." + error;
                }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.metamoto.types.Acceleration.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Pedestrian message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Pedestrian} Pedestrian
             */
            Pedestrian.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Pedestrian)
                    return object;
                var message = new $root.metamoto.types.Pedestrian();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.Pedestrian.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.velocity != null) {
                    if (typeof object.velocity !== "object")
                        throw TypeError(".metamoto.types.Pedestrian.velocity: object expected");
                    message.velocity = $root.metamoto.types.Velocity.fromObject(object.velocity);
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.types.Pedestrian.acceleration: object expected");
                    message.acceleration = $root.metamoto.types.Acceleration.fromObject(object.acceleration);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.Pedestrian.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "ADULT":
                case 2:
                    message.type = 2;
                    break;
                case "CHILD":
                case 3:
                    message.type = 3;
                    break;
                case "ANIMAL":
                case 4:
                    message.type = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Pedestrian message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Pedestrian
             * @static
             * @param {metamoto.types.Pedestrian} message Pedestrian
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pedestrian.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.pose = null;
                    object.velocity = null;
                    object.acceleration = null;
                    object.shape = null;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = $root.metamoto.types.Velocity.toObject(message.velocity, options);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.metamoto.types.Acceleration.toObject(message.acceleration, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Pedestrian.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Pedestrian to JSON.
             * @function toJSON
             * @memberof metamoto.types.Pedestrian
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pedestrian.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Pedestrian.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} ADULT=2 ADULT value
             * @property {number} CHILD=3 CHILD value
             * @property {number} ANIMAL=4 ANIMAL value
             */
            Pedestrian.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "ADULT"] = 2;
                values[valuesById[3] = "CHILD"] = 3;
                values[valuesById[4] = "ANIMAL"] = 4;
                return values;
            })();

            return Pedestrian;
        })();

        types.PedestrianLibrary = (function() {

            /**
             * Properties of a PedestrianLibrary.
             * @memberof metamoto.types
             * @interface IPedestrianLibrary
             * @property {Array.<metamoto.types.PedestrianLibrary.IPedestrianTemplate>|null} [pedestrians] PedestrianLibrary pedestrians
             */

            /**
             * Constructs a new PedestrianLibrary.
             * @memberof metamoto.types
             * @classdesc Represents a PedestrianLibrary.
             * @implements IPedestrianLibrary
             * @constructor
             * @param {metamoto.types.IPedestrianLibrary=} [properties] Properties to set
             */
            function PedestrianLibrary(properties) {
                this.pedestrians = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PedestrianLibrary pedestrians.
             * @member {Array.<metamoto.types.PedestrianLibrary.IPedestrianTemplate>} pedestrians
             * @memberof metamoto.types.PedestrianLibrary
             * @instance
             */
            PedestrianLibrary.prototype.pedestrians = $util.emptyArray;

            /**
             * Creates a new PedestrianLibrary instance using the specified properties.
             * @function create
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {metamoto.types.IPedestrianLibrary=} [properties] Properties to set
             * @returns {metamoto.types.PedestrianLibrary} PedestrianLibrary instance
             */
            PedestrianLibrary.create = function create(properties) {
                return new PedestrianLibrary(properties);
            };

            /**
             * Encodes the specified PedestrianLibrary message. Does not implicitly {@link metamoto.types.PedestrianLibrary.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {metamoto.types.IPedestrianLibrary} message PedestrianLibrary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianLibrary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pedestrians != null && message.pedestrians.length)
                    for (var i = 0; i < message.pedestrians.length; ++i)
                        $root.metamoto.types.PedestrianLibrary.PedestrianTemplate.encode(message.pedestrians[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PedestrianLibrary message, length delimited. Does not implicitly {@link metamoto.types.PedestrianLibrary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {metamoto.types.IPedestrianLibrary} message PedestrianLibrary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianLibrary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PedestrianLibrary message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.PedestrianLibrary} PedestrianLibrary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianLibrary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PedestrianLibrary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pedestrians && message.pedestrians.length))
                            message.pedestrians = [];
                        message.pedestrians.push($root.metamoto.types.PedestrianLibrary.PedestrianTemplate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PedestrianLibrary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.PedestrianLibrary} PedestrianLibrary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianLibrary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PedestrianLibrary message.
             * @function verify
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PedestrianLibrary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians")) {
                    if (!Array.isArray(message.pedestrians))
                        return "pedestrians: array expected";
                    for (var i = 0; i < message.pedestrians.length; ++i) {
                        var error = $root.metamoto.types.PedestrianLibrary.PedestrianTemplate.verify(message.pedestrians[i]);
                        if (error)
                            return "pedestrians." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PedestrianLibrary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.PedestrianLibrary} PedestrianLibrary
             */
            PedestrianLibrary.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.PedestrianLibrary)
                    return object;
                var message = new $root.metamoto.types.PedestrianLibrary();
                if (object.pedestrians) {
                    if (!Array.isArray(object.pedestrians))
                        throw TypeError(".metamoto.types.PedestrianLibrary.pedestrians: array expected");
                    message.pedestrians = [];
                    for (var i = 0; i < object.pedestrians.length; ++i) {
                        if (typeof object.pedestrians[i] !== "object")
                            throw TypeError(".metamoto.types.PedestrianLibrary.pedestrians: object expected");
                        message.pedestrians[i] = $root.metamoto.types.PedestrianLibrary.PedestrianTemplate.fromObject(object.pedestrians[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PedestrianLibrary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.PedestrianLibrary
             * @static
             * @param {metamoto.types.PedestrianLibrary} message PedestrianLibrary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PedestrianLibrary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pedestrians = [];
                if (message.pedestrians && message.pedestrians.length) {
                    object.pedestrians = [];
                    for (var j = 0; j < message.pedestrians.length; ++j)
                        object.pedestrians[j] = $root.metamoto.types.PedestrianLibrary.PedestrianTemplate.toObject(message.pedestrians[j], options);
                }
                return object;
            };

            /**
             * Converts this PedestrianLibrary to JSON.
             * @function toJSON
             * @memberof metamoto.types.PedestrianLibrary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PedestrianLibrary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PedestrianLibrary.PedestrianTemplate = (function() {

                /**
                 * Properties of a PedestrianTemplate.
                 * @memberof metamoto.types.PedestrianLibrary
                 * @interface IPedestrianTemplate
                 * @property {string|null} [name] PedestrianTemplate name
                 * @property {Array.<string>|null} [otherNames] PedestrianTemplate otherNames
                 * @property {string|null} [prefab] PedestrianTemplate prefab
                 * @property {metamoto.types.Pedestrian.Type|null} [type] PedestrianTemplate type
                 * @property {number|null} [weight] PedestrianTemplate weight
                 */

                /**
                 * Constructs a new PedestrianTemplate.
                 * @memberof metamoto.types.PedestrianLibrary
                 * @classdesc Represents a PedestrianTemplate.
                 * @implements IPedestrianTemplate
                 * @constructor
                 * @param {metamoto.types.PedestrianLibrary.IPedestrianTemplate=} [properties] Properties to set
                 */
                function PedestrianTemplate(properties) {
                    this.otherNames = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PedestrianTemplate name.
                 * @member {string} name
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 */
                PedestrianTemplate.prototype.name = "";

                /**
                 * PedestrianTemplate otherNames.
                 * @member {Array.<string>} otherNames
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 */
                PedestrianTemplate.prototype.otherNames = $util.emptyArray;

                /**
                 * PedestrianTemplate prefab.
                 * @member {string} prefab
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 */
                PedestrianTemplate.prototype.prefab = "";

                /**
                 * PedestrianTemplate type.
                 * @member {metamoto.types.Pedestrian.Type} type
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 */
                PedestrianTemplate.prototype.type = 0;

                /**
                 * PedestrianTemplate weight.
                 * @member {number} weight
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 */
                PedestrianTemplate.prototype.weight = 0;

                /**
                 * Creates a new PedestrianTemplate instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {metamoto.types.PedestrianLibrary.IPedestrianTemplate=} [properties] Properties to set
                 * @returns {metamoto.types.PedestrianLibrary.PedestrianTemplate} PedestrianTemplate instance
                 */
                PedestrianTemplate.create = function create(properties) {
                    return new PedestrianTemplate(properties);
                };

                /**
                 * Encodes the specified PedestrianTemplate message. Does not implicitly {@link metamoto.types.PedestrianLibrary.PedestrianTemplate.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {metamoto.types.PedestrianLibrary.IPedestrianTemplate} message PedestrianTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PedestrianTemplate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.otherNames != null && message.otherNames.length)
                        for (var i = 0; i < message.otherNames.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.otherNames[i]);
                    if (message.prefab != null && message.hasOwnProperty("prefab"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.prefab);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                    if (message.weight != null && message.hasOwnProperty("weight"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.weight);
                    return writer;
                };

                /**
                 * Encodes the specified PedestrianTemplate message, length delimited. Does not implicitly {@link metamoto.types.PedestrianLibrary.PedestrianTemplate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {metamoto.types.PedestrianLibrary.IPedestrianTemplate} message PedestrianTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PedestrianTemplate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PedestrianTemplate message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.PedestrianLibrary.PedestrianTemplate} PedestrianTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PedestrianTemplate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PedestrianLibrary.PedestrianTemplate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.otherNames && message.otherNames.length))
                                message.otherNames = [];
                            message.otherNames.push(reader.string());
                            break;
                        case 3:
                            message.prefab = reader.string();
                            break;
                        case 4:
                            message.type = reader.int32();
                            break;
                        case 5:
                            message.weight = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PedestrianTemplate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.PedestrianLibrary.PedestrianTemplate} PedestrianTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PedestrianTemplate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PedestrianTemplate message.
                 * @function verify
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PedestrianTemplate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.otherNames != null && message.hasOwnProperty("otherNames")) {
                        if (!Array.isArray(message.otherNames))
                            return "otherNames: array expected";
                        for (var i = 0; i < message.otherNames.length; ++i)
                            if (!$util.isString(message.otherNames[i]))
                                return "otherNames: string[] expected";
                    }
                    if (message.prefab != null && message.hasOwnProperty("prefab"))
                        if (!$util.isString(message.prefab))
                            return "prefab: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.weight != null && message.hasOwnProperty("weight"))
                        if (typeof message.weight !== "number")
                            return "weight: number expected";
                    return null;
                };

                /**
                 * Creates a PedestrianTemplate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.PedestrianLibrary.PedestrianTemplate} PedestrianTemplate
                 */
                PedestrianTemplate.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.PedestrianLibrary.PedestrianTemplate)
                        return object;
                    var message = new $root.metamoto.types.PedestrianLibrary.PedestrianTemplate();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.otherNames) {
                        if (!Array.isArray(object.otherNames))
                            throw TypeError(".metamoto.types.PedestrianLibrary.PedestrianTemplate.otherNames: array expected");
                        message.otherNames = [];
                        for (var i = 0; i < object.otherNames.length; ++i)
                            message.otherNames[i] = String(object.otherNames[i]);
                    }
                    if (object.prefab != null)
                        message.prefab = String(object.prefab);
                    switch (object.type) {
                    case "UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "OTHER":
                    case 1:
                        message.type = 1;
                        break;
                    case "ADULT":
                    case 2:
                        message.type = 2;
                        break;
                    case "CHILD":
                    case 3:
                        message.type = 3;
                        break;
                    case "ANIMAL":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.weight != null)
                        message.weight = Number(object.weight);
                    return message;
                };

                /**
                 * Creates a plain object from a PedestrianTemplate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @static
                 * @param {metamoto.types.PedestrianLibrary.PedestrianTemplate} message PedestrianTemplate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PedestrianTemplate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.otherNames = [];
                    if (options.defaults) {
                        object.name = "";
                        object.prefab = "";
                        object.type = options.enums === String ? "UNKNOWN" : 0;
                        object.weight = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.otherNames && message.otherNames.length) {
                        object.otherNames = [];
                        for (var j = 0; j < message.otherNames.length; ++j)
                            object.otherNames[j] = message.otherNames[j];
                    }
                    if (message.prefab != null && message.hasOwnProperty("prefab"))
                        object.prefab = message.prefab;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.metamoto.types.Pedestrian.Type[message.type] : message.type;
                    if (message.weight != null && message.hasOwnProperty("weight"))
                        object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                    return object;
                };

                /**
                 * Converts this PedestrianTemplate to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.PedestrianLibrary.PedestrianTemplate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PedestrianTemplate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PedestrianTemplate;
            })();

            return PedestrianLibrary;
        })();

        types.PerceptionObject = (function() {

            /**
             * Properties of a PerceptionObject.
             * @memberof metamoto.types
             * @interface IPerceptionObject
             * @property {number|null} [objectId] PerceptionObject objectId
             * @property {metamoto.types.ObjectType|null} [objectType] PerceptionObject objectType
             * @property {metamoto.types.IShape|null} [shape] PerceptionObject shape
             * @property {number|null} [trackingTime] PerceptionObject trackingTime
             * @property {metamoto.types.IGlobalFrame|null} [globalFrame] PerceptionObject globalFrame
             * @property {metamoto.types.ILocalFrame|null} [localFrame] PerceptionObject localFrame
             * @property {metamoto.types.Vehicle.LightState|null} [headLights] PerceptionObject headLights
             * @property {metamoto.types.Vehicle.LightState|null} [reverseLights] PerceptionObject reverseLights
             * @property {metamoto.types.Vehicle.LightState|null} [brakeLights] PerceptionObject brakeLights
             * @property {metamoto.types.Vehicle.SignalLightState|null} [signalLights] PerceptionObject signalLights
             * @property {Array.<metamoto.types.PerceptionObject.ITrafficLightBulb>|null} [trafficLightBulbs] PerceptionObject trafficLightBulbs
             */

            /**
             * Constructs a new PerceptionObject.
             * @memberof metamoto.types
             * @classdesc Represents a PerceptionObject.
             * @implements IPerceptionObject
             * @constructor
             * @param {metamoto.types.IPerceptionObject=} [properties] Properties to set
             */
            function PerceptionObject(properties) {
                this.trafficLightBulbs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PerceptionObject objectId.
             * @member {number} objectId
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.objectId = 0;

            /**
             * PerceptionObject objectType.
             * @member {metamoto.types.ObjectType} objectType
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.objectType = 0;

            /**
             * PerceptionObject shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.shape = null;

            /**
             * PerceptionObject trackingTime.
             * @member {number} trackingTime
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.trackingTime = 0;

            /**
             * PerceptionObject globalFrame.
             * @member {metamoto.types.IGlobalFrame|null|undefined} globalFrame
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.globalFrame = null;

            /**
             * PerceptionObject localFrame.
             * @member {metamoto.types.ILocalFrame|null|undefined} localFrame
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.localFrame = null;

            /**
             * PerceptionObject headLights.
             * @member {metamoto.types.Vehicle.LightState} headLights
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.headLights = 0;

            /**
             * PerceptionObject reverseLights.
             * @member {metamoto.types.Vehicle.LightState} reverseLights
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.reverseLights = 0;

            /**
             * PerceptionObject brakeLights.
             * @member {metamoto.types.Vehicle.LightState} brakeLights
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.brakeLights = 0;

            /**
             * PerceptionObject signalLights.
             * @member {metamoto.types.Vehicle.SignalLightState} signalLights
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.signalLights = 0;

            /**
             * PerceptionObject trafficLightBulbs.
             * @member {Array.<metamoto.types.PerceptionObject.ITrafficLightBulb>} trafficLightBulbs
             * @memberof metamoto.types.PerceptionObject
             * @instance
             */
            PerceptionObject.prototype.trafficLightBulbs = $util.emptyArray;

            /**
             * Creates a new PerceptionObject instance using the specified properties.
             * @function create
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {metamoto.types.IPerceptionObject=} [properties] Properties to set
             * @returns {metamoto.types.PerceptionObject} PerceptionObject instance
             */
            PerceptionObject.create = function create(properties) {
                return new PerceptionObject(properties);
            };

            /**
             * Encodes the specified PerceptionObject message. Does not implicitly {@link metamoto.types.PerceptionObject.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {metamoto.types.IPerceptionObject} message PerceptionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerceptionObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.objectId);
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.objectType);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.trackingTime != null && message.hasOwnProperty("trackingTime"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.trackingTime);
                if (message.globalFrame != null && message.hasOwnProperty("globalFrame"))
                    $root.metamoto.types.GlobalFrame.encode(message.globalFrame, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.localFrame != null && message.hasOwnProperty("localFrame"))
                    $root.metamoto.types.LocalFrame.encode(message.localFrame, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.headLights);
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.reverseLights);
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.brakeLights);
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.signalLights);
                if (message.trafficLightBulbs != null && message.trafficLightBulbs.length)
                    for (var i = 0; i < message.trafficLightBulbs.length; ++i)
                        $root.metamoto.types.PerceptionObject.TrafficLightBulb.encode(message.trafficLightBulbs[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PerceptionObject message, length delimited. Does not implicitly {@link metamoto.types.PerceptionObject.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {metamoto.types.IPerceptionObject} message PerceptionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerceptionObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PerceptionObject message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.PerceptionObject} PerceptionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerceptionObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PerceptionObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.objectId = reader.uint32();
                        break;
                    case 2:
                        message.objectType = reader.int32();
                        break;
                    case 3:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.trackingTime = reader.double();
                        break;
                    case 5:
                        message.globalFrame = $root.metamoto.types.GlobalFrame.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.localFrame = $root.metamoto.types.LocalFrame.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.headLights = reader.int32();
                        break;
                    case 11:
                        message.reverseLights = reader.int32();
                        break;
                    case 12:
                        message.brakeLights = reader.int32();
                        break;
                    case 13:
                        message.signalLights = reader.int32();
                        break;
                    case 14:
                        if (!(message.trafficLightBulbs && message.trafficLightBulbs.length))
                            message.trafficLightBulbs = [];
                        message.trafficLightBulbs.push($root.metamoto.types.PerceptionObject.TrafficLightBulb.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PerceptionObject message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.PerceptionObject} PerceptionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerceptionObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PerceptionObject message.
             * @function verify
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PerceptionObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    if (!$util.isInteger(message.objectId))
                        return "objectId: integer expected";
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    switch (message.objectType) {
                    default:
                        return "objectType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.trackingTime != null && message.hasOwnProperty("trackingTime"))
                    if (typeof message.trackingTime !== "number")
                        return "trackingTime: number expected";
                if (message.globalFrame != null && message.hasOwnProperty("globalFrame")) {
                    var error = $root.metamoto.types.GlobalFrame.verify(message.globalFrame);
                    if (error)
                        return "globalFrame." + error;
                }
                if (message.localFrame != null && message.hasOwnProperty("localFrame")) {
                    var error = $root.metamoto.types.LocalFrame.verify(message.localFrame);
                    if (error)
                        return "localFrame." + error;
                }
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    switch (message.headLights) {
                    default:
                        return "headLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    switch (message.reverseLights) {
                    default:
                        return "reverseLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    switch (message.brakeLights) {
                    default:
                        return "brakeLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    switch (message.signalLights) {
                    default:
                        return "signalLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.trafficLightBulbs != null && message.hasOwnProperty("trafficLightBulbs")) {
                    if (!Array.isArray(message.trafficLightBulbs))
                        return "trafficLightBulbs: array expected";
                    for (var i = 0; i < message.trafficLightBulbs.length; ++i) {
                        var error = $root.metamoto.types.PerceptionObject.TrafficLightBulb.verify(message.trafficLightBulbs[i]);
                        if (error)
                            return "trafficLightBulbs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PerceptionObject message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.PerceptionObject} PerceptionObject
             */
            PerceptionObject.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.PerceptionObject)
                    return object;
                var message = new $root.metamoto.types.PerceptionObject();
                if (object.objectId != null)
                    message.objectId = object.objectId >>> 0;
                switch (object.objectType) {
                case "OBJECT_UNKNOWN":
                case 0:
                    message.objectType = 0;
                    break;
                case "OBJECT_OTHER":
                case 1:
                    message.objectType = 1;
                    break;
                case "OBJECT_CAR":
                case 2:
                    message.objectType = 2;
                    break;
                case "OBJECT_TRUCK":
                case 3:
                    message.objectType = 3;
                    break;
                case "OBJECT_BUS":
                case 4:
                    message.objectType = 4;
                    break;
                case "OBJECT_MOTORCYCLE":
                case 5:
                    message.objectType = 5;
                    break;
                case "OBJECT_BICYCLE":
                case 6:
                    message.objectType = 6;
                    break;
                case "OBJECT_TRAIN":
                case 7:
                    message.objectType = 7;
                    break;
                case "OBJECT_PEDESTRIAN":
                case 8:
                    message.objectType = 8;
                    break;
                case "OBJECT_ANIMAL":
                case 9:
                    message.objectType = 9;
                    break;
                case "OBJECT_TRAFFIC_LIGHT":
                case 10:
                    message.objectType = 10;
                    break;
                case "OBJECT_TRAFFIC_SIGN":
                case 11:
                    message.objectType = 11;
                    break;
                case "OBJECT_TRAFFIC_BARRIER":
                case 12:
                    message.objectType = 12;
                    break;
                case "OBJECT_TRAFFIC_CONE":
                case 13:
                    message.objectType = 13;
                    break;
                case "OBJECT_GROUND":
                case 14:
                    message.objectType = 14;
                    break;
                case "OBJECT_ROAD":
                case 15:
                    message.objectType = 15;
                    break;
                case "OBJECT_RAIL_TRACK":
                case 16:
                    message.objectType = 16;
                    break;
                case "OBJECT_SIDEWALK":
                case 17:
                    message.objectType = 17;
                    break;
                case "OBJECT_CURB":
                case 18:
                    message.objectType = 18;
                    break;
                case "OBJECT_STATIC_OBJECT":
                case 19:
                    message.objectType = 19;
                    break;
                case "OBJECT_SIGN":
                case 20:
                    message.objectType = 20;
                    break;
                case "OBJECT_POLE":
                case 21:
                    message.objectType = 21;
                    break;
                case "OBJECT_BUILDING":
                case 22:
                    message.objectType = 22;
                    break;
                case "OBJECT_WALL":
                case 23:
                    message.objectType = 23;
                    break;
                case "OBJECT_FENCE":
                case 24:
                    message.objectType = 24;
                    break;
                case "OBJECT_TREE":
                case 25:
                    message.objectType = 25;
                    break;
                case "OBJECT_VEGETATION":
                case 26:
                    message.objectType = 26;
                    break;
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.PerceptionObject.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                if (object.trackingTime != null)
                    message.trackingTime = Number(object.trackingTime);
                if (object.globalFrame != null) {
                    if (typeof object.globalFrame !== "object")
                        throw TypeError(".metamoto.types.PerceptionObject.globalFrame: object expected");
                    message.globalFrame = $root.metamoto.types.GlobalFrame.fromObject(object.globalFrame);
                }
                if (object.localFrame != null) {
                    if (typeof object.localFrame !== "object")
                        throw TypeError(".metamoto.types.PerceptionObject.localFrame: object expected");
                    message.localFrame = $root.metamoto.types.LocalFrame.fromObject(object.localFrame);
                }
                switch (object.headLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.headLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.headLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.headLights = 2;
                    break;
                case "ON":
                case 3:
                    message.headLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.headLights = 4;
                    break;
                }
                switch (object.reverseLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.reverseLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.reverseLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.reverseLights = 2;
                    break;
                case "ON":
                case 3:
                    message.reverseLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.reverseLights = 4;
                    break;
                }
                switch (object.brakeLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.brakeLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.brakeLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.brakeLights = 2;
                    break;
                case "ON":
                case 3:
                    message.brakeLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.brakeLights = 4;
                    break;
                }
                switch (object.signalLights) {
                case "SIGNAL_LIGHT_STATE_UNKNOWN":
                case 0:
                    message.signalLights = 0;
                    break;
                case "SIGNAL_LIGHT_STATE_OTHER":
                case 1:
                    message.signalLights = 1;
                    break;
                case "SIGNAL_LIGHT_STATE_OFF":
                case 2:
                    message.signalLights = 2;
                    break;
                case "LEFT":
                case 3:
                    message.signalLights = 3;
                    break;
                case "RIGHT":
                case 4:
                    message.signalLights = 4;
                    break;
                case "HAZARD":
                case 5:
                    message.signalLights = 5;
                    break;
                }
                if (object.trafficLightBulbs) {
                    if (!Array.isArray(object.trafficLightBulbs))
                        throw TypeError(".metamoto.types.PerceptionObject.trafficLightBulbs: array expected");
                    message.trafficLightBulbs = [];
                    for (var i = 0; i < object.trafficLightBulbs.length; ++i) {
                        if (typeof object.trafficLightBulbs[i] !== "object")
                            throw TypeError(".metamoto.types.PerceptionObject.trafficLightBulbs: object expected");
                        message.trafficLightBulbs[i] = $root.metamoto.types.PerceptionObject.TrafficLightBulb.fromObject(object.trafficLightBulbs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PerceptionObject message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.PerceptionObject
             * @static
             * @param {metamoto.types.PerceptionObject} message PerceptionObject
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PerceptionObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.trafficLightBulbs = [];
                if (options.defaults) {
                    object.objectId = 0;
                    object.objectType = options.enums === String ? "OBJECT_UNKNOWN" : 0;
                    object.shape = null;
                    object.trackingTime = 0;
                    object.globalFrame = null;
                    object.localFrame = null;
                    object.headLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.reverseLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.brakeLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.signalLights = options.enums === String ? "SIGNAL_LIGHT_STATE_UNKNOWN" : 0;
                }
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    object.objectId = message.objectId;
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    object.objectType = options.enums === String ? $root.metamoto.types.ObjectType[message.objectType] : message.objectType;
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.trackingTime != null && message.hasOwnProperty("trackingTime"))
                    object.trackingTime = options.json && !isFinite(message.trackingTime) ? String(message.trackingTime) : message.trackingTime;
                if (message.globalFrame != null && message.hasOwnProperty("globalFrame"))
                    object.globalFrame = $root.metamoto.types.GlobalFrame.toObject(message.globalFrame, options);
                if (message.localFrame != null && message.hasOwnProperty("localFrame"))
                    object.localFrame = $root.metamoto.types.LocalFrame.toObject(message.localFrame, options);
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    object.headLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.headLights] : message.headLights;
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    object.reverseLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.reverseLights] : message.reverseLights;
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    object.brakeLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.brakeLights] : message.brakeLights;
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    object.signalLights = options.enums === String ? $root.metamoto.types.Vehicle.SignalLightState[message.signalLights] : message.signalLights;
                if (message.trafficLightBulbs && message.trafficLightBulbs.length) {
                    object.trafficLightBulbs = [];
                    for (var j = 0; j < message.trafficLightBulbs.length; ++j)
                        object.trafficLightBulbs[j] = $root.metamoto.types.PerceptionObject.TrafficLightBulb.toObject(message.trafficLightBulbs[j], options);
                }
                return object;
            };

            /**
             * Converts this PerceptionObject to JSON.
             * @function toJSON
             * @memberof metamoto.types.PerceptionObject
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PerceptionObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PerceptionObject.TrafficLightBulb = (function() {

                /**
                 * Properties of a TrafficLightBulb.
                 * @memberof metamoto.types.PerceptionObject
                 * @interface ITrafficLightBulb
                 * @property {metamoto.types.SignalConfiguration.Signal.IBulbType|null} [type] TrafficLightBulb type
                 * @property {metamoto.types.SignalConfiguration.Signal.IBulbState|null} [state] TrafficLightBulb state
                 */

                /**
                 * Constructs a new TrafficLightBulb.
                 * @memberof metamoto.types.PerceptionObject
                 * @classdesc Represents a TrafficLightBulb.
                 * @implements ITrafficLightBulb
                 * @constructor
                 * @param {metamoto.types.PerceptionObject.ITrafficLightBulb=} [properties] Properties to set
                 */
                function TrafficLightBulb(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrafficLightBulb type.
                 * @member {metamoto.types.SignalConfiguration.Signal.IBulbType|null|undefined} type
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @instance
                 */
                TrafficLightBulb.prototype.type = null;

                /**
                 * TrafficLightBulb state.
                 * @member {metamoto.types.SignalConfiguration.Signal.IBulbState|null|undefined} state
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @instance
                 */
                TrafficLightBulb.prototype.state = null;

                /**
                 * Creates a new TrafficLightBulb instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {metamoto.types.PerceptionObject.ITrafficLightBulb=} [properties] Properties to set
                 * @returns {metamoto.types.PerceptionObject.TrafficLightBulb} TrafficLightBulb instance
                 */
                TrafficLightBulb.create = function create(properties) {
                    return new TrafficLightBulb(properties);
                };

                /**
                 * Encodes the specified TrafficLightBulb message. Does not implicitly {@link metamoto.types.PerceptionObject.TrafficLightBulb.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {metamoto.types.PerceptionObject.ITrafficLightBulb} message TrafficLightBulb message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficLightBulb.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.metamoto.types.SignalConfiguration.Signal.BulbType.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        $root.metamoto.types.SignalConfiguration.Signal.BulbState.encode(message.state, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TrafficLightBulb message, length delimited. Does not implicitly {@link metamoto.types.PerceptionObject.TrafficLightBulb.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {metamoto.types.PerceptionObject.ITrafficLightBulb} message TrafficLightBulb message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficLightBulb.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrafficLightBulb message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.PerceptionObject.TrafficLightBulb} TrafficLightBulb
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficLightBulb.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PerceptionObject.TrafficLightBulb();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = $root.metamoto.types.SignalConfiguration.Signal.BulbType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.state = $root.metamoto.types.SignalConfiguration.Signal.BulbState.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrafficLightBulb message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.PerceptionObject.TrafficLightBulb} TrafficLightBulb
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficLightBulb.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrafficLightBulb message.
                 * @function verify
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrafficLightBulb.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.metamoto.types.SignalConfiguration.Signal.BulbType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    if (message.state != null && message.hasOwnProperty("state")) {
                        var error = $root.metamoto.types.SignalConfiguration.Signal.BulbState.verify(message.state);
                        if (error)
                            return "state." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TrafficLightBulb message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.PerceptionObject.TrafficLightBulb} TrafficLightBulb
                 */
                TrafficLightBulb.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.PerceptionObject.TrafficLightBulb)
                        return object;
                    var message = new $root.metamoto.types.PerceptionObject.TrafficLightBulb();
                    if (object.type != null) {
                        if (typeof object.type !== "object")
                            throw TypeError(".metamoto.types.PerceptionObject.TrafficLightBulb.type: object expected");
                        message.type = $root.metamoto.types.SignalConfiguration.Signal.BulbType.fromObject(object.type);
                    }
                    if (object.state != null) {
                        if (typeof object.state !== "object")
                            throw TypeError(".metamoto.types.PerceptionObject.TrafficLightBulb.state: object expected");
                        message.state = $root.metamoto.types.SignalConfiguration.Signal.BulbState.fromObject(object.state);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TrafficLightBulb message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @static
                 * @param {metamoto.types.PerceptionObject.TrafficLightBulb} message TrafficLightBulb
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrafficLightBulb.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = null;
                        object.state = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = $root.metamoto.types.SignalConfiguration.Signal.BulbType.toObject(message.type, options);
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = $root.metamoto.types.SignalConfiguration.Signal.BulbState.toObject(message.state, options);
                    return object;
                };

                /**
                 * Converts this TrafficLightBulb to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.PerceptionObject.TrafficLightBulb
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrafficLightBulb.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TrafficLightBulb;
            })();

            return PerceptionObject;
        })();

        types.LocalFrame = (function() {

            /**
             * Properties of a LocalFrame.
             * @memberof metamoto.types
             * @interface ILocalFrame
             * @property {number|null} [range] LocalFrame range
             * @property {number|null} [azimuthAngle] LocalFrame azimuthAngle
             * @property {number|null} [elevationAngle] LocalFrame elevationAngle
             * @property {number|null} [radialSpeed] LocalFrame radialSpeed
             * @property {number|null} [crossSpeed] LocalFrame crossSpeed
             */

            /**
             * Constructs a new LocalFrame.
             * @memberof metamoto.types
             * @classdesc Represents a LocalFrame.
             * @implements ILocalFrame
             * @constructor
             * @param {metamoto.types.ILocalFrame=} [properties] Properties to set
             */
            function LocalFrame(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocalFrame range.
             * @member {number} range
             * @memberof metamoto.types.LocalFrame
             * @instance
             */
            LocalFrame.prototype.range = 0;

            /**
             * LocalFrame azimuthAngle.
             * @member {number} azimuthAngle
             * @memberof metamoto.types.LocalFrame
             * @instance
             */
            LocalFrame.prototype.azimuthAngle = 0;

            /**
             * LocalFrame elevationAngle.
             * @member {number} elevationAngle
             * @memberof metamoto.types.LocalFrame
             * @instance
             */
            LocalFrame.prototype.elevationAngle = 0;

            /**
             * LocalFrame radialSpeed.
             * @member {number} radialSpeed
             * @memberof metamoto.types.LocalFrame
             * @instance
             */
            LocalFrame.prototype.radialSpeed = 0;

            /**
             * LocalFrame crossSpeed.
             * @member {number} crossSpeed
             * @memberof metamoto.types.LocalFrame
             * @instance
             */
            LocalFrame.prototype.crossSpeed = 0;

            /**
             * Creates a new LocalFrame instance using the specified properties.
             * @function create
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {metamoto.types.ILocalFrame=} [properties] Properties to set
             * @returns {metamoto.types.LocalFrame} LocalFrame instance
             */
            LocalFrame.create = function create(properties) {
                return new LocalFrame(properties);
            };

            /**
             * Encodes the specified LocalFrame message. Does not implicitly {@link metamoto.types.LocalFrame.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {metamoto.types.ILocalFrame} message LocalFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFrame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range != null && message.hasOwnProperty("range"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.range);
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.azimuthAngle);
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.elevationAngle);
                if (message.radialSpeed != null && message.hasOwnProperty("radialSpeed"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.radialSpeed);
                if (message.crossSpeed != null && message.hasOwnProperty("crossSpeed"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.crossSpeed);
                return writer;
            };

            /**
             * Encodes the specified LocalFrame message, length delimited. Does not implicitly {@link metamoto.types.LocalFrame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {metamoto.types.ILocalFrame} message LocalFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFrame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocalFrame message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.LocalFrame} LocalFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFrame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.LocalFrame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.range = reader.float();
                        break;
                    case 2:
                        message.azimuthAngle = reader.float();
                        break;
                    case 3:
                        message.elevationAngle = reader.float();
                        break;
                    case 4:
                        message.radialSpeed = reader.float();
                        break;
                    case 5:
                        message.crossSpeed = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocalFrame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.LocalFrame} LocalFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFrame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocalFrame message.
             * @function verify
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalFrame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range != null && message.hasOwnProperty("range"))
                    if (typeof message.range !== "number")
                        return "range: number expected";
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    if (typeof message.azimuthAngle !== "number")
                        return "azimuthAngle: number expected";
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    if (typeof message.elevationAngle !== "number")
                        return "elevationAngle: number expected";
                if (message.radialSpeed != null && message.hasOwnProperty("radialSpeed"))
                    if (typeof message.radialSpeed !== "number")
                        return "radialSpeed: number expected";
                if (message.crossSpeed != null && message.hasOwnProperty("crossSpeed"))
                    if (typeof message.crossSpeed !== "number")
                        return "crossSpeed: number expected";
                return null;
            };

            /**
             * Creates a LocalFrame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.LocalFrame} LocalFrame
             */
            LocalFrame.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.LocalFrame)
                    return object;
                var message = new $root.metamoto.types.LocalFrame();
                if (object.range != null)
                    message.range = Number(object.range);
                if (object.azimuthAngle != null)
                    message.azimuthAngle = Number(object.azimuthAngle);
                if (object.elevationAngle != null)
                    message.elevationAngle = Number(object.elevationAngle);
                if (object.radialSpeed != null)
                    message.radialSpeed = Number(object.radialSpeed);
                if (object.crossSpeed != null)
                    message.crossSpeed = Number(object.crossSpeed);
                return message;
            };

            /**
             * Creates a plain object from a LocalFrame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.LocalFrame
             * @static
             * @param {metamoto.types.LocalFrame} message LocalFrame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalFrame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.range = 0;
                    object.azimuthAngle = 0;
                    object.elevationAngle = 0;
                    object.radialSpeed = 0;
                    object.crossSpeed = 0;
                }
                if (message.range != null && message.hasOwnProperty("range"))
                    object.range = options.json && !isFinite(message.range) ? String(message.range) : message.range;
                if (message.azimuthAngle != null && message.hasOwnProperty("azimuthAngle"))
                    object.azimuthAngle = options.json && !isFinite(message.azimuthAngle) ? String(message.azimuthAngle) : message.azimuthAngle;
                if (message.elevationAngle != null && message.hasOwnProperty("elevationAngle"))
                    object.elevationAngle = options.json && !isFinite(message.elevationAngle) ? String(message.elevationAngle) : message.elevationAngle;
                if (message.radialSpeed != null && message.hasOwnProperty("radialSpeed"))
                    object.radialSpeed = options.json && !isFinite(message.radialSpeed) ? String(message.radialSpeed) : message.radialSpeed;
                if (message.crossSpeed != null && message.hasOwnProperty("crossSpeed"))
                    object.crossSpeed = options.json && !isFinite(message.crossSpeed) ? String(message.crossSpeed) : message.crossSpeed;
                return object;
            };

            /**
             * Converts this LocalFrame to JSON.
             * @function toJSON
             * @memberof metamoto.types.LocalFrame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalFrame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocalFrame;
        })();

        types.GlobalFrame = (function() {

            /**
             * Properties of a GlobalFrame.
             * @memberof metamoto.types
             * @interface IGlobalFrame
             * @property {metamoto.types.IPose|null} [pose] GlobalFrame pose
             * @property {metamoto.types.IVelocity|null} [velocity] GlobalFrame velocity
             * @property {metamoto.types.IAcceleration|null} [acceleration] GlobalFrame acceleration
             */

            /**
             * Constructs a new GlobalFrame.
             * @memberof metamoto.types
             * @classdesc Represents a GlobalFrame.
             * @implements IGlobalFrame
             * @constructor
             * @param {metamoto.types.IGlobalFrame=} [properties] Properties to set
             */
            function GlobalFrame(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalFrame pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.GlobalFrame
             * @instance
             */
            GlobalFrame.prototype.pose = null;

            /**
             * GlobalFrame velocity.
             * @member {metamoto.types.IVelocity|null|undefined} velocity
             * @memberof metamoto.types.GlobalFrame
             * @instance
             */
            GlobalFrame.prototype.velocity = null;

            /**
             * GlobalFrame acceleration.
             * @member {metamoto.types.IAcceleration|null|undefined} acceleration
             * @memberof metamoto.types.GlobalFrame
             * @instance
             */
            GlobalFrame.prototype.acceleration = null;

            /**
             * Creates a new GlobalFrame instance using the specified properties.
             * @function create
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {metamoto.types.IGlobalFrame=} [properties] Properties to set
             * @returns {metamoto.types.GlobalFrame} GlobalFrame instance
             */
            GlobalFrame.create = function create(properties) {
                return new GlobalFrame(properties);
            };

            /**
             * Encodes the specified GlobalFrame message. Does not implicitly {@link metamoto.types.GlobalFrame.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {metamoto.types.IGlobalFrame} message GlobalFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalFrame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    $root.metamoto.types.Velocity.encode(message.velocity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.metamoto.types.Acceleration.encode(message.acceleration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GlobalFrame message, length delimited. Does not implicitly {@link metamoto.types.GlobalFrame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {metamoto.types.IGlobalFrame} message GlobalFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalFrame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalFrame message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.GlobalFrame} GlobalFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalFrame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.GlobalFrame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.velocity = $root.metamoto.types.Velocity.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.acceleration = $root.metamoto.types.Acceleration.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalFrame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.GlobalFrame} GlobalFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalFrame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalFrame message.
             * @function verify
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalFrame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    var error = $root.metamoto.types.Velocity.verify(message.velocity);
                    if (error)
                        return "velocity." + error;
                }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.metamoto.types.Acceleration.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                return null;
            };

            /**
             * Creates a GlobalFrame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.GlobalFrame} GlobalFrame
             */
            GlobalFrame.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.GlobalFrame)
                    return object;
                var message = new $root.metamoto.types.GlobalFrame();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.GlobalFrame.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.velocity != null) {
                    if (typeof object.velocity !== "object")
                        throw TypeError(".metamoto.types.GlobalFrame.velocity: object expected");
                    message.velocity = $root.metamoto.types.Velocity.fromObject(object.velocity);
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.types.GlobalFrame.acceleration: object expected");
                    message.acceleration = $root.metamoto.types.Acceleration.fromObject(object.acceleration);
                }
                return message;
            };

            /**
             * Creates a plain object from a GlobalFrame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.GlobalFrame
             * @static
             * @param {metamoto.types.GlobalFrame} message GlobalFrame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalFrame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pose = null;
                    object.velocity = null;
                    object.acceleration = null;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = $root.metamoto.types.Velocity.toObject(message.velocity, options);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.metamoto.types.Acceleration.toObject(message.acceleration, options);
                return object;
            };

            /**
             * Converts this GlobalFrame to JSON.
             * @function toJSON
             * @memberof metamoto.types.GlobalFrame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalFrame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalFrame;
        })();

        types.Pose = (function() {

            /**
             * Properties of a Pose.
             * @memberof metamoto.types
             * @interface IPose
             * @property {metamoto.types.IVector3|null} [position] Pose position
             * @property {metamoto.types.IQuaternion|null} [orientation] Pose orientation
             */

            /**
             * Constructs a new Pose.
             * @memberof metamoto.types
             * @classdesc Represents a Pose.
             * @implements IPose
             * @constructor
             * @param {metamoto.types.IPose=} [properties] Properties to set
             */
            function Pose(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pose position.
             * @member {metamoto.types.IVector3|null|undefined} position
             * @memberof metamoto.types.Pose
             * @instance
             */
            Pose.prototype.position = null;

            /**
             * Pose orientation.
             * @member {metamoto.types.IQuaternion|null|undefined} orientation
             * @memberof metamoto.types.Pose
             * @instance
             */
            Pose.prototype.orientation = null;

            /**
             * Creates a new Pose instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Pose
             * @static
             * @param {metamoto.types.IPose=} [properties] Properties to set
             * @returns {metamoto.types.Pose} Pose instance
             */
            Pose.create = function create(properties) {
                return new Pose(properties);
            };

            /**
             * Encodes the specified Pose message. Does not implicitly {@link metamoto.types.Pose.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Pose
             * @static
             * @param {metamoto.types.IPose} message Pose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.metamoto.types.Vector3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    $root.metamoto.types.Quaternion.encode(message.orientation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Pose message, length delimited. Does not implicitly {@link metamoto.types.Pose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Pose
             * @static
             * @param {metamoto.types.IPose} message Pose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pose message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Pose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Pose} Pose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Pose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.orientation = $root.metamoto.types.Quaternion.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Pose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Pose} Pose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pose message.
             * @function verify
             * @memberof metamoto.types.Pose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.metamoto.types.Vector3.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.orientation != null && message.hasOwnProperty("orientation")) {
                    var error = $root.metamoto.types.Quaternion.verify(message.orientation);
                    if (error)
                        return "orientation." + error;
                }
                return null;
            };

            /**
             * Creates a Pose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Pose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Pose} Pose
             */
            Pose.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Pose)
                    return object;
                var message = new $root.metamoto.types.Pose();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".metamoto.types.Pose.position: object expected");
                    message.position = $root.metamoto.types.Vector3.fromObject(object.position);
                }
                if (object.orientation != null) {
                    if (typeof object.orientation !== "object")
                        throw TypeError(".metamoto.types.Pose.orientation: object expected");
                    message.orientation = $root.metamoto.types.Quaternion.fromObject(object.orientation);
                }
                return message;
            };

            /**
             * Creates a plain object from a Pose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Pose
             * @static
             * @param {metamoto.types.Pose} message Pose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.orientation = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.metamoto.types.Vector3.toObject(message.position, options);
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    object.orientation = $root.metamoto.types.Quaternion.toObject(message.orientation, options);
                return object;
            };

            /**
             * Converts this Pose to JSON.
             * @function toJSON
             * @memberof metamoto.types.Pose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Pose;
        })();

        types.Quaternion = (function() {

            /**
             * Properties of a Quaternion.
             * @memberof metamoto.types
             * @interface IQuaternion
             * @property {number|null} [x] Quaternion x
             * @property {number|null} [y] Quaternion y
             * @property {number|null} [z] Quaternion z
             * @property {number|null} [w] Quaternion w
             */

            /**
             * Constructs a new Quaternion.
             * @memberof metamoto.types
             * @classdesc Represents a Quaternion.
             * @implements IQuaternion
             * @constructor
             * @param {metamoto.types.IQuaternion=} [properties] Properties to set
             */
            function Quaternion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Quaternion x.
             * @member {number} x
             * @memberof metamoto.types.Quaternion
             * @instance
             */
            Quaternion.prototype.x = 0;

            /**
             * Quaternion y.
             * @member {number} y
             * @memberof metamoto.types.Quaternion
             * @instance
             */
            Quaternion.prototype.y = 0;

            /**
             * Quaternion z.
             * @member {number} z
             * @memberof metamoto.types.Quaternion
             * @instance
             */
            Quaternion.prototype.z = 0;

            /**
             * Quaternion w.
             * @member {number} w
             * @memberof metamoto.types.Quaternion
             * @instance
             */
            Quaternion.prototype.w = 0;

            /**
             * Creates a new Quaternion instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {metamoto.types.IQuaternion=} [properties] Properties to set
             * @returns {metamoto.types.Quaternion} Quaternion instance
             */
            Quaternion.create = function create(properties) {
                return new Quaternion(properties);
            };

            /**
             * Encodes the specified Quaternion message. Does not implicitly {@link metamoto.types.Quaternion.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {metamoto.types.IQuaternion} message Quaternion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quaternion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && message.hasOwnProperty("x"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                if (message.y != null && message.hasOwnProperty("y"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                if (message.z != null && message.hasOwnProperty("z"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
                if (message.w != null && message.hasOwnProperty("w"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.w);
                return writer;
            };

            /**
             * Encodes the specified Quaternion message, length delimited. Does not implicitly {@link metamoto.types.Quaternion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {metamoto.types.IQuaternion} message Quaternion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quaternion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Quaternion message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Quaternion} Quaternion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quaternion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Quaternion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.float();
                        break;
                    case 2:
                        message.y = reader.float();
                        break;
                    case 3:
                        message.z = reader.float();
                        break;
                    case 4:
                        message.w = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Quaternion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Quaternion} Quaternion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quaternion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Quaternion message.
             * @function verify
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Quaternion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                if (message.z != null && message.hasOwnProperty("z"))
                    if (typeof message.z !== "number")
                        return "z: number expected";
                if (message.w != null && message.hasOwnProperty("w"))
                    if (typeof message.w !== "number")
                        return "w: number expected";
                return null;
            };

            /**
             * Creates a Quaternion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Quaternion} Quaternion
             */
            Quaternion.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Quaternion)
                    return object;
                var message = new $root.metamoto.types.Quaternion();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                if (object.w != null)
                    message.w = Number(object.w);
                return message;
            };

            /**
             * Creates a plain object from a Quaternion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Quaternion
             * @static
             * @param {metamoto.types.Quaternion} message Quaternion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Quaternion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                    object.w = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                if (message.w != null && message.hasOwnProperty("w"))
                    object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
                return object;
            };

            /**
             * Converts this Quaternion to JSON.
             * @function toJSON
             * @memberof metamoto.types.Quaternion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Quaternion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Quaternion;
        })();

        types.RadarObject = (function() {

            /**
             * Properties of a RadarObject.
             * @memberof metamoto.types
             * @interface IRadarObject
             * @property {number|null} [internalId] RadarObject internalId
             * @property {number|null} [objectId] RadarObject objectId
             * @property {metamoto.types.ObjectType|null} [objectType] RadarObject objectType
             * @property {metamoto.types.RadarObject.Status|null} [status] RadarObject status
             * @property {number|null} [range] RadarObject range
             * @property {number|null} [rangeRate] RadarObject rangeRate
             * @property {number|null} [rangeAcceleration] RadarObject rangeAcceleration
             * @property {number|null} [angle] RadarObject angle
             * @property {number|null} [width] RadarObject width
             * @property {number|null} [length] RadarObject length
             * @property {number|null} [positionX] RadarObject positionX
             * @property {number|null} [positionZ] RadarObject positionZ
             * @property {number|null} [velocityX] RadarObject velocityX
             * @property {number|null} [velocityZ] RadarObject velocityZ
             * @property {number|null} [accelerationZ] RadarObject accelerationZ
             * @property {number|null} [rcs] RadarObject rcs
             * @property {number|null} [snr] RadarObject snr
             */

            /**
             * Constructs a new RadarObject.
             * @memberof metamoto.types
             * @classdesc Represents a RadarObject.
             * @implements IRadarObject
             * @constructor
             * @param {metamoto.types.IRadarObject=} [properties] Properties to set
             */
            function RadarObject(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RadarObject internalId.
             * @member {number} internalId
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.internalId = 0;

            /**
             * RadarObject objectId.
             * @member {number} objectId
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.objectId = 0;

            /**
             * RadarObject objectType.
             * @member {metamoto.types.ObjectType} objectType
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.objectType = 0;

            /**
             * RadarObject status.
             * @member {metamoto.types.RadarObject.Status} status
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.status = 0;

            /**
             * RadarObject range.
             * @member {number} range
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.range = 0;

            /**
             * RadarObject rangeRate.
             * @member {number} rangeRate
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.rangeRate = 0;

            /**
             * RadarObject rangeAcceleration.
             * @member {number} rangeAcceleration
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.rangeAcceleration = 0;

            /**
             * RadarObject angle.
             * @member {number} angle
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.angle = 0;

            /**
             * RadarObject width.
             * @member {number} width
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.width = 0;

            /**
             * RadarObject length.
             * @member {number} length
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.length = 0;

            /**
             * RadarObject positionX.
             * @member {number} positionX
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.positionX = 0;

            /**
             * RadarObject positionZ.
             * @member {number} positionZ
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.positionZ = 0;

            /**
             * RadarObject velocityX.
             * @member {number} velocityX
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.velocityX = 0;

            /**
             * RadarObject velocityZ.
             * @member {number} velocityZ
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.velocityZ = 0;

            /**
             * RadarObject accelerationZ.
             * @member {number} accelerationZ
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.accelerationZ = 0;

            /**
             * RadarObject rcs.
             * @member {number} rcs
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.rcs = 0;

            /**
             * RadarObject snr.
             * @member {number} snr
             * @memberof metamoto.types.RadarObject
             * @instance
             */
            RadarObject.prototype.snr = 0;

            /**
             * Creates a new RadarObject instance using the specified properties.
             * @function create
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {metamoto.types.IRadarObject=} [properties] Properties to set
             * @returns {metamoto.types.RadarObject} RadarObject instance
             */
            RadarObject.create = function create(properties) {
                return new RadarObject(properties);
            };

            /**
             * Encodes the specified RadarObject message. Does not implicitly {@link metamoto.types.RadarObject.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {metamoto.types.IRadarObject} message RadarObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RadarObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.internalId != null && message.hasOwnProperty("internalId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.internalId);
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.objectId);
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.objectType);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
                if (message.range != null && message.hasOwnProperty("range"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.range);
                if (message.rangeRate != null && message.hasOwnProperty("rangeRate"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.rangeRate);
                if (message.rangeAcceleration != null && message.hasOwnProperty("rangeAcceleration"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.rangeAcceleration);
                if (message.angle != null && message.hasOwnProperty("angle"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.angle);
                if (message.width != null && message.hasOwnProperty("width"))
                    writer.uint32(/* id 9, wireType 5 =*/77).float(message.width);
                if (message.length != null && message.hasOwnProperty("length"))
                    writer.uint32(/* id 10, wireType 5 =*/85).float(message.length);
                if (message.positionX != null && message.hasOwnProperty("positionX"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.positionX);
                if (message.positionZ != null && message.hasOwnProperty("positionZ"))
                    writer.uint32(/* id 12, wireType 5 =*/101).float(message.positionZ);
                if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                    writer.uint32(/* id 13, wireType 5 =*/109).float(message.velocityX);
                if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.velocityZ);
                if (message.accelerationZ != null && message.hasOwnProperty("accelerationZ"))
                    writer.uint32(/* id 15, wireType 5 =*/125).float(message.accelerationZ);
                if (message.rcs != null && message.hasOwnProperty("rcs"))
                    writer.uint32(/* id 16, wireType 5 =*/133).float(message.rcs);
                if (message.snr != null && message.hasOwnProperty("snr"))
                    writer.uint32(/* id 17, wireType 5 =*/141).float(message.snr);
                return writer;
            };

            /**
             * Encodes the specified RadarObject message, length delimited. Does not implicitly {@link metamoto.types.RadarObject.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {metamoto.types.IRadarObject} message RadarObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RadarObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RadarObject message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.RadarObject} RadarObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RadarObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.RadarObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.internalId = reader.uint32();
                        break;
                    case 2:
                        message.objectId = reader.uint32();
                        break;
                    case 3:
                        message.objectType = reader.int32();
                        break;
                    case 4:
                        message.status = reader.int32();
                        break;
                    case 5:
                        message.range = reader.float();
                        break;
                    case 6:
                        message.rangeRate = reader.float();
                        break;
                    case 7:
                        message.rangeAcceleration = reader.float();
                        break;
                    case 8:
                        message.angle = reader.float();
                        break;
                    case 9:
                        message.width = reader.float();
                        break;
                    case 10:
                        message.length = reader.float();
                        break;
                    case 11:
                        message.positionX = reader.float();
                        break;
                    case 12:
                        message.positionZ = reader.float();
                        break;
                    case 13:
                        message.velocityX = reader.float();
                        break;
                    case 14:
                        message.velocityZ = reader.float();
                        break;
                    case 15:
                        message.accelerationZ = reader.float();
                        break;
                    case 16:
                        message.rcs = reader.float();
                        break;
                    case 17:
                        message.snr = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RadarObject message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.RadarObject} RadarObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RadarObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RadarObject message.
             * @function verify
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RadarObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.internalId != null && message.hasOwnProperty("internalId"))
                    if (!$util.isInteger(message.internalId))
                        return "internalId: integer expected";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    if (!$util.isInteger(message.objectId))
                        return "objectId: integer expected";
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    switch (message.objectType) {
                    default:
                        return "objectType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.range != null && message.hasOwnProperty("range"))
                    if (typeof message.range !== "number")
                        return "range: number expected";
                if (message.rangeRate != null && message.hasOwnProperty("rangeRate"))
                    if (typeof message.rangeRate !== "number")
                        return "rangeRate: number expected";
                if (message.rangeAcceleration != null && message.hasOwnProperty("rangeAcceleration"))
                    if (typeof message.rangeAcceleration !== "number")
                        return "rangeAcceleration: number expected";
                if (message.angle != null && message.hasOwnProperty("angle"))
                    if (typeof message.angle !== "number")
                        return "angle: number expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (typeof message.width !== "number")
                        return "width: number expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (typeof message.length !== "number")
                        return "length: number expected";
                if (message.positionX != null && message.hasOwnProperty("positionX"))
                    if (typeof message.positionX !== "number")
                        return "positionX: number expected";
                if (message.positionZ != null && message.hasOwnProperty("positionZ"))
                    if (typeof message.positionZ !== "number")
                        return "positionZ: number expected";
                if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                    if (typeof message.velocityX !== "number")
                        return "velocityX: number expected";
                if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                    if (typeof message.velocityZ !== "number")
                        return "velocityZ: number expected";
                if (message.accelerationZ != null && message.hasOwnProperty("accelerationZ"))
                    if (typeof message.accelerationZ !== "number")
                        return "accelerationZ: number expected";
                if (message.rcs != null && message.hasOwnProperty("rcs"))
                    if (typeof message.rcs !== "number")
                        return "rcs: number expected";
                if (message.snr != null && message.hasOwnProperty("snr"))
                    if (typeof message.snr !== "number")
                        return "snr: number expected";
                return null;
            };

            /**
             * Creates a RadarObject message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.RadarObject} RadarObject
             */
            RadarObject.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.RadarObject)
                    return object;
                var message = new $root.metamoto.types.RadarObject();
                if (object.internalId != null)
                    message.internalId = object.internalId >>> 0;
                if (object.objectId != null)
                    message.objectId = object.objectId >>> 0;
                switch (object.objectType) {
                case "OBJECT_UNKNOWN":
                case 0:
                    message.objectType = 0;
                    break;
                case "OBJECT_OTHER":
                case 1:
                    message.objectType = 1;
                    break;
                case "OBJECT_CAR":
                case 2:
                    message.objectType = 2;
                    break;
                case "OBJECT_TRUCK":
                case 3:
                    message.objectType = 3;
                    break;
                case "OBJECT_BUS":
                case 4:
                    message.objectType = 4;
                    break;
                case "OBJECT_MOTORCYCLE":
                case 5:
                    message.objectType = 5;
                    break;
                case "OBJECT_BICYCLE":
                case 6:
                    message.objectType = 6;
                    break;
                case "OBJECT_TRAIN":
                case 7:
                    message.objectType = 7;
                    break;
                case "OBJECT_PEDESTRIAN":
                case 8:
                    message.objectType = 8;
                    break;
                case "OBJECT_ANIMAL":
                case 9:
                    message.objectType = 9;
                    break;
                case "OBJECT_TRAFFIC_LIGHT":
                case 10:
                    message.objectType = 10;
                    break;
                case "OBJECT_TRAFFIC_SIGN":
                case 11:
                    message.objectType = 11;
                    break;
                case "OBJECT_TRAFFIC_BARRIER":
                case 12:
                    message.objectType = 12;
                    break;
                case "OBJECT_TRAFFIC_CONE":
                case 13:
                    message.objectType = 13;
                    break;
                case "OBJECT_GROUND":
                case 14:
                    message.objectType = 14;
                    break;
                case "OBJECT_ROAD":
                case 15:
                    message.objectType = 15;
                    break;
                case "OBJECT_RAIL_TRACK":
                case 16:
                    message.objectType = 16;
                    break;
                case "OBJECT_SIDEWALK":
                case 17:
                    message.objectType = 17;
                    break;
                case "OBJECT_CURB":
                case 18:
                    message.objectType = 18;
                    break;
                case "OBJECT_STATIC_OBJECT":
                case 19:
                    message.objectType = 19;
                    break;
                case "OBJECT_SIGN":
                case 20:
                    message.objectType = 20;
                    break;
                case "OBJECT_POLE":
                case 21:
                    message.objectType = 21;
                    break;
                case "OBJECT_BUILDING":
                case 22:
                    message.objectType = 22;
                    break;
                case "OBJECT_WALL":
                case 23:
                    message.objectType = 23;
                    break;
                case "OBJECT_FENCE":
                case 24:
                    message.objectType = 24;
                    break;
                case "OBJECT_TREE":
                case 25:
                    message.objectType = 25;
                    break;
                case "OBJECT_VEGETATION":
                case 26:
                    message.objectType = 26;
                    break;
                }
                switch (object.status) {
                case "STATUS_UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "STATUS_NEW_OBJECT":
                case 1:
                    message.status = 1;
                    break;
                case "STATUS_UPDATED":
                case 2:
                    message.status = 2;
                    break;
                case "STATUS_NOT_UPDATED":
                case 3:
                    message.status = 3;
                    break;
                }
                if (object.range != null)
                    message.range = Number(object.range);
                if (object.rangeRate != null)
                    message.rangeRate = Number(object.rangeRate);
                if (object.rangeAcceleration != null)
                    message.rangeAcceleration = Number(object.rangeAcceleration);
                if (object.angle != null)
                    message.angle = Number(object.angle);
                if (object.width != null)
                    message.width = Number(object.width);
                if (object.length != null)
                    message.length = Number(object.length);
                if (object.positionX != null)
                    message.positionX = Number(object.positionX);
                if (object.positionZ != null)
                    message.positionZ = Number(object.positionZ);
                if (object.velocityX != null)
                    message.velocityX = Number(object.velocityX);
                if (object.velocityZ != null)
                    message.velocityZ = Number(object.velocityZ);
                if (object.accelerationZ != null)
                    message.accelerationZ = Number(object.accelerationZ);
                if (object.rcs != null)
                    message.rcs = Number(object.rcs);
                if (object.snr != null)
                    message.snr = Number(object.snr);
                return message;
            };

            /**
             * Creates a plain object from a RadarObject message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.RadarObject
             * @static
             * @param {metamoto.types.RadarObject} message RadarObject
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RadarObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.internalId = 0;
                    object.objectId = 0;
                    object.objectType = options.enums === String ? "OBJECT_UNKNOWN" : 0;
                    object.status = options.enums === String ? "STATUS_UNKNOWN" : 0;
                    object.range = 0;
                    object.rangeRate = 0;
                    object.rangeAcceleration = 0;
                    object.angle = 0;
                    object.width = 0;
                    object.length = 0;
                    object.positionX = 0;
                    object.positionZ = 0;
                    object.velocityX = 0;
                    object.velocityZ = 0;
                    object.accelerationZ = 0;
                    object.rcs = 0;
                    object.snr = 0;
                }
                if (message.internalId != null && message.hasOwnProperty("internalId"))
                    object.internalId = message.internalId;
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    object.objectId = message.objectId;
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    object.objectType = options.enums === String ? $root.metamoto.types.ObjectType[message.objectType] : message.objectType;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.metamoto.types.RadarObject.Status[message.status] : message.status;
                if (message.range != null && message.hasOwnProperty("range"))
                    object.range = options.json && !isFinite(message.range) ? String(message.range) : message.range;
                if (message.rangeRate != null && message.hasOwnProperty("rangeRate"))
                    object.rangeRate = options.json && !isFinite(message.rangeRate) ? String(message.rangeRate) : message.rangeRate;
                if (message.rangeAcceleration != null && message.hasOwnProperty("rangeAcceleration"))
                    object.rangeAcceleration = options.json && !isFinite(message.rangeAcceleration) ? String(message.rangeAcceleration) : message.rangeAcceleration;
                if (message.angle != null && message.hasOwnProperty("angle"))
                    object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
                if (message.positionX != null && message.hasOwnProperty("positionX"))
                    object.positionX = options.json && !isFinite(message.positionX) ? String(message.positionX) : message.positionX;
                if (message.positionZ != null && message.hasOwnProperty("positionZ"))
                    object.positionZ = options.json && !isFinite(message.positionZ) ? String(message.positionZ) : message.positionZ;
                if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                    object.velocityX = options.json && !isFinite(message.velocityX) ? String(message.velocityX) : message.velocityX;
                if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                    object.velocityZ = options.json && !isFinite(message.velocityZ) ? String(message.velocityZ) : message.velocityZ;
                if (message.accelerationZ != null && message.hasOwnProperty("accelerationZ"))
                    object.accelerationZ = options.json && !isFinite(message.accelerationZ) ? String(message.accelerationZ) : message.accelerationZ;
                if (message.rcs != null && message.hasOwnProperty("rcs"))
                    object.rcs = options.json && !isFinite(message.rcs) ? String(message.rcs) : message.rcs;
                if (message.snr != null && message.hasOwnProperty("snr"))
                    object.snr = options.json && !isFinite(message.snr) ? String(message.snr) : message.snr;
                return object;
            };

            /**
             * Converts this RadarObject to JSON.
             * @function toJSON
             * @memberof metamoto.types.RadarObject
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RadarObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Status enum.
             * @name metamoto.types.RadarObject.Status
             * @enum {string}
             * @property {number} STATUS_UNKNOWN=0 STATUS_UNKNOWN value
             * @property {number} STATUS_NEW_OBJECT=1 STATUS_NEW_OBJECT value
             * @property {number} STATUS_UPDATED=2 STATUS_UPDATED value
             * @property {number} STATUS_NOT_UPDATED=3 STATUS_NOT_UPDATED value
             */
            RadarObject.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATUS_UNKNOWN"] = 0;
                values[valuesById[1] = "STATUS_NEW_OBJECT"] = 1;
                values[valuesById[2] = "STATUS_UPDATED"] = 2;
                values[valuesById[3] = "STATUS_NOT_UPDATED"] = 3;
                return values;
            })();

            return RadarObject;
        })();

        types.NumericRange = (function() {

            /**
             * Properties of a NumericRange.
             * @memberof metamoto.types
             * @interface INumericRange
             * @property {number|null} [min] NumericRange min
             * @property {number|null} [max] NumericRange max
             * @property {number|null} [step] NumericRange step
             */

            /**
             * Constructs a new NumericRange.
             * @memberof metamoto.types
             * @classdesc Represents a NumericRange.
             * @implements INumericRange
             * @constructor
             * @param {metamoto.types.INumericRange=} [properties] Properties to set
             */
            function NumericRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NumericRange min.
             * @member {number} min
             * @memberof metamoto.types.NumericRange
             * @instance
             */
            NumericRange.prototype.min = 0;

            /**
             * NumericRange max.
             * @member {number} max
             * @memberof metamoto.types.NumericRange
             * @instance
             */
            NumericRange.prototype.max = 0;

            /**
             * NumericRange step.
             * @member {number} step
             * @memberof metamoto.types.NumericRange
             * @instance
             */
            NumericRange.prototype.step = 0;

            /**
             * Creates a new NumericRange instance using the specified properties.
             * @function create
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {metamoto.types.INumericRange=} [properties] Properties to set
             * @returns {metamoto.types.NumericRange} NumericRange instance
             */
            NumericRange.create = function create(properties) {
                return new NumericRange(properties);
            };

            /**
             * Encodes the specified NumericRange message. Does not implicitly {@link metamoto.types.NumericRange.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {metamoto.types.INumericRange} message NumericRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumericRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.min != null && message.hasOwnProperty("min"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.min);
                if (message.max != null && message.hasOwnProperty("max"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.max);
                if (message.step != null && message.hasOwnProperty("step"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.step);
                return writer;
            };

            /**
             * Encodes the specified NumericRange message, length delimited. Does not implicitly {@link metamoto.types.NumericRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {metamoto.types.INumericRange} message NumericRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumericRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NumericRange message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.NumericRange} NumericRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumericRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.NumericRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.min = reader.double();
                        break;
                    case 2:
                        message.max = reader.double();
                        break;
                    case 3:
                        message.step = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NumericRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.NumericRange} NumericRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumericRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NumericRange message.
             * @function verify
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NumericRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.min != null && message.hasOwnProperty("min"))
                    if (typeof message.min !== "number")
                        return "min: number expected";
                if (message.max != null && message.hasOwnProperty("max"))
                    if (typeof message.max !== "number")
                        return "max: number expected";
                if (message.step != null && message.hasOwnProperty("step"))
                    if (typeof message.step !== "number")
                        return "step: number expected";
                return null;
            };

            /**
             * Creates a NumericRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.NumericRange} NumericRange
             */
            NumericRange.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.NumericRange)
                    return object;
                var message = new $root.metamoto.types.NumericRange();
                if (object.min != null)
                    message.min = Number(object.min);
                if (object.max != null)
                    message.max = Number(object.max);
                if (object.step != null)
                    message.step = Number(object.step);
                return message;
            };

            /**
             * Creates a plain object from a NumericRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.NumericRange
             * @static
             * @param {metamoto.types.NumericRange} message NumericRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NumericRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.min = 0;
                    object.max = 0;
                    object.step = 0;
                }
                if (message.min != null && message.hasOwnProperty("min"))
                    object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                if (message.max != null && message.hasOwnProperty("max"))
                    object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                if (message.step != null && message.hasOwnProperty("step"))
                    object.step = options.json && !isFinite(message.step) ? String(message.step) : message.step;
                return object;
            };

            /**
             * Converts this NumericRange to JSON.
             * @function toJSON
             * @memberof metamoto.types.NumericRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NumericRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NumericRange;
        })();

        types.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof metamoto.types
             * @interface IRange
             * @property {string|null} [parameterName] Range parameterName
             * @property {Array.<metamoto.types.INumericRange>|null} [numericRanges] Range numericRanges
             * @property {Array.<google.protobuf.IValue>|null} [values] Range values
             */

            /**
             * Constructs a new Range.
             * @memberof metamoto.types
             * @classdesc Represents a Range.
             * @implements IRange
             * @constructor
             * @param {metamoto.types.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                this.numericRanges = [];
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range parameterName.
             * @member {string} parameterName
             * @memberof metamoto.types.Range
             * @instance
             */
            Range.prototype.parameterName = "";

            /**
             * Range numericRanges.
             * @member {Array.<metamoto.types.INumericRange>} numericRanges
             * @memberof metamoto.types.Range
             * @instance
             */
            Range.prototype.numericRanges = $util.emptyArray;

            /**
             * Range values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof metamoto.types.Range
             * @instance
             */
            Range.prototype.values = $util.emptyArray;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Range
             * @static
             * @param {metamoto.types.IRange=} [properties] Properties to set
             * @returns {metamoto.types.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link metamoto.types.Range.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Range
             * @static
             * @param {metamoto.types.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.parameterName != null && message.hasOwnProperty("parameterName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.parameterName);
                if (message.numericRanges != null && message.numericRanges.length)
                    for (var i = 0; i < message.numericRanges.length; ++i)
                        $root.metamoto.types.NumericRange.encode(message.numericRanges[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link metamoto.types.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Range
             * @static
             * @param {metamoto.types.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Range();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.parameterName = reader.string();
                        break;
                    case 2:
                        if (!(message.numericRanges && message.numericRanges.length))
                            message.numericRanges = [];
                        message.numericRanges.push($root.metamoto.types.NumericRange.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof metamoto.types.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.parameterName != null && message.hasOwnProperty("parameterName"))
                    if (!$util.isString(message.parameterName))
                        return "parameterName: string expected";
                if (message.numericRanges != null && message.hasOwnProperty("numericRanges")) {
                    if (!Array.isArray(message.numericRanges))
                        return "numericRanges: array expected";
                    for (var i = 0; i < message.numericRanges.length; ++i) {
                        var error = $root.metamoto.types.NumericRange.verify(message.numericRanges[i]);
                        if (error)
                            return "numericRanges." + error;
                    }
                }
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Range)
                    return object;
                var message = new $root.metamoto.types.Range();
                if (object.parameterName != null)
                    message.parameterName = String(object.parameterName);
                if (object.numericRanges) {
                    if (!Array.isArray(object.numericRanges))
                        throw TypeError(".metamoto.types.Range.numericRanges: array expected");
                    message.numericRanges = [];
                    for (var i = 0; i < object.numericRanges.length; ++i) {
                        if (typeof object.numericRanges[i] !== "object")
                            throw TypeError(".metamoto.types.Range.numericRanges: object expected");
                        message.numericRanges[i] = $root.metamoto.types.NumericRange.fromObject(object.numericRanges[i]);
                    }
                }
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".metamoto.types.Range.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".metamoto.types.Range.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Range
             * @static
             * @param {metamoto.types.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.numericRanges = [];
                    object.values = [];
                }
                if (options.defaults)
                    object.parameterName = "";
                if (message.parameterName != null && message.hasOwnProperty("parameterName"))
                    object.parameterName = message.parameterName;
                if (message.numericRanges && message.numericRanges.length) {
                    object.numericRanges = [];
                    for (var j = 0; j < message.numericRanges.length; ++j)
                        object.numericRanges[j] = $root.metamoto.types.NumericRange.toObject(message.numericRanges[j], options);
                }
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof metamoto.types.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        types.Parameter = (function() {

            /**
             * Properties of a Parameter.
             * @memberof metamoto.types
             * @interface IParameter
             * @property {metamoto.types.IRange|null} [range] Parameter range
             * @property {metamoto.types.IRange|null} [selected] Parameter selected
             */

            /**
             * Constructs a new Parameter.
             * @memberof metamoto.types
             * @classdesc Represents a Parameter.
             * @implements IParameter
             * @constructor
             * @param {metamoto.types.IParameter=} [properties] Properties to set
             */
            function Parameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Parameter range.
             * @member {metamoto.types.IRange|null|undefined} range
             * @memberof metamoto.types.Parameter
             * @instance
             */
            Parameter.prototype.range = null;

            /**
             * Parameter selected.
             * @member {metamoto.types.IRange|null|undefined} selected
             * @memberof metamoto.types.Parameter
             * @instance
             */
            Parameter.prototype.selected = null;

            /**
             * Creates a new Parameter instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Parameter
             * @static
             * @param {metamoto.types.IParameter=} [properties] Properties to set
             * @returns {metamoto.types.Parameter} Parameter instance
             */
            Parameter.create = function create(properties) {
                return new Parameter(properties);
            };

            /**
             * Encodes the specified Parameter message. Does not implicitly {@link metamoto.types.Parameter.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Parameter
             * @static
             * @param {metamoto.types.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range != null && message.hasOwnProperty("range"))
                    $root.metamoto.types.Range.encode(message.range, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.selected != null && message.hasOwnProperty("selected"))
                    $root.metamoto.types.Range.encode(message.selected, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Parameter message, length delimited. Does not implicitly {@link metamoto.types.Parameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Parameter
             * @static
             * @param {metamoto.types.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Parameter message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Parameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.range = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.selected = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Parameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Parameter message.
             * @function verify
             * @memberof metamoto.types.Parameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Parameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range != null && message.hasOwnProperty("range")) {
                    var error = $root.metamoto.types.Range.verify(message.range);
                    if (error)
                        return "range." + error;
                }
                if (message.selected != null && message.hasOwnProperty("selected")) {
                    var error = $root.metamoto.types.Range.verify(message.selected);
                    if (error)
                        return "selected." + error;
                }
                return null;
            };

            /**
             * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Parameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Parameter} Parameter
             */
            Parameter.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Parameter)
                    return object;
                var message = new $root.metamoto.types.Parameter();
                if (object.range != null) {
                    if (typeof object.range !== "object")
                        throw TypeError(".metamoto.types.Parameter.range: object expected");
                    message.range = $root.metamoto.types.Range.fromObject(object.range);
                }
                if (object.selected != null) {
                    if (typeof object.selected !== "object")
                        throw TypeError(".metamoto.types.Parameter.selected: object expected");
                    message.selected = $root.metamoto.types.Range.fromObject(object.selected);
                }
                return message;
            };

            /**
             * Creates a plain object from a Parameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Parameter
             * @static
             * @param {metamoto.types.Parameter} message Parameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Parameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.range = null;
                    object.selected = null;
                }
                if (message.range != null && message.hasOwnProperty("range"))
                    object.range = $root.metamoto.types.Range.toObject(message.range, options);
                if (message.selected != null && message.hasOwnProperty("selected"))
                    object.selected = $root.metamoto.types.Range.toObject(message.selected, options);
                return object;
            };

            /**
             * Converts this Parameter to JSON.
             * @function toJSON
             * @memberof metamoto.types.Parameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Parameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Parameter;
        })();

        types.ResultMetadata = (function() {

            /**
             * Properties of a ResultMetadata.
             * @memberof metamoto.types
             * @interface IResultMetadata
             * @property {string|null} [name] ResultMetadata name
             * @property {string|null} [type] ResultMetadata type
             * @property {string|null} [format] ResultMetadata format
             * @property {string|null} [path] ResultMetadata path
             */

            /**
             * Constructs a new ResultMetadata.
             * @memberof metamoto.types
             * @classdesc Represents a ResultMetadata.
             * @implements IResultMetadata
             * @constructor
             * @param {metamoto.types.IResultMetadata=} [properties] Properties to set
             */
            function ResultMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResultMetadata name.
             * @member {string} name
             * @memberof metamoto.types.ResultMetadata
             * @instance
             */
            ResultMetadata.prototype.name = "";

            /**
             * ResultMetadata type.
             * @member {string} type
             * @memberof metamoto.types.ResultMetadata
             * @instance
             */
            ResultMetadata.prototype.type = "";

            /**
             * ResultMetadata format.
             * @member {string} format
             * @memberof metamoto.types.ResultMetadata
             * @instance
             */
            ResultMetadata.prototype.format = "";

            /**
             * ResultMetadata path.
             * @member {string} path
             * @memberof metamoto.types.ResultMetadata
             * @instance
             */
            ResultMetadata.prototype.path = "";

            /**
             * Creates a new ResultMetadata instance using the specified properties.
             * @function create
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {metamoto.types.IResultMetadata=} [properties] Properties to set
             * @returns {metamoto.types.ResultMetadata} ResultMetadata instance
             */
            ResultMetadata.create = function create(properties) {
                return new ResultMetadata(properties);
            };

            /**
             * Encodes the specified ResultMetadata message. Does not implicitly {@link metamoto.types.ResultMetadata.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {metamoto.types.IResultMetadata} message ResultMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResultMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                if (message.format != null && message.hasOwnProperty("format"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.format);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified ResultMetadata message, length delimited. Does not implicitly {@link metamoto.types.ResultMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {metamoto.types.IResultMetadata} message ResultMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResultMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResultMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.ResultMetadata} ResultMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResultMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.ResultMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.string();
                        break;
                    case 3:
                        message.format = reader.string();
                        break;
                    case 4:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResultMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.ResultMetadata} ResultMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResultMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResultMetadata message.
             * @function verify
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResultMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isString(message.format))
                        return "format: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a ResultMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.ResultMetadata} ResultMetadata
             */
            ResultMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.ResultMetadata)
                    return object;
                var message = new $root.metamoto.types.ResultMetadata();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.format != null)
                    message.format = String(object.format);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a ResultMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.ResultMetadata
             * @static
             * @param {metamoto.types.ResultMetadata} message ResultMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResultMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = "";
                    object.format = "";
                    object.path = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this ResultMetadata to JSON.
             * @function toJSON
             * @memberof metamoto.types.ResultMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResultMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ResultMetadata;
        })();

        types.Elevation = (function() {

            /**
             * Properties of an Elevation.
             * @memberof metamoto.types
             * @interface IElevation
             * @property {number|null} [s] Elevation s
             * @property {number|null} [a] Elevation a
             * @property {number|null} [b] Elevation b
             * @property {number|null} [c] Elevation c
             * @property {number|null} [d] Elevation d
             * @property {boolean|null} [reversed] Elevation reversed
             */

            /**
             * Constructs a new Elevation.
             * @memberof metamoto.types
             * @classdesc Represents an Elevation.
             * @implements IElevation
             * @constructor
             * @param {metamoto.types.IElevation=} [properties] Properties to set
             */
            function Elevation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Elevation s.
             * @member {number} s
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.s = 0;

            /**
             * Elevation a.
             * @member {number} a
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.a = 0;

            /**
             * Elevation b.
             * @member {number} b
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.b = 0;

            /**
             * Elevation c.
             * @member {number} c
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.c = 0;

            /**
             * Elevation d.
             * @member {number} d
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.d = 0;

            /**
             * Elevation reversed.
             * @member {boolean} reversed
             * @memberof metamoto.types.Elevation
             * @instance
             */
            Elevation.prototype.reversed = false;

            /**
             * Creates a new Elevation instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Elevation
             * @static
             * @param {metamoto.types.IElevation=} [properties] Properties to set
             * @returns {metamoto.types.Elevation} Elevation instance
             */
            Elevation.create = function create(properties) {
                return new Elevation(properties);
            };

            /**
             * Encodes the specified Elevation message. Does not implicitly {@link metamoto.types.Elevation.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Elevation
             * @static
             * @param {metamoto.types.IElevation} message Elevation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elevation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.s != null && message.hasOwnProperty("s"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.s);
                if (message.a != null && message.hasOwnProperty("a"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.a);
                if (message.b != null && message.hasOwnProperty("b"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.b);
                if (message.c != null && message.hasOwnProperty("c"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.c);
                if (message.d != null && message.hasOwnProperty("d"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.d);
                if (message.reversed != null && message.hasOwnProperty("reversed"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.reversed);
                return writer;
            };

            /**
             * Encodes the specified Elevation message, length delimited. Does not implicitly {@link metamoto.types.Elevation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Elevation
             * @static
             * @param {metamoto.types.IElevation} message Elevation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Elevation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Elevation message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Elevation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Elevation} Elevation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elevation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Elevation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.s = reader.float();
                        break;
                    case 2:
                        message.a = reader.float();
                        break;
                    case 3:
                        message.b = reader.float();
                        break;
                    case 4:
                        message.c = reader.float();
                        break;
                    case 5:
                        message.d = reader.float();
                        break;
                    case 6:
                        message.reversed = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Elevation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Elevation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Elevation} Elevation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Elevation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Elevation message.
             * @function verify
             * @memberof metamoto.types.Elevation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Elevation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.s != null && message.hasOwnProperty("s"))
                    if (typeof message.s !== "number")
                        return "s: number expected";
                if (message.a != null && message.hasOwnProperty("a"))
                    if (typeof message.a !== "number")
                        return "a: number expected";
                if (message.b != null && message.hasOwnProperty("b"))
                    if (typeof message.b !== "number")
                        return "b: number expected";
                if (message.c != null && message.hasOwnProperty("c"))
                    if (typeof message.c !== "number")
                        return "c: number expected";
                if (message.d != null && message.hasOwnProperty("d"))
                    if (typeof message.d !== "number")
                        return "d: number expected";
                if (message.reversed != null && message.hasOwnProperty("reversed"))
                    if (typeof message.reversed !== "boolean")
                        return "reversed: boolean expected";
                return null;
            };

            /**
             * Creates an Elevation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Elevation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Elevation} Elevation
             */
            Elevation.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Elevation)
                    return object;
                var message = new $root.metamoto.types.Elevation();
                if (object.s != null)
                    message.s = Number(object.s);
                if (object.a != null)
                    message.a = Number(object.a);
                if (object.b != null)
                    message.b = Number(object.b);
                if (object.c != null)
                    message.c = Number(object.c);
                if (object.d != null)
                    message.d = Number(object.d);
                if (object.reversed != null)
                    message.reversed = Boolean(object.reversed);
                return message;
            };

            /**
             * Creates a plain object from an Elevation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Elevation
             * @static
             * @param {metamoto.types.Elevation} message Elevation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Elevation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.s = 0;
                    object.a = 0;
                    object.b = 0;
                    object.c = 0;
                    object.d = 0;
                    object.reversed = false;
                }
                if (message.s != null && message.hasOwnProperty("s"))
                    object.s = options.json && !isFinite(message.s) ? String(message.s) : message.s;
                if (message.a != null && message.hasOwnProperty("a"))
                    object.a = options.json && !isFinite(message.a) ? String(message.a) : message.a;
                if (message.b != null && message.hasOwnProperty("b"))
                    object.b = options.json && !isFinite(message.b) ? String(message.b) : message.b;
                if (message.c != null && message.hasOwnProperty("c"))
                    object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
                if (message.d != null && message.hasOwnProperty("d"))
                    object.d = options.json && !isFinite(message.d) ? String(message.d) : message.d;
                if (message.reversed != null && message.hasOwnProperty("reversed"))
                    object.reversed = message.reversed;
                return object;
            };

            /**
             * Converts this Elevation to JSON.
             * @function toJSON
             * @memberof metamoto.types.Elevation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Elevation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Elevation;
        })();

        types.Geometry = (function() {

            /**
             * Properties of a Geometry.
             * @memberof metamoto.types
             * @interface IGeometry
             * @property {metamoto.types.Geometry.Type|null} [type] Geometry type
             * @property {metamoto.types.IVector3|null} [start] Geometry start
             * @property {metamoto.types.IVector3|null} [heading] Geometry heading
             * @property {number|null} [s] Geometry s
             * @property {number|null} [length] Geometry length
             * @property {metamoto.types.Geometry.IArc|null} [arc] Geometry arc
             */

            /**
             * Constructs a new Geometry.
             * @memberof metamoto.types
             * @classdesc Represents a Geometry.
             * @implements IGeometry
             * @constructor
             * @param {metamoto.types.IGeometry=} [properties] Properties to set
             */
            function Geometry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Geometry type.
             * @member {metamoto.types.Geometry.Type} type
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.type = 0;

            /**
             * Geometry start.
             * @member {metamoto.types.IVector3|null|undefined} start
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.start = null;

            /**
             * Geometry heading.
             * @member {metamoto.types.IVector3|null|undefined} heading
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.heading = null;

            /**
             * Geometry s.
             * @member {number} s
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.s = 0;

            /**
             * Geometry length.
             * @member {number} length
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.length = 0;

            /**
             * Geometry arc.
             * @member {metamoto.types.Geometry.IArc|null|undefined} arc
             * @memberof metamoto.types.Geometry
             * @instance
             */
            Geometry.prototype.arc = null;

            /**
             * Creates a new Geometry instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Geometry
             * @static
             * @param {metamoto.types.IGeometry=} [properties] Properties to set
             * @returns {metamoto.types.Geometry} Geometry instance
             */
            Geometry.create = function create(properties) {
                return new Geometry(properties);
            };

            /**
             * Encodes the specified Geometry message. Does not implicitly {@link metamoto.types.Geometry.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Geometry
             * @static
             * @param {metamoto.types.IGeometry} message Geometry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Geometry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.start != null && message.hasOwnProperty("start"))
                    $root.metamoto.types.Vector3.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.heading != null && message.hasOwnProperty("heading"))
                    $root.metamoto.types.Vector3.encode(message.heading, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.s != null && message.hasOwnProperty("s"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.s);
                if (message.length != null && message.hasOwnProperty("length"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.length);
                if (message.arc != null && message.hasOwnProperty("arc"))
                    $root.metamoto.types.Geometry.Arc.encode(message.arc, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Geometry message, length delimited. Does not implicitly {@link metamoto.types.Geometry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Geometry
             * @static
             * @param {metamoto.types.IGeometry} message Geometry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Geometry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Geometry message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Geometry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Geometry} Geometry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Geometry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Geometry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.start = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.heading = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.s = reader.float();
                        break;
                    case 5:
                        message.length = reader.float();
                        break;
                    case 6:
                        message.arc = $root.metamoto.types.Geometry.Arc.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Geometry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Geometry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Geometry} Geometry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Geometry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Geometry message.
             * @function verify
             * @memberof metamoto.types.Geometry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Geometry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.start != null && message.hasOwnProperty("start")) {
                    var error = $root.metamoto.types.Vector3.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.heading != null && message.hasOwnProperty("heading")) {
                    var error = $root.metamoto.types.Vector3.verify(message.heading);
                    if (error)
                        return "heading." + error;
                }
                if (message.s != null && message.hasOwnProperty("s"))
                    if (typeof message.s !== "number")
                        return "s: number expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (typeof message.length !== "number")
                        return "length: number expected";
                if (message.arc != null && message.hasOwnProperty("arc")) {
                    var error = $root.metamoto.types.Geometry.Arc.verify(message.arc);
                    if (error)
                        return "arc." + error;
                }
                return null;
            };

            /**
             * Creates a Geometry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Geometry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Geometry} Geometry
             */
            Geometry.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Geometry)
                    return object;
                var message = new $root.metamoto.types.Geometry();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "STRAIGHT_LINE":
                case 2:
                    message.type = 2;
                    break;
                case "ARC":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".metamoto.types.Geometry.start: object expected");
                    message.start = $root.metamoto.types.Vector3.fromObject(object.start);
                }
                if (object.heading != null) {
                    if (typeof object.heading !== "object")
                        throw TypeError(".metamoto.types.Geometry.heading: object expected");
                    message.heading = $root.metamoto.types.Vector3.fromObject(object.heading);
                }
                if (object.s != null)
                    message.s = Number(object.s);
                if (object.length != null)
                    message.length = Number(object.length);
                if (object.arc != null) {
                    if (typeof object.arc !== "object")
                        throw TypeError(".metamoto.types.Geometry.arc: object expected");
                    message.arc = $root.metamoto.types.Geometry.Arc.fromObject(object.arc);
                }
                return message;
            };

            /**
             * Creates a plain object from a Geometry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Geometry
             * @static
             * @param {metamoto.types.Geometry} message Geometry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Geometry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.start = null;
                    object.heading = null;
                    object.s = 0;
                    object.length = 0;
                    object.arc = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Geometry.Type[message.type] : message.type;
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.metamoto.types.Vector3.toObject(message.start, options);
                if (message.heading != null && message.hasOwnProperty("heading"))
                    object.heading = $root.metamoto.types.Vector3.toObject(message.heading, options);
                if (message.s != null && message.hasOwnProperty("s"))
                    object.s = options.json && !isFinite(message.s) ? String(message.s) : message.s;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
                if (message.arc != null && message.hasOwnProperty("arc"))
                    object.arc = $root.metamoto.types.Geometry.Arc.toObject(message.arc, options);
                return object;
            };

            /**
             * Converts this Geometry to JSON.
             * @function toJSON
             * @memberof metamoto.types.Geometry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Geometry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Geometry.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} STRAIGHT_LINE=2 STRAIGHT_LINE value
             * @property {number} ARC=3 ARC value
             */
            Geometry.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "STRAIGHT_LINE"] = 2;
                values[valuesById[3] = "ARC"] = 3;
                return values;
            })();

            Geometry.Arc = (function() {

                /**
                 * Properties of an Arc.
                 * @memberof metamoto.types.Geometry
                 * @interface IArc
                 * @property {number|null} [radius] Arc radius
                 * @property {number|null} [angle] Arc angle
                 * @property {metamoto.types.IVector3|null} [center] Arc center
                 */

                /**
                 * Constructs a new Arc.
                 * @memberof metamoto.types.Geometry
                 * @classdesc Represents an Arc.
                 * @implements IArc
                 * @constructor
                 * @param {metamoto.types.Geometry.IArc=} [properties] Properties to set
                 */
                function Arc(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Arc radius.
                 * @member {number} radius
                 * @memberof metamoto.types.Geometry.Arc
                 * @instance
                 */
                Arc.prototype.radius = 0;

                /**
                 * Arc angle.
                 * @member {number} angle
                 * @memberof metamoto.types.Geometry.Arc
                 * @instance
                 */
                Arc.prototype.angle = 0;

                /**
                 * Arc center.
                 * @member {metamoto.types.IVector3|null|undefined} center
                 * @memberof metamoto.types.Geometry.Arc
                 * @instance
                 */
                Arc.prototype.center = null;

                /**
                 * Creates a new Arc instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {metamoto.types.Geometry.IArc=} [properties] Properties to set
                 * @returns {metamoto.types.Geometry.Arc} Arc instance
                 */
                Arc.create = function create(properties) {
                    return new Arc(properties);
                };

                /**
                 * Encodes the specified Arc message. Does not implicitly {@link metamoto.types.Geometry.Arc.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {metamoto.types.Geometry.IArc} message Arc message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arc.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.radius);
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.angle);
                    if (message.center != null && message.hasOwnProperty("center"))
                        $root.metamoto.types.Vector3.encode(message.center, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Arc message, length delimited. Does not implicitly {@link metamoto.types.Geometry.Arc.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {metamoto.types.Geometry.IArc} message Arc message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arc.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Arc message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Geometry.Arc} Arc
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arc.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Geometry.Arc();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.radius = reader.float();
                            break;
                        case 2:
                            message.angle = reader.float();
                            break;
                        case 3:
                            message.center = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Arc message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Geometry.Arc} Arc
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arc.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Arc message.
                 * @function verify
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Arc.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        if (typeof message.radius !== "number")
                            return "radius: number expected";
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        if (typeof message.angle !== "number")
                            return "angle: number expected";
                    if (message.center != null && message.hasOwnProperty("center")) {
                        var error = $root.metamoto.types.Vector3.verify(message.center);
                        if (error)
                            return "center." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Arc message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Geometry.Arc} Arc
                 */
                Arc.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Geometry.Arc)
                        return object;
                    var message = new $root.metamoto.types.Geometry.Arc();
                    if (object.radius != null)
                        message.radius = Number(object.radius);
                    if (object.angle != null)
                        message.angle = Number(object.angle);
                    if (object.center != null) {
                        if (typeof object.center !== "object")
                            throw TypeError(".metamoto.types.Geometry.Arc.center: object expected");
                        message.center = $root.metamoto.types.Vector3.fromObject(object.center);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Arc message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Geometry.Arc
                 * @static
                 * @param {metamoto.types.Geometry.Arc} message Arc
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Arc.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.radius = 0;
                        object.angle = 0;
                        object.center = null;
                    }
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
                    if (message.center != null && message.hasOwnProperty("center"))
                        object.center = $root.metamoto.types.Vector3.toObject(message.center, options);
                    return object;
                };

                /**
                 * Converts this Arc to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Geometry.Arc
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Arc.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Arc;
            })();

            return Geometry;
        })();

        types.Marking = (function() {

            /**
             * Properties of a Marking.
             * @memberof metamoto.types
             * @interface IMarking
             * @property {metamoto.types.Marking.Type|null} [type] Marking type
             * @property {metamoto.types.Marking.Color|null} [color] Marking color
             * @property {google.protobuf.IFloatValue|null} [s] Marking s
             * @property {google.protobuf.IFloatValue|null} [t] Marking t
             * @property {number|null} [headingOffset] Marking headingOffset
             */

            /**
             * Constructs a new Marking.
             * @memberof metamoto.types
             * @classdesc Represents a Marking.
             * @implements IMarking
             * @constructor
             * @param {metamoto.types.IMarking=} [properties] Properties to set
             */
            function Marking(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Marking type.
             * @member {metamoto.types.Marking.Type} type
             * @memberof metamoto.types.Marking
             * @instance
             */
            Marking.prototype.type = 0;

            /**
             * Marking color.
             * @member {metamoto.types.Marking.Color} color
             * @memberof metamoto.types.Marking
             * @instance
             */
            Marking.prototype.color = 0;

            /**
             * Marking s.
             * @member {google.protobuf.IFloatValue|null|undefined} s
             * @memberof metamoto.types.Marking
             * @instance
             */
            Marking.prototype.s = null;

            /**
             * Marking t.
             * @member {google.protobuf.IFloatValue|null|undefined} t
             * @memberof metamoto.types.Marking
             * @instance
             */
            Marking.prototype.t = null;

            /**
             * Marking headingOffset.
             * @member {number} headingOffset
             * @memberof metamoto.types.Marking
             * @instance
             */
            Marking.prototype.headingOffset = 0;

            /**
             * Creates a new Marking instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Marking
             * @static
             * @param {metamoto.types.IMarking=} [properties] Properties to set
             * @returns {metamoto.types.Marking} Marking instance
             */
            Marking.create = function create(properties) {
                return new Marking(properties);
            };

            /**
             * Encodes the specified Marking message. Does not implicitly {@link metamoto.types.Marking.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Marking
             * @static
             * @param {metamoto.types.IMarking} message Marking message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Marking.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.color != null && message.hasOwnProperty("color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.s != null && message.hasOwnProperty("s"))
                    $root.google.protobuf.FloatValue.encode(message.s, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.t != null && message.hasOwnProperty("t"))
                    $root.google.protobuf.FloatValue.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.headingOffset);
                return writer;
            };

            /**
             * Encodes the specified Marking message, length delimited. Does not implicitly {@link metamoto.types.Marking.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Marking
             * @static
             * @param {metamoto.types.IMarking} message Marking message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Marking.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Marking message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Marking
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Marking} Marking
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Marking.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Marking();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.color = reader.int32();
                        break;
                    case 3:
                        message.s = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.t = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.headingOffset = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Marking message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Marking
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Marking} Marking
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Marking.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Marking message.
             * @function verify
             * @memberof metamoto.types.Marking
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Marking.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.color != null && message.hasOwnProperty("color"))
                    switch (message.color) {
                    default:
                        return "color: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.s != null && message.hasOwnProperty("s")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.s);
                    if (error)
                        return "s." + error;
                }
                if (message.t != null && message.hasOwnProperty("t")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.t);
                    if (error)
                        return "t." + error;
                }
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    if (typeof message.headingOffset !== "number")
                        return "headingOffset: number expected";
                return null;
            };

            /**
             * Creates a Marking message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Marking
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Marking} Marking
             */
            Marking.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Marking)
                    return object;
                var message = new $root.metamoto.types.Marking();
                switch (object.type) {
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "SOLID":
                case 2:
                    message.type = 2;
                    break;
                case "DASH":
                case 3:
                    message.type = 3;
                    break;
                case "CURB":
                case 4:
                    message.type = 4;
                    break;
                case "DOUBLE_SOLID":
                case 5:
                    message.type = 5;
                    break;
                case "SOLID_RIGHT_DASH":
                case 6:
                    message.type = 6;
                    break;
                case "SOLID_LEFT_DASH":
                case 7:
                    message.type = 7;
                    break;
                case "PARALLEL_PARKING":
                case 8:
                    message.type = 8;
                    break;
                case "PERPENDICULAR_PARKING":
                case 9:
                    message.type = 9;
                    break;
                case "ANGLED_PARKING_60":
                case 10:
                    message.type = 10;
                    break;
                case "CROSSWALK":
                case 11:
                    message.type = 11;
                    break;
                case "PARKING":
                case 12:
                    message.type = 12;
                    break;
                }
                switch (object.color) {
                case "COLOR_UNKNOWN":
                case 0:
                    message.color = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.color = 1;
                    break;
                case "WHITE":
                case 2:
                    message.color = 2;
                    break;
                case "YELLOW":
                case 3:
                    message.color = 3;
                    break;
                case "RED":
                case 4:
                    message.color = 4;
                    break;
                case "GREEN":
                case 5:
                    message.color = 5;
                    break;
                case "BLUE":
                case 6:
                    message.color = 6;
                    break;
                }
                if (object.s != null) {
                    if (typeof object.s !== "object")
                        throw TypeError(".metamoto.types.Marking.s: object expected");
                    message.s = $root.google.protobuf.FloatValue.fromObject(object.s);
                }
                if (object.t != null) {
                    if (typeof object.t !== "object")
                        throw TypeError(".metamoto.types.Marking.t: object expected");
                    message.t = $root.google.protobuf.FloatValue.fromObject(object.t);
                }
                if (object.headingOffset != null)
                    message.headingOffset = Number(object.headingOffset);
                return message;
            };

            /**
             * Creates a plain object from a Marking message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Marking
             * @static
             * @param {metamoto.types.Marking} message Marking
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Marking.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                    object.s = null;
                    object.t = null;
                    object.headingOffset = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Marking.Type[message.type] : message.type;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = options.enums === String ? $root.metamoto.types.Marking.Color[message.color] : message.color;
                if (message.s != null && message.hasOwnProperty("s"))
                    object.s = $root.google.protobuf.FloatValue.toObject(message.s, options);
                if (message.t != null && message.hasOwnProperty("t"))
                    object.t = $root.google.protobuf.FloatValue.toObject(message.t, options);
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    object.headingOffset = options.json && !isFinite(message.headingOffset) ? String(message.headingOffset) : message.headingOffset;
                return object;
            };

            /**
             * Converts this Marking to JSON.
             * @function toJSON
             * @memberof metamoto.types.Marking
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Marking.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Marking.Type
             * @enum {string}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} SOLID=2 SOLID value
             * @property {number} DASH=3 DASH value
             * @property {number} CURB=4 CURB value
             * @property {number} DOUBLE_SOLID=5 DOUBLE_SOLID value
             * @property {number} SOLID_RIGHT_DASH=6 SOLID_RIGHT_DASH value
             * @property {number} SOLID_LEFT_DASH=7 SOLID_LEFT_DASH value
             * @property {number} PARALLEL_PARKING=8 PARALLEL_PARKING value
             * @property {number} PERPENDICULAR_PARKING=9 PERPENDICULAR_PARKING value
             * @property {number} ANGLED_PARKING_60=10 ANGLED_PARKING_60 value
             * @property {number} CROSSWALK=11 CROSSWALK value
             * @property {number} PARKING=12 PARKING value
             */
            Marking.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "SOLID"] = 2;
                values[valuesById[3] = "DASH"] = 3;
                values[valuesById[4] = "CURB"] = 4;
                values[valuesById[5] = "DOUBLE_SOLID"] = 5;
                values[valuesById[6] = "SOLID_RIGHT_DASH"] = 6;
                values[valuesById[7] = "SOLID_LEFT_DASH"] = 7;
                values[valuesById[8] = "PARALLEL_PARKING"] = 8;
                values[valuesById[9] = "PERPENDICULAR_PARKING"] = 9;
                values[valuesById[10] = "ANGLED_PARKING_60"] = 10;
                values[valuesById[11] = "CROSSWALK"] = 11;
                values[valuesById[12] = "PARKING"] = 12;
                return values;
            })();

            /**
             * Color enum.
             * @name metamoto.types.Marking.Color
             * @enum {string}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} WHITE=2 WHITE value
             * @property {number} YELLOW=3 YELLOW value
             * @property {number} RED=4 RED value
             * @property {number} GREEN=5 GREEN value
             * @property {number} BLUE=6 BLUE value
             */
            Marking.Color = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "WHITE"] = 2;
                values[valuesById[3] = "YELLOW"] = 3;
                values[valuesById[4] = "RED"] = 4;
                values[valuesById[5] = "GREEN"] = 5;
                values[valuesById[6] = "BLUE"] = 6;
                return values;
            })();

            return Marking;
        })();

        types.Lane = (function() {

            /**
             * Properties of a Lane.
             * @memberof metamoto.types
             * @interface ILane
             * @property {number|null} [index] Lane index
             * @property {string|null} [id] Lane id
             * @property {metamoto.types.Lane.Type|null} [type] Lane type
             * @property {number|null} [width0] Lane width0
             * @property {number|null} [width1] Lane width1
             * @property {number|null} [center0] Lane center0
             * @property {number|null} [center1] Lane center1
             * @property {Array.<metamoto.types.IMarking>|null} [markings] Lane markings
             */

            /**
             * Constructs a new Lane.
             * @memberof metamoto.types
             * @classdesc Represents a Lane.
             * @implements ILane
             * @constructor
             * @param {metamoto.types.ILane=} [properties] Properties to set
             */
            function Lane(properties) {
                this.markings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Lane index.
             * @member {number} index
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.index = 0;

            /**
             * Lane id.
             * @member {string} id
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.id = "";

            /**
             * Lane type.
             * @member {metamoto.types.Lane.Type} type
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.type = 0;

            /**
             * Lane width0.
             * @member {number} width0
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.width0 = 0;

            /**
             * Lane width1.
             * @member {number} width1
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.width1 = 0;

            /**
             * Lane center0.
             * @member {number} center0
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.center0 = 0;

            /**
             * Lane center1.
             * @member {number} center1
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.center1 = 0;

            /**
             * Lane markings.
             * @member {Array.<metamoto.types.IMarking>} markings
             * @memberof metamoto.types.Lane
             * @instance
             */
            Lane.prototype.markings = $util.emptyArray;

            /**
             * Creates a new Lane instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Lane
             * @static
             * @param {metamoto.types.ILane=} [properties] Properties to set
             * @returns {metamoto.types.Lane} Lane instance
             */
            Lane.create = function create(properties) {
                return new Lane(properties);
            };

            /**
             * Encodes the specified Lane message. Does not implicitly {@link metamoto.types.Lane.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Lane
             * @static
             * @param {metamoto.types.ILane} message Lane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.width0 != null && message.hasOwnProperty("width0"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.width0);
                if (message.width1 != null && message.hasOwnProperty("width1"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.width1);
                if (message.center0 != null && message.hasOwnProperty("center0"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.center0);
                if (message.center1 != null && message.hasOwnProperty("center1"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.center1);
                if (message.markings != null && message.markings.length)
                    for (var i = 0; i < message.markings.length; ++i)
                        $root.metamoto.types.Marking.encode(message.markings[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Lane message, length delimited. Does not implicitly {@link metamoto.types.Lane.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Lane
             * @static
             * @param {metamoto.types.ILane} message Lane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lane.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Lane message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Lane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Lane} Lane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Lane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.int32();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.width0 = reader.float();
                        break;
                    case 5:
                        message.width1 = reader.float();
                        break;
                    case 6:
                        message.center0 = reader.float();
                        break;
                    case 7:
                        message.center1 = reader.float();
                        break;
                    case 8:
                        if (!(message.markings && message.markings.length))
                            message.markings = [];
                        message.markings.push($root.metamoto.types.Marking.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Lane message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Lane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Lane} Lane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lane.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Lane message.
             * @function verify
             * @memberof metamoto.types.Lane
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Lane.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.width0 != null && message.hasOwnProperty("width0"))
                    if (typeof message.width0 !== "number")
                        return "width0: number expected";
                if (message.width1 != null && message.hasOwnProperty("width1"))
                    if (typeof message.width1 !== "number")
                        return "width1: number expected";
                if (message.center0 != null && message.hasOwnProperty("center0"))
                    if (typeof message.center0 !== "number")
                        return "center0: number expected";
                if (message.center1 != null && message.hasOwnProperty("center1"))
                    if (typeof message.center1 !== "number")
                        return "center1: number expected";
                if (message.markings != null && message.hasOwnProperty("markings")) {
                    if (!Array.isArray(message.markings))
                        return "markings: array expected";
                    for (var i = 0; i < message.markings.length; ++i) {
                        var error = $root.metamoto.types.Marking.verify(message.markings[i]);
                        if (error)
                            return "markings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Lane message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Lane
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Lane} Lane
             */
            Lane.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Lane)
                    return object;
                var message = new $root.metamoto.types.Lane();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "MEDIAN":
                case 2:
                    message.type = 2;
                    break;
                case "CAR_LANE":
                case 3:
                    message.type = 3;
                    break;
                case "PARALLEL_PARKING_LANE":
                case 4:
                    message.type = 4;
                    break;
                case "BIKE_LANE":
                case 5:
                    message.type = 5;
                    break;
                case "SHOULDER":
                case 6:
                    message.type = 6;
                    break;
                case "PERPENDICULAR_PARKING_LANE":
                case 7:
                    message.type = 7;
                    break;
                case "ANGLED_PARKING_60_LANE":
                case 8:
                    message.type = 8;
                    break;
                case "PARKING_LANE":
                case 9:
                    message.type = 9;
                    break;
                }
                if (object.width0 != null)
                    message.width0 = Number(object.width0);
                if (object.width1 != null)
                    message.width1 = Number(object.width1);
                if (object.center0 != null)
                    message.center0 = Number(object.center0);
                if (object.center1 != null)
                    message.center1 = Number(object.center1);
                if (object.markings) {
                    if (!Array.isArray(object.markings))
                        throw TypeError(".metamoto.types.Lane.markings: array expected");
                    message.markings = [];
                    for (var i = 0; i < object.markings.length; ++i) {
                        if (typeof object.markings[i] !== "object")
                            throw TypeError(".metamoto.types.Lane.markings: object expected");
                        message.markings[i] = $root.metamoto.types.Marking.fromObject(object.markings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Lane message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Lane
             * @static
             * @param {metamoto.types.Lane} message Lane
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Lane.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.markings = [];
                if (options.defaults) {
                    object.index = 0;
                    object.id = "";
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.width0 = 0;
                    object.width1 = 0;
                    object.center0 = 0;
                    object.center1 = 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Lane.Type[message.type] : message.type;
                if (message.width0 != null && message.hasOwnProperty("width0"))
                    object.width0 = options.json && !isFinite(message.width0) ? String(message.width0) : message.width0;
                if (message.width1 != null && message.hasOwnProperty("width1"))
                    object.width1 = options.json && !isFinite(message.width1) ? String(message.width1) : message.width1;
                if (message.center0 != null && message.hasOwnProperty("center0"))
                    object.center0 = options.json && !isFinite(message.center0) ? String(message.center0) : message.center0;
                if (message.center1 != null && message.hasOwnProperty("center1"))
                    object.center1 = options.json && !isFinite(message.center1) ? String(message.center1) : message.center1;
                if (message.markings && message.markings.length) {
                    object.markings = [];
                    for (var j = 0; j < message.markings.length; ++j)
                        object.markings[j] = $root.metamoto.types.Marking.toObject(message.markings[j], options);
                }
                return object;
            };

            /**
             * Converts this Lane to JSON.
             * @function toJSON
             * @memberof metamoto.types.Lane
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Lane.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Lane.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} MEDIAN=2 MEDIAN value
             * @property {number} CAR_LANE=3 CAR_LANE value
             * @property {number} PARALLEL_PARKING_LANE=4 PARALLEL_PARKING_LANE value
             * @property {number} BIKE_LANE=5 BIKE_LANE value
             * @property {number} SHOULDER=6 SHOULDER value
             * @property {number} PERPENDICULAR_PARKING_LANE=7 PERPENDICULAR_PARKING_LANE value
             * @property {number} ANGLED_PARKING_60_LANE=8 ANGLED_PARKING_60_LANE value
             * @property {number} PARKING_LANE=9 PARKING_LANE value
             */
            Lane.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "MEDIAN"] = 2;
                values[valuesById[3] = "CAR_LANE"] = 3;
                values[valuesById[4] = "PARALLEL_PARKING_LANE"] = 4;
                values[valuesById[5] = "BIKE_LANE"] = 5;
                values[valuesById[6] = "SHOULDER"] = 6;
                values[valuesById[7] = "PERPENDICULAR_PARKING_LANE"] = 7;
                values[valuesById[8] = "ANGLED_PARKING_60_LANE"] = 8;
                values[valuesById[9] = "PARKING_LANE"] = 9;
                return values;
            })();

            return Lane;
        })();

        types.LaneLink = (function() {

            /**
             * Properties of a LaneLink.
             * @memberof metamoto.types
             * @interface ILaneLink
             * @property {number|null} [fromLaneIndex] LaneLink fromLaneIndex
             * @property {number|null} [toLaneIndex] LaneLink toLaneIndex
             * @property {string|null} [fromLaneId] LaneLink fromLaneId
             * @property {string|null} [toLaneId] LaneLink toLaneId
             * @property {number|null} [laneIndex] LaneLink laneIndex
             * @property {string|null} [laneId] LaneLink laneId
             */

            /**
             * Constructs a new LaneLink.
             * @memberof metamoto.types
             * @classdesc Represents a LaneLink.
             * @implements ILaneLink
             * @constructor
             * @param {metamoto.types.ILaneLink=} [properties] Properties to set
             */
            function LaneLink(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaneLink fromLaneIndex.
             * @member {number} fromLaneIndex
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.fromLaneIndex = 0;

            /**
             * LaneLink toLaneIndex.
             * @member {number} toLaneIndex
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.toLaneIndex = 0;

            /**
             * LaneLink fromLaneId.
             * @member {string} fromLaneId
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.fromLaneId = "";

            /**
             * LaneLink toLaneId.
             * @member {string} toLaneId
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.toLaneId = "";

            /**
             * LaneLink laneIndex.
             * @member {number} laneIndex
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.laneIndex = 0;

            /**
             * LaneLink laneId.
             * @member {string} laneId
             * @memberof metamoto.types.LaneLink
             * @instance
             */
            LaneLink.prototype.laneId = "";

            /**
             * Creates a new LaneLink instance using the specified properties.
             * @function create
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {metamoto.types.ILaneLink=} [properties] Properties to set
             * @returns {metamoto.types.LaneLink} LaneLink instance
             */
            LaneLink.create = function create(properties) {
                return new LaneLink(properties);
            };

            /**
             * Encodes the specified LaneLink message. Does not implicitly {@link metamoto.types.LaneLink.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {metamoto.types.ILaneLink} message LaneLink message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneLink.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fromLaneIndex);
                if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.toLaneIndex);
                if (message.fromLaneId != null && message.hasOwnProperty("fromLaneId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fromLaneId);
                if (message.toLaneId != null && message.hasOwnProperty("toLaneId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.toLaneId);
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.laneIndex);
                if (message.laneId != null && message.hasOwnProperty("laneId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.laneId);
                return writer;
            };

            /**
             * Encodes the specified LaneLink message, length delimited. Does not implicitly {@link metamoto.types.LaneLink.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {metamoto.types.ILaneLink} message LaneLink message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneLink.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaneLink message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.LaneLink} LaneLink
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneLink.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.LaneLink();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fromLaneIndex = reader.int32();
                        break;
                    case 2:
                        message.toLaneIndex = reader.int32();
                        break;
                    case 3:
                        message.fromLaneId = reader.string();
                        break;
                    case 4:
                        message.toLaneId = reader.string();
                        break;
                    case 5:
                        message.laneIndex = reader.int32();
                        break;
                    case 6:
                        message.laneId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaneLink message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.LaneLink} LaneLink
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneLink.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaneLink message.
             * @function verify
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaneLink.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                    if (!$util.isInteger(message.fromLaneIndex))
                        return "fromLaneIndex: integer expected";
                if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                    if (!$util.isInteger(message.toLaneIndex))
                        return "toLaneIndex: integer expected";
                if (message.fromLaneId != null && message.hasOwnProperty("fromLaneId"))
                    if (!$util.isString(message.fromLaneId))
                        return "fromLaneId: string expected";
                if (message.toLaneId != null && message.hasOwnProperty("toLaneId"))
                    if (!$util.isString(message.toLaneId))
                        return "toLaneId: string expected";
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    if (!$util.isInteger(message.laneIndex))
                        return "laneIndex: integer expected";
                if (message.laneId != null && message.hasOwnProperty("laneId"))
                    if (!$util.isString(message.laneId))
                        return "laneId: string expected";
                return null;
            };

            /**
             * Creates a LaneLink message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.LaneLink} LaneLink
             */
            LaneLink.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.LaneLink)
                    return object;
                var message = new $root.metamoto.types.LaneLink();
                if (object.fromLaneIndex != null)
                    message.fromLaneIndex = object.fromLaneIndex | 0;
                if (object.toLaneIndex != null)
                    message.toLaneIndex = object.toLaneIndex | 0;
                if (object.fromLaneId != null)
                    message.fromLaneId = String(object.fromLaneId);
                if (object.toLaneId != null)
                    message.toLaneId = String(object.toLaneId);
                if (object.laneIndex != null)
                    message.laneIndex = object.laneIndex | 0;
                if (object.laneId != null)
                    message.laneId = String(object.laneId);
                return message;
            };

            /**
             * Creates a plain object from a LaneLink message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.LaneLink
             * @static
             * @param {metamoto.types.LaneLink} message LaneLink
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaneLink.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fromLaneIndex = 0;
                    object.toLaneIndex = 0;
                    object.fromLaneId = "";
                    object.toLaneId = "";
                    object.laneIndex = 0;
                    object.laneId = "";
                }
                if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                    object.fromLaneIndex = message.fromLaneIndex;
                if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                    object.toLaneIndex = message.toLaneIndex;
                if (message.fromLaneId != null && message.hasOwnProperty("fromLaneId"))
                    object.fromLaneId = message.fromLaneId;
                if (message.toLaneId != null && message.hasOwnProperty("toLaneId"))
                    object.toLaneId = message.toLaneId;
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    object.laneIndex = message.laneIndex;
                if (message.laneId != null && message.hasOwnProperty("laneId"))
                    object.laneId = message.laneId;
                return object;
            };

            /**
             * Converts this LaneLink to JSON.
             * @function toJSON
             * @memberof metamoto.types.LaneLink
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaneLink.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LaneLink;
        })();

        types.Signal = (function() {

            /**
             * Properties of a Signal.
             * @memberof metamoto.types
             * @interface ISignal
             * @property {string|null} [id] Signal id
             * @property {metamoto.types.Signal.Type|null} [type] Signal type
             * @property {number|null} [s] Signal s
             * @property {metamoto.types.Signal.ILaneValidity|null} [laneValidity] Signal laneValidity
             */

            /**
             * Constructs a new Signal.
             * @memberof metamoto.types
             * @classdesc Represents a Signal.
             * @implements ISignal
             * @constructor
             * @param {metamoto.types.ISignal=} [properties] Properties to set
             */
            function Signal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Signal id.
             * @member {string} id
             * @memberof metamoto.types.Signal
             * @instance
             */
            Signal.prototype.id = "";

            /**
             * Signal type.
             * @member {metamoto.types.Signal.Type} type
             * @memberof metamoto.types.Signal
             * @instance
             */
            Signal.prototype.type = 0;

            /**
             * Signal s.
             * @member {number} s
             * @memberof metamoto.types.Signal
             * @instance
             */
            Signal.prototype.s = 0;

            /**
             * Signal laneValidity.
             * @member {metamoto.types.Signal.ILaneValidity|null|undefined} laneValidity
             * @memberof metamoto.types.Signal
             * @instance
             */
            Signal.prototype.laneValidity = null;

            /**
             * Creates a new Signal instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Signal
             * @static
             * @param {metamoto.types.ISignal=} [properties] Properties to set
             * @returns {metamoto.types.Signal} Signal instance
             */
            Signal.create = function create(properties) {
                return new Signal(properties);
            };

            /**
             * Encodes the specified Signal message. Does not implicitly {@link metamoto.types.Signal.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Signal
             * @static
             * @param {metamoto.types.ISignal} message Signal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.s != null && message.hasOwnProperty("s"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.s);
                if (message.laneValidity != null && message.hasOwnProperty("laneValidity"))
                    $root.metamoto.types.Signal.LaneValidity.encode(message.laneValidity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Signal message, length delimited. Does not implicitly {@link metamoto.types.Signal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Signal
             * @static
             * @param {metamoto.types.ISignal} message Signal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Signal message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Signal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Signal} Signal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Signal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.s = reader.float();
                        break;
                    case 4:
                        message.laneValidity = $root.metamoto.types.Signal.LaneValidity.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Signal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Signal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Signal} Signal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Signal message.
             * @function verify
             * @memberof metamoto.types.Signal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Signal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.s != null && message.hasOwnProperty("s"))
                    if (typeof message.s !== "number")
                        return "s: number expected";
                if (message.laneValidity != null && message.hasOwnProperty("laneValidity")) {
                    var error = $root.metamoto.types.Signal.LaneValidity.verify(message.laneValidity);
                    if (error)
                        return "laneValidity." + error;
                }
                return null;
            };

            /**
             * Creates a Signal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Signal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Signal} Signal
             */
            Signal.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Signal)
                    return object;
                var message = new $root.metamoto.types.Signal();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "LIGHT":
                case 2:
                    message.type = 2;
                    break;
                case "LEFT_TURN_LIGHT":
                case 3:
                    message.type = 3;
                    break;
                case "RIGHT_TURN_LIGHT":
                case 4:
                    message.type = 4;
                    break;
                case "STOP":
                case 5:
                    message.type = 5;
                    break;
                case "YIELD":
                case 6:
                    message.type = 6;
                    break;
                case "IMPLICIT_YIELD":
                case 7:
                    message.type = 7;
                    break;
                case "DISCONTINUITY":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.s != null)
                    message.s = Number(object.s);
                if (object.laneValidity != null) {
                    if (typeof object.laneValidity !== "object")
                        throw TypeError(".metamoto.types.Signal.laneValidity: object expected");
                    message.laneValidity = $root.metamoto.types.Signal.LaneValidity.fromObject(object.laneValidity);
                }
                return message;
            };

            /**
             * Creates a plain object from a Signal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Signal
             * @static
             * @param {metamoto.types.Signal} message Signal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Signal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.s = 0;
                    object.laneValidity = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Signal.Type[message.type] : message.type;
                if (message.s != null && message.hasOwnProperty("s"))
                    object.s = options.json && !isFinite(message.s) ? String(message.s) : message.s;
                if (message.laneValidity != null && message.hasOwnProperty("laneValidity"))
                    object.laneValidity = $root.metamoto.types.Signal.LaneValidity.toObject(message.laneValidity, options);
                return object;
            };

            /**
             * Converts this Signal to JSON.
             * @function toJSON
             * @memberof metamoto.types.Signal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Signal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Signal.LaneValidity = (function() {

                /**
                 * Properties of a LaneValidity.
                 * @memberof metamoto.types.Signal
                 * @interface ILaneValidity
                 * @property {number|null} [fromLaneIndex] LaneValidity fromLaneIndex
                 * @property {number|null} [toLaneIndex] LaneValidity toLaneIndex
                 */

                /**
                 * Constructs a new LaneValidity.
                 * @memberof metamoto.types.Signal
                 * @classdesc Represents a LaneValidity.
                 * @implements ILaneValidity
                 * @constructor
                 * @param {metamoto.types.Signal.ILaneValidity=} [properties] Properties to set
                 */
                function LaneValidity(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LaneValidity fromLaneIndex.
                 * @member {number} fromLaneIndex
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @instance
                 */
                LaneValidity.prototype.fromLaneIndex = 0;

                /**
                 * LaneValidity toLaneIndex.
                 * @member {number} toLaneIndex
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @instance
                 */
                LaneValidity.prototype.toLaneIndex = 0;

                /**
                 * Creates a new LaneValidity instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {metamoto.types.Signal.ILaneValidity=} [properties] Properties to set
                 * @returns {metamoto.types.Signal.LaneValidity} LaneValidity instance
                 */
                LaneValidity.create = function create(properties) {
                    return new LaneValidity(properties);
                };

                /**
                 * Encodes the specified LaneValidity message. Does not implicitly {@link metamoto.types.Signal.LaneValidity.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {metamoto.types.Signal.ILaneValidity} message LaneValidity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaneValidity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fromLaneIndex);
                    if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.toLaneIndex);
                    return writer;
                };

                /**
                 * Encodes the specified LaneValidity message, length delimited. Does not implicitly {@link metamoto.types.Signal.LaneValidity.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {metamoto.types.Signal.ILaneValidity} message LaneValidity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaneValidity.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LaneValidity message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Signal.LaneValidity} LaneValidity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaneValidity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Signal.LaneValidity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fromLaneIndex = reader.int32();
                            break;
                        case 2:
                            message.toLaneIndex = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LaneValidity message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Signal.LaneValidity} LaneValidity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaneValidity.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LaneValidity message.
                 * @function verify
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaneValidity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                        if (!$util.isInteger(message.fromLaneIndex))
                            return "fromLaneIndex: integer expected";
                    if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                        if (!$util.isInteger(message.toLaneIndex))
                            return "toLaneIndex: integer expected";
                    return null;
                };

                /**
                 * Creates a LaneValidity message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Signal.LaneValidity} LaneValidity
                 */
                LaneValidity.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Signal.LaneValidity)
                        return object;
                    var message = new $root.metamoto.types.Signal.LaneValidity();
                    if (object.fromLaneIndex != null)
                        message.fromLaneIndex = object.fromLaneIndex | 0;
                    if (object.toLaneIndex != null)
                        message.toLaneIndex = object.toLaneIndex | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a LaneValidity message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @static
                 * @param {metamoto.types.Signal.LaneValidity} message LaneValidity
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LaneValidity.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.fromLaneIndex = 0;
                        object.toLaneIndex = 0;
                    }
                    if (message.fromLaneIndex != null && message.hasOwnProperty("fromLaneIndex"))
                        object.fromLaneIndex = message.fromLaneIndex;
                    if (message.toLaneIndex != null && message.hasOwnProperty("toLaneIndex"))
                        object.toLaneIndex = message.toLaneIndex;
                    return object;
                };

                /**
                 * Converts this LaneValidity to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Signal.LaneValidity
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LaneValidity.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LaneValidity;
            })();

            /**
             * Type enum.
             * @name metamoto.types.Signal.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} LIGHT=2 LIGHT value
             * @property {number} LEFT_TURN_LIGHT=3 LEFT_TURN_LIGHT value
             * @property {number} RIGHT_TURN_LIGHT=4 RIGHT_TURN_LIGHT value
             * @property {number} STOP=5 STOP value
             * @property {number} YIELD=6 YIELD value
             * @property {number} IMPLICIT_YIELD=7 IMPLICIT_YIELD value
             * @property {number} DISCONTINUITY=8 DISCONTINUITY value
             */
            Signal.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "LIGHT"] = 2;
                values[valuesById[3] = "LEFT_TURN_LIGHT"] = 3;
                values[valuesById[4] = "RIGHT_TURN_LIGHT"] = 4;
                values[valuesById[5] = "STOP"] = 5;
                values[valuesById[6] = "YIELD"] = 6;
                values[valuesById[7] = "IMPLICIT_YIELD"] = 7;
                values[valuesById[8] = "DISCONTINUITY"] = 8;
                return values;
            })();

            return Signal;
        })();

        types.ConnectingRoad = (function() {

            /**
             * Properties of a ConnectingRoad.
             * @memberof metamoto.types
             * @interface IConnectingRoad
             * @property {string|null} [inJunctionId] ConnectingRoad inJunctionId
             * @property {metamoto.types.ConnectingRoad.Direction|null} [type] ConnectingRoad type
             * @property {Array.<metamoto.types.ILaneLink>|null} [laneLinks] ConnectingRoad laneLinks
             */

            /**
             * Constructs a new ConnectingRoad.
             * @memberof metamoto.types
             * @classdesc Represents a ConnectingRoad.
             * @implements IConnectingRoad
             * @constructor
             * @param {metamoto.types.IConnectingRoad=} [properties] Properties to set
             */
            function ConnectingRoad(properties) {
                this.laneLinks = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectingRoad inJunctionId.
             * @member {string} inJunctionId
             * @memberof metamoto.types.ConnectingRoad
             * @instance
             */
            ConnectingRoad.prototype.inJunctionId = "";

            /**
             * ConnectingRoad type.
             * @member {metamoto.types.ConnectingRoad.Direction} type
             * @memberof metamoto.types.ConnectingRoad
             * @instance
             */
            ConnectingRoad.prototype.type = 0;

            /**
             * ConnectingRoad laneLinks.
             * @member {Array.<metamoto.types.ILaneLink>} laneLinks
             * @memberof metamoto.types.ConnectingRoad
             * @instance
             */
            ConnectingRoad.prototype.laneLinks = $util.emptyArray;

            /**
             * Creates a new ConnectingRoad instance using the specified properties.
             * @function create
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {metamoto.types.IConnectingRoad=} [properties] Properties to set
             * @returns {metamoto.types.ConnectingRoad} ConnectingRoad instance
             */
            ConnectingRoad.create = function create(properties) {
                return new ConnectingRoad(properties);
            };

            /**
             * Encodes the specified ConnectingRoad message. Does not implicitly {@link metamoto.types.ConnectingRoad.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {metamoto.types.IConnectingRoad} message ConnectingRoad message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectingRoad.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inJunctionId != null && message.hasOwnProperty("inJunctionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inJunctionId);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.laneLinks != null && message.laneLinks.length)
                    for (var i = 0; i < message.laneLinks.length; ++i)
                        $root.metamoto.types.LaneLink.encode(message.laneLinks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ConnectingRoad message, length delimited. Does not implicitly {@link metamoto.types.ConnectingRoad.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {metamoto.types.IConnectingRoad} message ConnectingRoad message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectingRoad.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConnectingRoad message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.ConnectingRoad} ConnectingRoad
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectingRoad.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.ConnectingRoad();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inJunctionId = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        if (!(message.laneLinks && message.laneLinks.length))
                            message.laneLinks = [];
                        message.laneLinks.push($root.metamoto.types.LaneLink.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConnectingRoad message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.ConnectingRoad} ConnectingRoad
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectingRoad.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConnectingRoad message.
             * @function verify
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectingRoad.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inJunctionId != null && message.hasOwnProperty("inJunctionId"))
                    if (!$util.isString(message.inJunctionId))
                        return "inJunctionId: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.laneLinks != null && message.hasOwnProperty("laneLinks")) {
                    if (!Array.isArray(message.laneLinks))
                        return "laneLinks: array expected";
                    for (var i = 0; i < message.laneLinks.length; ++i) {
                        var error = $root.metamoto.types.LaneLink.verify(message.laneLinks[i]);
                        if (error)
                            return "laneLinks." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ConnectingRoad message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.ConnectingRoad} ConnectingRoad
             */
            ConnectingRoad.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.ConnectingRoad)
                    return object;
                var message = new $root.metamoto.types.ConnectingRoad();
                if (object.inJunctionId != null)
                    message.inJunctionId = String(object.inJunctionId);
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "STRAIGHT":
                case 2:
                    message.type = 2;
                    break;
                case "RIGHT":
                case 3:
                    message.type = 3;
                    break;
                case "LEFT":
                case 4:
                    message.type = 4;
                    break;
                case "UTURN":
                case 5:
                    message.type = 5;
                    break;
                case "SOFT_RIGHT":
                case 6:
                    message.type = 6;
                    break;
                case "SOFT_LEFT":
                case 7:
                    message.type = 7;
                    break;
                }
                if (object.laneLinks) {
                    if (!Array.isArray(object.laneLinks))
                        throw TypeError(".metamoto.types.ConnectingRoad.laneLinks: array expected");
                    message.laneLinks = [];
                    for (var i = 0; i < object.laneLinks.length; ++i) {
                        if (typeof object.laneLinks[i] !== "object")
                            throw TypeError(".metamoto.types.ConnectingRoad.laneLinks: object expected");
                        message.laneLinks[i] = $root.metamoto.types.LaneLink.fromObject(object.laneLinks[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ConnectingRoad message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.ConnectingRoad
             * @static
             * @param {metamoto.types.ConnectingRoad} message ConnectingRoad
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectingRoad.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.laneLinks = [];
                if (options.defaults) {
                    object.inJunctionId = "";
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.inJunctionId != null && message.hasOwnProperty("inJunctionId"))
                    object.inJunctionId = message.inJunctionId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.ConnectingRoad.Direction[message.type] : message.type;
                if (message.laneLinks && message.laneLinks.length) {
                    object.laneLinks = [];
                    for (var j = 0; j < message.laneLinks.length; ++j)
                        object.laneLinks[j] = $root.metamoto.types.LaneLink.toObject(message.laneLinks[j], options);
                }
                return object;
            };

            /**
             * Converts this ConnectingRoad to JSON.
             * @function toJSON
             * @memberof metamoto.types.ConnectingRoad
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectingRoad.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Direction enum.
             * @name metamoto.types.ConnectingRoad.Direction
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} STRAIGHT=2 STRAIGHT value
             * @property {number} RIGHT=3 RIGHT value
             * @property {number} LEFT=4 LEFT value
             * @property {number} UTURN=5 UTURN value
             * @property {number} SOFT_RIGHT=6 SOFT_RIGHT value
             * @property {number} SOFT_LEFT=7 SOFT_LEFT value
             */
            ConnectingRoad.Direction = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "STRAIGHT"] = 2;
                values[valuesById[3] = "RIGHT"] = 3;
                values[valuesById[4] = "LEFT"] = 4;
                values[valuesById[5] = "UTURN"] = 5;
                values[valuesById[6] = "SOFT_RIGHT"] = 6;
                values[valuesById[7] = "SOFT_LEFT"] = 7;
                return values;
            })();

            return ConnectingRoad;
        })();

        types.LaneSection = (function() {

            /**
             * Properties of a LaneSection.
             * @memberof metamoto.types
             * @interface ILaneSection
             * @property {number|null} [s0] LaneSection s0
             * @property {number|null} [s1] LaneSection s1
             * @property {Array.<metamoto.types.ILane>|null} [lanes] LaneSection lanes
             */

            /**
             * Constructs a new LaneSection.
             * @memberof metamoto.types
             * @classdesc Represents a LaneSection.
             * @implements ILaneSection
             * @constructor
             * @param {metamoto.types.ILaneSection=} [properties] Properties to set
             */
            function LaneSection(properties) {
                this.lanes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaneSection s0.
             * @member {number} s0
             * @memberof metamoto.types.LaneSection
             * @instance
             */
            LaneSection.prototype.s0 = 0;

            /**
             * LaneSection s1.
             * @member {number} s1
             * @memberof metamoto.types.LaneSection
             * @instance
             */
            LaneSection.prototype.s1 = 0;

            /**
             * LaneSection lanes.
             * @member {Array.<metamoto.types.ILane>} lanes
             * @memberof metamoto.types.LaneSection
             * @instance
             */
            LaneSection.prototype.lanes = $util.emptyArray;

            /**
             * Creates a new LaneSection instance using the specified properties.
             * @function create
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {metamoto.types.ILaneSection=} [properties] Properties to set
             * @returns {metamoto.types.LaneSection} LaneSection instance
             */
            LaneSection.create = function create(properties) {
                return new LaneSection(properties);
            };

            /**
             * Encodes the specified LaneSection message. Does not implicitly {@link metamoto.types.LaneSection.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {metamoto.types.ILaneSection} message LaneSection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneSection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.s0 != null && message.hasOwnProperty("s0"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
                if (message.s1 != null && message.hasOwnProperty("s1"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
                if (message.lanes != null && message.lanes.length)
                    for (var i = 0; i < message.lanes.length; ++i)
                        $root.metamoto.types.Lane.encode(message.lanes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LaneSection message, length delimited. Does not implicitly {@link metamoto.types.LaneSection.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {metamoto.types.ILaneSection} message LaneSection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneSection.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaneSection message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.LaneSection} LaneSection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneSection.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.LaneSection();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.s0 = reader.float();
                        break;
                    case 2:
                        message.s1 = reader.float();
                        break;
                    case 3:
                        if (!(message.lanes && message.lanes.length))
                            message.lanes = [];
                        message.lanes.push($root.metamoto.types.Lane.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaneSection message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.LaneSection} LaneSection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneSection.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaneSection message.
             * @function verify
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaneSection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.s0 != null && message.hasOwnProperty("s0"))
                    if (typeof message.s0 !== "number")
                        return "s0: number expected";
                if (message.s1 != null && message.hasOwnProperty("s1"))
                    if (typeof message.s1 !== "number")
                        return "s1: number expected";
                if (message.lanes != null && message.hasOwnProperty("lanes")) {
                    if (!Array.isArray(message.lanes))
                        return "lanes: array expected";
                    for (var i = 0; i < message.lanes.length; ++i) {
                        var error = $root.metamoto.types.Lane.verify(message.lanes[i]);
                        if (error)
                            return "lanes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LaneSection message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.LaneSection} LaneSection
             */
            LaneSection.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.LaneSection)
                    return object;
                var message = new $root.metamoto.types.LaneSection();
                if (object.s0 != null)
                    message.s0 = Number(object.s0);
                if (object.s1 != null)
                    message.s1 = Number(object.s1);
                if (object.lanes) {
                    if (!Array.isArray(object.lanes))
                        throw TypeError(".metamoto.types.LaneSection.lanes: array expected");
                    message.lanes = [];
                    for (var i = 0; i < object.lanes.length; ++i) {
                        if (typeof object.lanes[i] !== "object")
                            throw TypeError(".metamoto.types.LaneSection.lanes: object expected");
                        message.lanes[i] = $root.metamoto.types.Lane.fromObject(object.lanes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a LaneSection message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.LaneSection
             * @static
             * @param {metamoto.types.LaneSection} message LaneSection
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaneSection.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.lanes = [];
                if (options.defaults) {
                    object.s0 = 0;
                    object.s1 = 0;
                }
                if (message.s0 != null && message.hasOwnProperty("s0"))
                    object.s0 = options.json && !isFinite(message.s0) ? String(message.s0) : message.s0;
                if (message.s1 != null && message.hasOwnProperty("s1"))
                    object.s1 = options.json && !isFinite(message.s1) ? String(message.s1) : message.s1;
                if (message.lanes && message.lanes.length) {
                    object.lanes = [];
                    for (var j = 0; j < message.lanes.length; ++j)
                        object.lanes[j] = $root.metamoto.types.Lane.toObject(message.lanes[j], options);
                }
                return object;
            };

            /**
             * Converts this LaneSection to JSON.
             * @function toJSON
             * @memberof metamoto.types.LaneSection
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaneSection.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LaneSection;
        })();

        types.Road = (function() {

            /**
             * Properties of a Road.
             * @memberof metamoto.types
             * @interface IRoad
             * @property {string|null} [id] Road id
             * @property {number|null} [length] Road length
             * @property {number|null} [speedLimit] Road speedLimit
             * @property {boolean|null} [oneWay] Road oneWay
             * @property {Array.<metamoto.types.IGeometry>|null} [geometries] Road geometries
             * @property {Array.<metamoto.types.ILaneSection>|null} [laneSections] Road laneSections
             * @property {Array.<metamoto.types.ISignal>|null} [signals] Road signals
             * @property {metamoto.types.IConnectingRoad|null} [connectingRoad] Road connectingRoad
             * @property {Array.<string>|null} [predecessorRoadIds] Road predecessorRoadIds
             * @property {Array.<string>|null} [successorRoadIds] Road successorRoadIds
             * @property {string|null} [predecessorJunctionId] Road predecessorJunctionId
             * @property {string|null} [successorJunctionId] Road successorJunctionId
             * @property {Array.<metamoto.types.IElevation>|null} [elevation] Road elevation
             */

            /**
             * Constructs a new Road.
             * @memberof metamoto.types
             * @classdesc Represents a Road.
             * @implements IRoad
             * @constructor
             * @param {metamoto.types.IRoad=} [properties] Properties to set
             */
            function Road(properties) {
                this.geometries = [];
                this.laneSections = [];
                this.signals = [];
                this.predecessorRoadIds = [];
                this.successorRoadIds = [];
                this.elevation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Road id.
             * @member {string} id
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.id = "";

            /**
             * Road length.
             * @member {number} length
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.length = 0;

            /**
             * Road speedLimit.
             * @member {number} speedLimit
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.speedLimit = 0;

            /**
             * Road oneWay.
             * @member {boolean} oneWay
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.oneWay = false;

            /**
             * Road geometries.
             * @member {Array.<metamoto.types.IGeometry>} geometries
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.geometries = $util.emptyArray;

            /**
             * Road laneSections.
             * @member {Array.<metamoto.types.ILaneSection>} laneSections
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.laneSections = $util.emptyArray;

            /**
             * Road signals.
             * @member {Array.<metamoto.types.ISignal>} signals
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.signals = $util.emptyArray;

            /**
             * Road connectingRoad.
             * @member {metamoto.types.IConnectingRoad|null|undefined} connectingRoad
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.connectingRoad = null;

            /**
             * Road predecessorRoadIds.
             * @member {Array.<string>} predecessorRoadIds
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.predecessorRoadIds = $util.emptyArray;

            /**
             * Road successorRoadIds.
             * @member {Array.<string>} successorRoadIds
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.successorRoadIds = $util.emptyArray;

            /**
             * Road predecessorJunctionId.
             * @member {string} predecessorJunctionId
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.predecessorJunctionId = "";

            /**
             * Road successorJunctionId.
             * @member {string} successorJunctionId
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.successorJunctionId = "";

            /**
             * Road elevation.
             * @member {Array.<metamoto.types.IElevation>} elevation
             * @memberof metamoto.types.Road
             * @instance
             */
            Road.prototype.elevation = $util.emptyArray;

            /**
             * Creates a new Road instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Road
             * @static
             * @param {metamoto.types.IRoad=} [properties] Properties to set
             * @returns {metamoto.types.Road} Road instance
             */
            Road.create = function create(properties) {
                return new Road(properties);
            };

            /**
             * Encodes the specified Road message. Does not implicitly {@link metamoto.types.Road.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Road
             * @static
             * @param {metamoto.types.IRoad} message Road message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Road.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.length != null && message.hasOwnProperty("length"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.length);
                if (message.speedLimit != null && message.hasOwnProperty("speedLimit"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.speedLimit);
                if (message.oneWay != null && message.hasOwnProperty("oneWay"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.oneWay);
                if (message.geometries != null && message.geometries.length)
                    for (var i = 0; i < message.geometries.length; ++i)
                        $root.metamoto.types.Geometry.encode(message.geometries[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.laneSections != null && message.laneSections.length)
                    for (var i = 0; i < message.laneSections.length; ++i)
                        $root.metamoto.types.LaneSection.encode(message.laneSections[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.signals != null && message.signals.length)
                    for (var i = 0; i < message.signals.length; ++i)
                        $root.metamoto.types.Signal.encode(message.signals[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.connectingRoad != null && message.hasOwnProperty("connectingRoad"))
                    $root.metamoto.types.ConnectingRoad.encode(message.connectingRoad, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.predecessorRoadIds != null && message.predecessorRoadIds.length)
                    for (var i = 0; i < message.predecessorRoadIds.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.predecessorRoadIds[i]);
                if (message.successorRoadIds != null && message.successorRoadIds.length)
                    for (var i = 0; i < message.successorRoadIds.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.successorRoadIds[i]);
                if (message.predecessorJunctionId != null && message.hasOwnProperty("predecessorJunctionId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.predecessorJunctionId);
                if (message.successorJunctionId != null && message.hasOwnProperty("successorJunctionId"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.successorJunctionId);
                if (message.elevation != null && message.elevation.length)
                    for (var i = 0; i < message.elevation.length; ++i)
                        $root.metamoto.types.Elevation.encode(message.elevation[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Road message, length delimited. Does not implicitly {@link metamoto.types.Road.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Road
             * @static
             * @param {metamoto.types.IRoad} message Road message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Road.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Road message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Road
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Road} Road
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Road.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Road();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.length = reader.float();
                        break;
                    case 3:
                        message.speedLimit = reader.float();
                        break;
                    case 4:
                        message.oneWay = reader.bool();
                        break;
                    case 5:
                        if (!(message.geometries && message.geometries.length))
                            message.geometries = [];
                        message.geometries.push($root.metamoto.types.Geometry.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.laneSections && message.laneSections.length))
                            message.laneSections = [];
                        message.laneSections.push($root.metamoto.types.LaneSection.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.signals && message.signals.length))
                            message.signals = [];
                        message.signals.push($root.metamoto.types.Signal.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.connectingRoad = $root.metamoto.types.ConnectingRoad.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.predecessorRoadIds && message.predecessorRoadIds.length))
                            message.predecessorRoadIds = [];
                        message.predecessorRoadIds.push(reader.string());
                        break;
                    case 10:
                        if (!(message.successorRoadIds && message.successorRoadIds.length))
                            message.successorRoadIds = [];
                        message.successorRoadIds.push(reader.string());
                        break;
                    case 11:
                        message.predecessorJunctionId = reader.string();
                        break;
                    case 12:
                        message.successorJunctionId = reader.string();
                        break;
                    case 13:
                        if (!(message.elevation && message.elevation.length))
                            message.elevation = [];
                        message.elevation.push($root.metamoto.types.Elevation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Road message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Road
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Road} Road
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Road.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Road message.
             * @function verify
             * @memberof metamoto.types.Road
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Road.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (typeof message.length !== "number")
                        return "length: number expected";
                if (message.speedLimit != null && message.hasOwnProperty("speedLimit"))
                    if (typeof message.speedLimit !== "number")
                        return "speedLimit: number expected";
                if (message.oneWay != null && message.hasOwnProperty("oneWay"))
                    if (typeof message.oneWay !== "boolean")
                        return "oneWay: boolean expected";
                if (message.geometries != null && message.hasOwnProperty("geometries")) {
                    if (!Array.isArray(message.geometries))
                        return "geometries: array expected";
                    for (var i = 0; i < message.geometries.length; ++i) {
                        var error = $root.metamoto.types.Geometry.verify(message.geometries[i]);
                        if (error)
                            return "geometries." + error;
                    }
                }
                if (message.laneSections != null && message.hasOwnProperty("laneSections")) {
                    if (!Array.isArray(message.laneSections))
                        return "laneSections: array expected";
                    for (var i = 0; i < message.laneSections.length; ++i) {
                        var error = $root.metamoto.types.LaneSection.verify(message.laneSections[i]);
                        if (error)
                            return "laneSections." + error;
                    }
                }
                if (message.signals != null && message.hasOwnProperty("signals")) {
                    if (!Array.isArray(message.signals))
                        return "signals: array expected";
                    for (var i = 0; i < message.signals.length; ++i) {
                        var error = $root.metamoto.types.Signal.verify(message.signals[i]);
                        if (error)
                            return "signals." + error;
                    }
                }
                if (message.connectingRoad != null && message.hasOwnProperty("connectingRoad")) {
                    var error = $root.metamoto.types.ConnectingRoad.verify(message.connectingRoad);
                    if (error)
                        return "connectingRoad." + error;
                }
                if (message.predecessorRoadIds != null && message.hasOwnProperty("predecessorRoadIds")) {
                    if (!Array.isArray(message.predecessorRoadIds))
                        return "predecessorRoadIds: array expected";
                    for (var i = 0; i < message.predecessorRoadIds.length; ++i)
                        if (!$util.isString(message.predecessorRoadIds[i]))
                            return "predecessorRoadIds: string[] expected";
                }
                if (message.successorRoadIds != null && message.hasOwnProperty("successorRoadIds")) {
                    if (!Array.isArray(message.successorRoadIds))
                        return "successorRoadIds: array expected";
                    for (var i = 0; i < message.successorRoadIds.length; ++i)
                        if (!$util.isString(message.successorRoadIds[i]))
                            return "successorRoadIds: string[] expected";
                }
                if (message.predecessorJunctionId != null && message.hasOwnProperty("predecessorJunctionId"))
                    if (!$util.isString(message.predecessorJunctionId))
                        return "predecessorJunctionId: string expected";
                if (message.successorJunctionId != null && message.hasOwnProperty("successorJunctionId"))
                    if (!$util.isString(message.successorJunctionId))
                        return "successorJunctionId: string expected";
                if (message.elevation != null && message.hasOwnProperty("elevation")) {
                    if (!Array.isArray(message.elevation))
                        return "elevation: array expected";
                    for (var i = 0; i < message.elevation.length; ++i) {
                        var error = $root.metamoto.types.Elevation.verify(message.elevation[i]);
                        if (error)
                            return "elevation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Road message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Road
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Road} Road
             */
            Road.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Road)
                    return object;
                var message = new $root.metamoto.types.Road();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.length != null)
                    message.length = Number(object.length);
                if (object.speedLimit != null)
                    message.speedLimit = Number(object.speedLimit);
                if (object.oneWay != null)
                    message.oneWay = Boolean(object.oneWay);
                if (object.geometries) {
                    if (!Array.isArray(object.geometries))
                        throw TypeError(".metamoto.types.Road.geometries: array expected");
                    message.geometries = [];
                    for (var i = 0; i < object.geometries.length; ++i) {
                        if (typeof object.geometries[i] !== "object")
                            throw TypeError(".metamoto.types.Road.geometries: object expected");
                        message.geometries[i] = $root.metamoto.types.Geometry.fromObject(object.geometries[i]);
                    }
                }
                if (object.laneSections) {
                    if (!Array.isArray(object.laneSections))
                        throw TypeError(".metamoto.types.Road.laneSections: array expected");
                    message.laneSections = [];
                    for (var i = 0; i < object.laneSections.length; ++i) {
                        if (typeof object.laneSections[i] !== "object")
                            throw TypeError(".metamoto.types.Road.laneSections: object expected");
                        message.laneSections[i] = $root.metamoto.types.LaneSection.fromObject(object.laneSections[i]);
                    }
                }
                if (object.signals) {
                    if (!Array.isArray(object.signals))
                        throw TypeError(".metamoto.types.Road.signals: array expected");
                    message.signals = [];
                    for (var i = 0; i < object.signals.length; ++i) {
                        if (typeof object.signals[i] !== "object")
                            throw TypeError(".metamoto.types.Road.signals: object expected");
                        message.signals[i] = $root.metamoto.types.Signal.fromObject(object.signals[i]);
                    }
                }
                if (object.connectingRoad != null) {
                    if (typeof object.connectingRoad !== "object")
                        throw TypeError(".metamoto.types.Road.connectingRoad: object expected");
                    message.connectingRoad = $root.metamoto.types.ConnectingRoad.fromObject(object.connectingRoad);
                }
                if (object.predecessorRoadIds) {
                    if (!Array.isArray(object.predecessorRoadIds))
                        throw TypeError(".metamoto.types.Road.predecessorRoadIds: array expected");
                    message.predecessorRoadIds = [];
                    for (var i = 0; i < object.predecessorRoadIds.length; ++i)
                        message.predecessorRoadIds[i] = String(object.predecessorRoadIds[i]);
                }
                if (object.successorRoadIds) {
                    if (!Array.isArray(object.successorRoadIds))
                        throw TypeError(".metamoto.types.Road.successorRoadIds: array expected");
                    message.successorRoadIds = [];
                    for (var i = 0; i < object.successorRoadIds.length; ++i)
                        message.successorRoadIds[i] = String(object.successorRoadIds[i]);
                }
                if (object.predecessorJunctionId != null)
                    message.predecessorJunctionId = String(object.predecessorJunctionId);
                if (object.successorJunctionId != null)
                    message.successorJunctionId = String(object.successorJunctionId);
                if (object.elevation) {
                    if (!Array.isArray(object.elevation))
                        throw TypeError(".metamoto.types.Road.elevation: array expected");
                    message.elevation = [];
                    for (var i = 0; i < object.elevation.length; ++i) {
                        if (typeof object.elevation[i] !== "object")
                            throw TypeError(".metamoto.types.Road.elevation: object expected");
                        message.elevation[i] = $root.metamoto.types.Elevation.fromObject(object.elevation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Road message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Road
             * @static
             * @param {metamoto.types.Road} message Road
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Road.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.geometries = [];
                    object.laneSections = [];
                    object.signals = [];
                    object.predecessorRoadIds = [];
                    object.successorRoadIds = [];
                    object.elevation = [];
                }
                if (options.defaults) {
                    object.id = "";
                    object.length = 0;
                    object.speedLimit = 0;
                    object.oneWay = false;
                    object.connectingRoad = null;
                    object.predecessorJunctionId = "";
                    object.successorJunctionId = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
                if (message.speedLimit != null && message.hasOwnProperty("speedLimit"))
                    object.speedLimit = options.json && !isFinite(message.speedLimit) ? String(message.speedLimit) : message.speedLimit;
                if (message.oneWay != null && message.hasOwnProperty("oneWay"))
                    object.oneWay = message.oneWay;
                if (message.geometries && message.geometries.length) {
                    object.geometries = [];
                    for (var j = 0; j < message.geometries.length; ++j)
                        object.geometries[j] = $root.metamoto.types.Geometry.toObject(message.geometries[j], options);
                }
                if (message.laneSections && message.laneSections.length) {
                    object.laneSections = [];
                    for (var j = 0; j < message.laneSections.length; ++j)
                        object.laneSections[j] = $root.metamoto.types.LaneSection.toObject(message.laneSections[j], options);
                }
                if (message.signals && message.signals.length) {
                    object.signals = [];
                    for (var j = 0; j < message.signals.length; ++j)
                        object.signals[j] = $root.metamoto.types.Signal.toObject(message.signals[j], options);
                }
                if (message.connectingRoad != null && message.hasOwnProperty("connectingRoad"))
                    object.connectingRoad = $root.metamoto.types.ConnectingRoad.toObject(message.connectingRoad, options);
                if (message.predecessorRoadIds && message.predecessorRoadIds.length) {
                    object.predecessorRoadIds = [];
                    for (var j = 0; j < message.predecessorRoadIds.length; ++j)
                        object.predecessorRoadIds[j] = message.predecessorRoadIds[j];
                }
                if (message.successorRoadIds && message.successorRoadIds.length) {
                    object.successorRoadIds = [];
                    for (var j = 0; j < message.successorRoadIds.length; ++j)
                        object.successorRoadIds[j] = message.successorRoadIds[j];
                }
                if (message.predecessorJunctionId != null && message.hasOwnProperty("predecessorJunctionId"))
                    object.predecessorJunctionId = message.predecessorJunctionId;
                if (message.successorJunctionId != null && message.hasOwnProperty("successorJunctionId"))
                    object.successorJunctionId = message.successorJunctionId;
                if (message.elevation && message.elevation.length) {
                    object.elevation = [];
                    for (var j = 0; j < message.elevation.length; ++j)
                        object.elevation[j] = $root.metamoto.types.Elevation.toObject(message.elevation[j], options);
                }
                return object;
            };

            /**
             * Converts this Road to JSON.
             * @function toJSON
             * @memberof metamoto.types.Road
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Road.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Road;
        })();

        types.Junction = (function() {

            /**
             * Properties of a Junction.
             * @memberof metamoto.types
             * @interface IJunction
             * @property {string|null} [id] Junction id
             * @property {Array.<metamoto.types.Junction.IConnection>|null} [connections] Junction connections
             * @property {metamoto.types.IVector3|null} [approxLocation] Junction approxLocation
             * @property {string|null} [vectorId] Junction vectorId
             */

            /**
             * Constructs a new Junction.
             * @memberof metamoto.types
             * @classdesc Represents a Junction.
             * @implements IJunction
             * @constructor
             * @param {metamoto.types.IJunction=} [properties] Properties to set
             */
            function Junction(properties) {
                this.connections = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Junction id.
             * @member {string} id
             * @memberof metamoto.types.Junction
             * @instance
             */
            Junction.prototype.id = "";

            /**
             * Junction connections.
             * @member {Array.<metamoto.types.Junction.IConnection>} connections
             * @memberof metamoto.types.Junction
             * @instance
             */
            Junction.prototype.connections = $util.emptyArray;

            /**
             * Junction approxLocation.
             * @member {metamoto.types.IVector3|null|undefined} approxLocation
             * @memberof metamoto.types.Junction
             * @instance
             */
            Junction.prototype.approxLocation = null;

            /**
             * Junction vectorId.
             * @member {string} vectorId
             * @memberof metamoto.types.Junction
             * @instance
             */
            Junction.prototype.vectorId = "";

            /**
             * Creates a new Junction instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Junction
             * @static
             * @param {metamoto.types.IJunction=} [properties] Properties to set
             * @returns {metamoto.types.Junction} Junction instance
             */
            Junction.create = function create(properties) {
                return new Junction(properties);
            };

            /**
             * Encodes the specified Junction message. Does not implicitly {@link metamoto.types.Junction.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Junction
             * @static
             * @param {metamoto.types.IJunction} message Junction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Junction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.connections != null && message.connections.length)
                    for (var i = 0; i < message.connections.length; ++i)
                        $root.metamoto.types.Junction.Connection.encode(message.connections[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.approxLocation != null && message.hasOwnProperty("approxLocation"))
                    $root.metamoto.types.Vector3.encode(message.approxLocation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.vectorId);
                return writer;
            };

            /**
             * Encodes the specified Junction message, length delimited. Does not implicitly {@link metamoto.types.Junction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Junction
             * @static
             * @param {metamoto.types.IJunction} message Junction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Junction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Junction message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Junction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Junction} Junction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Junction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Junction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (!(message.connections && message.connections.length))
                            message.connections = [];
                        message.connections.push($root.metamoto.types.Junction.Connection.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.approxLocation = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.vectorId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Junction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Junction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Junction} Junction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Junction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Junction message.
             * @function verify
             * @memberof metamoto.types.Junction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Junction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.connections != null && message.hasOwnProperty("connections")) {
                    if (!Array.isArray(message.connections))
                        return "connections: array expected";
                    for (var i = 0; i < message.connections.length; ++i) {
                        var error = $root.metamoto.types.Junction.Connection.verify(message.connections[i]);
                        if (error)
                            return "connections." + error;
                    }
                }
                if (message.approxLocation != null && message.hasOwnProperty("approxLocation")) {
                    var error = $root.metamoto.types.Vector3.verify(message.approxLocation);
                    if (error)
                        return "approxLocation." + error;
                }
                if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                    if (!$util.isString(message.vectorId))
                        return "vectorId: string expected";
                return null;
            };

            /**
             * Creates a Junction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Junction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Junction} Junction
             */
            Junction.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Junction)
                    return object;
                var message = new $root.metamoto.types.Junction();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.connections) {
                    if (!Array.isArray(object.connections))
                        throw TypeError(".metamoto.types.Junction.connections: array expected");
                    message.connections = [];
                    for (var i = 0; i < object.connections.length; ++i) {
                        if (typeof object.connections[i] !== "object")
                            throw TypeError(".metamoto.types.Junction.connections: object expected");
                        message.connections[i] = $root.metamoto.types.Junction.Connection.fromObject(object.connections[i]);
                    }
                }
                if (object.approxLocation != null) {
                    if (typeof object.approxLocation !== "object")
                        throw TypeError(".metamoto.types.Junction.approxLocation: object expected");
                    message.approxLocation = $root.metamoto.types.Vector3.fromObject(object.approxLocation);
                }
                if (object.vectorId != null)
                    message.vectorId = String(object.vectorId);
                return message;
            };

            /**
             * Creates a plain object from a Junction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Junction
             * @static
             * @param {metamoto.types.Junction} message Junction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Junction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.connections = [];
                if (options.defaults) {
                    object.id = "";
                    object.approxLocation = null;
                    object.vectorId = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.connections && message.connections.length) {
                    object.connections = [];
                    for (var j = 0; j < message.connections.length; ++j)
                        object.connections[j] = $root.metamoto.types.Junction.Connection.toObject(message.connections[j], options);
                }
                if (message.approxLocation != null && message.hasOwnProperty("approxLocation"))
                    object.approxLocation = $root.metamoto.types.Vector3.toObject(message.approxLocation, options);
                if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                    object.vectorId = message.vectorId;
                return object;
            };

            /**
             * Converts this Junction to JSON.
             * @function toJSON
             * @memberof metamoto.types.Junction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Junction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Junction.Connection = (function() {

                /**
                 * Properties of a Connection.
                 * @memberof metamoto.types.Junction
                 * @interface IConnection
                 * @property {metamoto.types.Junction.Connection.IRoadLink|null} [fromRoad] Connection fromRoad
                 * @property {metamoto.types.Junction.Connection.IRoadLink|null} [toRoad] Connection toRoad
                 * @property {string|null} [connectingRoadId] Connection connectingRoadId
                 */

                /**
                 * Constructs a new Connection.
                 * @memberof metamoto.types.Junction
                 * @classdesc Represents a Connection.
                 * @implements IConnection
                 * @constructor
                 * @param {metamoto.types.Junction.IConnection=} [properties] Properties to set
                 */
                function Connection(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Connection fromRoad.
                 * @member {metamoto.types.Junction.Connection.IRoadLink|null|undefined} fromRoad
                 * @memberof metamoto.types.Junction.Connection
                 * @instance
                 */
                Connection.prototype.fromRoad = null;

                /**
                 * Connection toRoad.
                 * @member {metamoto.types.Junction.Connection.IRoadLink|null|undefined} toRoad
                 * @memberof metamoto.types.Junction.Connection
                 * @instance
                 */
                Connection.prototype.toRoad = null;

                /**
                 * Connection connectingRoadId.
                 * @member {string} connectingRoadId
                 * @memberof metamoto.types.Junction.Connection
                 * @instance
                 */
                Connection.prototype.connectingRoadId = "";

                /**
                 * Creates a new Connection instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {metamoto.types.Junction.IConnection=} [properties] Properties to set
                 * @returns {metamoto.types.Junction.Connection} Connection instance
                 */
                Connection.create = function create(properties) {
                    return new Connection(properties);
                };

                /**
                 * Encodes the specified Connection message. Does not implicitly {@link metamoto.types.Junction.Connection.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {metamoto.types.Junction.IConnection} message Connection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Connection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fromRoad != null && message.hasOwnProperty("fromRoad"))
                        $root.metamoto.types.Junction.Connection.RoadLink.encode(message.fromRoad, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.toRoad != null && message.hasOwnProperty("toRoad"))
                        $root.metamoto.types.Junction.Connection.RoadLink.encode(message.toRoad, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.connectingRoadId != null && message.hasOwnProperty("connectingRoadId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.connectingRoadId);
                    return writer;
                };

                /**
                 * Encodes the specified Connection message, length delimited. Does not implicitly {@link metamoto.types.Junction.Connection.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {metamoto.types.Junction.IConnection} message Connection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Connection.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Connection message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Junction.Connection} Connection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Connection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Junction.Connection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fromRoad = $root.metamoto.types.Junction.Connection.RoadLink.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.toRoad = $root.metamoto.types.Junction.Connection.RoadLink.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.connectingRoadId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Connection message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Junction.Connection} Connection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Connection.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Connection message.
                 * @function verify
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Connection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fromRoad != null && message.hasOwnProperty("fromRoad")) {
                        var error = $root.metamoto.types.Junction.Connection.RoadLink.verify(message.fromRoad);
                        if (error)
                            return "fromRoad." + error;
                    }
                    if (message.toRoad != null && message.hasOwnProperty("toRoad")) {
                        var error = $root.metamoto.types.Junction.Connection.RoadLink.verify(message.toRoad);
                        if (error)
                            return "toRoad." + error;
                    }
                    if (message.connectingRoadId != null && message.hasOwnProperty("connectingRoadId"))
                        if (!$util.isString(message.connectingRoadId))
                            return "connectingRoadId: string expected";
                    return null;
                };

                /**
                 * Creates a Connection message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Junction.Connection} Connection
                 */
                Connection.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Junction.Connection)
                        return object;
                    var message = new $root.metamoto.types.Junction.Connection();
                    if (object.fromRoad != null) {
                        if (typeof object.fromRoad !== "object")
                            throw TypeError(".metamoto.types.Junction.Connection.fromRoad: object expected");
                        message.fromRoad = $root.metamoto.types.Junction.Connection.RoadLink.fromObject(object.fromRoad);
                    }
                    if (object.toRoad != null) {
                        if (typeof object.toRoad !== "object")
                            throw TypeError(".metamoto.types.Junction.Connection.toRoad: object expected");
                        message.toRoad = $root.metamoto.types.Junction.Connection.RoadLink.fromObject(object.toRoad);
                    }
                    if (object.connectingRoadId != null)
                        message.connectingRoadId = String(object.connectingRoadId);
                    return message;
                };

                /**
                 * Creates a plain object from a Connection message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Junction.Connection
                 * @static
                 * @param {metamoto.types.Junction.Connection} message Connection
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Connection.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.fromRoad = null;
                        object.toRoad = null;
                        object.connectingRoadId = "";
                    }
                    if (message.fromRoad != null && message.hasOwnProperty("fromRoad"))
                        object.fromRoad = $root.metamoto.types.Junction.Connection.RoadLink.toObject(message.fromRoad, options);
                    if (message.toRoad != null && message.hasOwnProperty("toRoad"))
                        object.toRoad = $root.metamoto.types.Junction.Connection.RoadLink.toObject(message.toRoad, options);
                    if (message.connectingRoadId != null && message.hasOwnProperty("connectingRoadId"))
                        object.connectingRoadId = message.connectingRoadId;
                    return object;
                };

                /**
                 * Converts this Connection to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Junction.Connection
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Connection.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Connection.RoadLink = (function() {

                    /**
                     * Properties of a RoadLink.
                     * @memberof metamoto.types.Junction.Connection
                     * @interface IRoadLink
                     * @property {string|null} [roadId] RoadLink roadId
                     * @property {metamoto.types.Junction.Connection.RoadLink.ContactType|null} [contactType] RoadLink contactType
                     */

                    /**
                     * Constructs a new RoadLink.
                     * @memberof metamoto.types.Junction.Connection
                     * @classdesc Represents a RoadLink.
                     * @implements IRoadLink
                     * @constructor
                     * @param {metamoto.types.Junction.Connection.IRoadLink=} [properties] Properties to set
                     */
                    function RoadLink(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RoadLink roadId.
                     * @member {string} roadId
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @instance
                     */
                    RoadLink.prototype.roadId = "";

                    /**
                     * RoadLink contactType.
                     * @member {metamoto.types.Junction.Connection.RoadLink.ContactType} contactType
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @instance
                     */
                    RoadLink.prototype.contactType = 0;

                    /**
                     * Creates a new RoadLink instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {metamoto.types.Junction.Connection.IRoadLink=} [properties] Properties to set
                     * @returns {metamoto.types.Junction.Connection.RoadLink} RoadLink instance
                     */
                    RoadLink.create = function create(properties) {
                        return new RoadLink(properties);
                    };

                    /**
                     * Encodes the specified RoadLink message. Does not implicitly {@link metamoto.types.Junction.Connection.RoadLink.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {metamoto.types.Junction.Connection.IRoadLink} message RoadLink message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RoadLink.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.roadId != null && message.hasOwnProperty("roadId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.roadId);
                        if (message.contactType != null && message.hasOwnProperty("contactType"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contactType);
                        return writer;
                    };

                    /**
                     * Encodes the specified RoadLink message, length delimited. Does not implicitly {@link metamoto.types.Junction.Connection.RoadLink.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {metamoto.types.Junction.Connection.IRoadLink} message RoadLink message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RoadLink.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RoadLink message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Junction.Connection.RoadLink} RoadLink
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RoadLink.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Junction.Connection.RoadLink();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.roadId = reader.string();
                                break;
                            case 2:
                                message.contactType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RoadLink message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Junction.Connection.RoadLink} RoadLink
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RoadLink.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RoadLink message.
                     * @function verify
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RoadLink.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.roadId != null && message.hasOwnProperty("roadId"))
                            if (!$util.isString(message.roadId))
                                return "roadId: string expected";
                        if (message.contactType != null && message.hasOwnProperty("contactType"))
                            switch (message.contactType) {
                            default:
                                return "contactType: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a RoadLink message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Junction.Connection.RoadLink} RoadLink
                     */
                    RoadLink.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Junction.Connection.RoadLink)
                            return object;
                        var message = new $root.metamoto.types.Junction.Connection.RoadLink();
                        if (object.roadId != null)
                            message.roadId = String(object.roadId);
                        switch (object.contactType) {
                        case "START":
                        case 0:
                            message.contactType = 0;
                            break;
                        case "END":
                        case 1:
                            message.contactType = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RoadLink message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @static
                     * @param {metamoto.types.Junction.Connection.RoadLink} message RoadLink
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RoadLink.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.roadId = "";
                            object.contactType = options.enums === String ? "START" : 0;
                        }
                        if (message.roadId != null && message.hasOwnProperty("roadId"))
                            object.roadId = message.roadId;
                        if (message.contactType != null && message.hasOwnProperty("contactType"))
                            object.contactType = options.enums === String ? $root.metamoto.types.Junction.Connection.RoadLink.ContactType[message.contactType] : message.contactType;
                        return object;
                    };

                    /**
                     * Converts this RoadLink to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Junction.Connection.RoadLink
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RoadLink.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * ContactType enum.
                     * @name metamoto.types.Junction.Connection.RoadLink.ContactType
                     * @enum {string}
                     * @property {number} START=0 START value
                     * @property {number} END=1 END value
                     */
                    RoadLink.ContactType = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "START"] = 0;
                        values[valuesById[1] = "END"] = 1;
                        return values;
                    })();

                    return RoadLink;
                })();

                return Connection;
            })();

            return Junction;
        })();

        types.RoadNetwork = (function() {

            /**
             * Properties of a RoadNetwork.
             * @memberof metamoto.types
             * @interface IRoadNetwork
             * @property {string|null} [id] RoadNetwork id
             * @property {Array.<metamoto.types.IRoad>|null} [roads] RoadNetwork roads
             * @property {Array.<metamoto.types.IJunction>|null} [junctions] RoadNetwork junctions
             * @property {metamoto.types.IGeoCoordinates|null} [originCoordinates] RoadNetwork originCoordinates
             */

            /**
             * Constructs a new RoadNetwork.
             * @memberof metamoto.types
             * @classdesc Represents a RoadNetwork.
             * @implements IRoadNetwork
             * @constructor
             * @param {metamoto.types.IRoadNetwork=} [properties] Properties to set
             */
            function RoadNetwork(properties) {
                this.roads = [];
                this.junctions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoadNetwork id.
             * @member {string} id
             * @memberof metamoto.types.RoadNetwork
             * @instance
             */
            RoadNetwork.prototype.id = "";

            /**
             * RoadNetwork roads.
             * @member {Array.<metamoto.types.IRoad>} roads
             * @memberof metamoto.types.RoadNetwork
             * @instance
             */
            RoadNetwork.prototype.roads = $util.emptyArray;

            /**
             * RoadNetwork junctions.
             * @member {Array.<metamoto.types.IJunction>} junctions
             * @memberof metamoto.types.RoadNetwork
             * @instance
             */
            RoadNetwork.prototype.junctions = $util.emptyArray;

            /**
             * RoadNetwork originCoordinates.
             * @member {metamoto.types.IGeoCoordinates|null|undefined} originCoordinates
             * @memberof metamoto.types.RoadNetwork
             * @instance
             */
            RoadNetwork.prototype.originCoordinates = null;

            /**
             * Creates a new RoadNetwork instance using the specified properties.
             * @function create
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {metamoto.types.IRoadNetwork=} [properties] Properties to set
             * @returns {metamoto.types.RoadNetwork} RoadNetwork instance
             */
            RoadNetwork.create = function create(properties) {
                return new RoadNetwork(properties);
            };

            /**
             * Encodes the specified RoadNetwork message. Does not implicitly {@link metamoto.types.RoadNetwork.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {metamoto.types.IRoadNetwork} message RoadNetwork message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoadNetwork.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.roads != null && message.roads.length)
                    for (var i = 0; i < message.roads.length; ++i)
                        $root.metamoto.types.Road.encode(message.roads[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.junctions != null && message.junctions.length)
                    for (var i = 0; i < message.junctions.length; ++i)
                        $root.metamoto.types.Junction.encode(message.junctions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.originCoordinates != null && message.hasOwnProperty("originCoordinates"))
                    $root.metamoto.types.GeoCoordinates.encode(message.originCoordinates, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RoadNetwork message, length delimited. Does not implicitly {@link metamoto.types.RoadNetwork.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {metamoto.types.IRoadNetwork} message RoadNetwork message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoadNetwork.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoadNetwork message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.RoadNetwork} RoadNetwork
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoadNetwork.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.RoadNetwork();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (!(message.roads && message.roads.length))
                            message.roads = [];
                        message.roads.push($root.metamoto.types.Road.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.junctions && message.junctions.length))
                            message.junctions = [];
                        message.junctions.push($root.metamoto.types.Junction.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.originCoordinates = $root.metamoto.types.GeoCoordinates.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoadNetwork message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.RoadNetwork} RoadNetwork
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoadNetwork.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoadNetwork message.
             * @function verify
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoadNetwork.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.roads != null && message.hasOwnProperty("roads")) {
                    if (!Array.isArray(message.roads))
                        return "roads: array expected";
                    for (var i = 0; i < message.roads.length; ++i) {
                        var error = $root.metamoto.types.Road.verify(message.roads[i]);
                        if (error)
                            return "roads." + error;
                    }
                }
                if (message.junctions != null && message.hasOwnProperty("junctions")) {
                    if (!Array.isArray(message.junctions))
                        return "junctions: array expected";
                    for (var i = 0; i < message.junctions.length; ++i) {
                        var error = $root.metamoto.types.Junction.verify(message.junctions[i]);
                        if (error)
                            return "junctions." + error;
                    }
                }
                if (message.originCoordinates != null && message.hasOwnProperty("originCoordinates")) {
                    var error = $root.metamoto.types.GeoCoordinates.verify(message.originCoordinates);
                    if (error)
                        return "originCoordinates." + error;
                }
                return null;
            };

            /**
             * Creates a RoadNetwork message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.RoadNetwork} RoadNetwork
             */
            RoadNetwork.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.RoadNetwork)
                    return object;
                var message = new $root.metamoto.types.RoadNetwork();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.roads) {
                    if (!Array.isArray(object.roads))
                        throw TypeError(".metamoto.types.RoadNetwork.roads: array expected");
                    message.roads = [];
                    for (var i = 0; i < object.roads.length; ++i) {
                        if (typeof object.roads[i] !== "object")
                            throw TypeError(".metamoto.types.RoadNetwork.roads: object expected");
                        message.roads[i] = $root.metamoto.types.Road.fromObject(object.roads[i]);
                    }
                }
                if (object.junctions) {
                    if (!Array.isArray(object.junctions))
                        throw TypeError(".metamoto.types.RoadNetwork.junctions: array expected");
                    message.junctions = [];
                    for (var i = 0; i < object.junctions.length; ++i) {
                        if (typeof object.junctions[i] !== "object")
                            throw TypeError(".metamoto.types.RoadNetwork.junctions: object expected");
                        message.junctions[i] = $root.metamoto.types.Junction.fromObject(object.junctions[i]);
                    }
                }
                if (object.originCoordinates != null) {
                    if (typeof object.originCoordinates !== "object")
                        throw TypeError(".metamoto.types.RoadNetwork.originCoordinates: object expected");
                    message.originCoordinates = $root.metamoto.types.GeoCoordinates.fromObject(object.originCoordinates);
                }
                return message;
            };

            /**
             * Creates a plain object from a RoadNetwork message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.RoadNetwork
             * @static
             * @param {metamoto.types.RoadNetwork} message RoadNetwork
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoadNetwork.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.roads = [];
                    object.junctions = [];
                }
                if (options.defaults) {
                    object.id = "";
                    object.originCoordinates = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.roads && message.roads.length) {
                    object.roads = [];
                    for (var j = 0; j < message.roads.length; ++j)
                        object.roads[j] = $root.metamoto.types.Road.toObject(message.roads[j], options);
                }
                if (message.junctions && message.junctions.length) {
                    object.junctions = [];
                    for (var j = 0; j < message.junctions.length; ++j)
                        object.junctions[j] = $root.metamoto.types.Junction.toObject(message.junctions[j], options);
                }
                if (message.originCoordinates != null && message.hasOwnProperty("originCoordinates"))
                    object.originCoordinates = $root.metamoto.types.GeoCoordinates.toObject(message.originCoordinates, options);
                return object;
            };

            /**
             * Converts this RoadNetwork to JSON.
             * @function toJSON
             * @memberof metamoto.types.RoadNetwork
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoadNetwork.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RoadNetwork;
        })();

        types.RoadPoint = (function() {

            /**
             * Properties of a RoadPoint.
             * @memberof metamoto.types
             * @interface IRoadPoint
             * @property {string|null} [roadId] RoadPoint roadId
             * @property {number|null} [laneSectionIndex] RoadPoint laneSectionIndex
             * @property {number|null} [laneIndex] RoadPoint laneIndex
             * @property {number|null} [s] RoadPoint s
             * @property {number|null} [t] RoadPoint t
             * @property {number|null} [headingOffset] RoadPoint headingOffset
             * @property {metamoto.types.IVector3|null} [worldPosition] RoadPoint worldPosition
             */

            /**
             * Constructs a new RoadPoint.
             * @memberof metamoto.types
             * @classdesc Represents a RoadPoint.
             * @implements IRoadPoint
             * @constructor
             * @param {metamoto.types.IRoadPoint=} [properties] Properties to set
             */
            function RoadPoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoadPoint roadId.
             * @member {string} roadId
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.roadId = "";

            /**
             * RoadPoint laneSectionIndex.
             * @member {number} laneSectionIndex
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.laneSectionIndex = 0;

            /**
             * RoadPoint laneIndex.
             * @member {number} laneIndex
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.laneIndex = 0;

            /**
             * RoadPoint s.
             * @member {number} s
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.s = 0;

            /**
             * RoadPoint t.
             * @member {number} t
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.t = 0;

            /**
             * RoadPoint headingOffset.
             * @member {number} headingOffset
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.headingOffset = 0;

            /**
             * RoadPoint worldPosition.
             * @member {metamoto.types.IVector3|null|undefined} worldPosition
             * @memberof metamoto.types.RoadPoint
             * @instance
             */
            RoadPoint.prototype.worldPosition = null;

            /**
             * Creates a new RoadPoint instance using the specified properties.
             * @function create
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {metamoto.types.IRoadPoint=} [properties] Properties to set
             * @returns {metamoto.types.RoadPoint} RoadPoint instance
             */
            RoadPoint.create = function create(properties) {
                return new RoadPoint(properties);
            };

            /**
             * Encodes the specified RoadPoint message. Does not implicitly {@link metamoto.types.RoadPoint.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {metamoto.types.IRoadPoint} message RoadPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoadPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roadId != null && message.hasOwnProperty("roadId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roadId);
                if (message.laneSectionIndex != null && message.hasOwnProperty("laneSectionIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.laneSectionIndex);
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.laneIndex);
                if (message.s != null && message.hasOwnProperty("s"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.s);
                if (message.t != null && message.hasOwnProperty("t"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.t);
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.headingOffset);
                if (message.worldPosition != null && message.hasOwnProperty("worldPosition"))
                    $root.metamoto.types.Vector3.encode(message.worldPosition, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RoadPoint message, length delimited. Does not implicitly {@link metamoto.types.RoadPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {metamoto.types.IRoadPoint} message RoadPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoadPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoadPoint message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.RoadPoint} RoadPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoadPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.RoadPoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roadId = reader.string();
                        break;
                    case 2:
                        message.laneSectionIndex = reader.int32();
                        break;
                    case 3:
                        message.laneIndex = reader.int32();
                        break;
                    case 4:
                        message.s = reader.float();
                        break;
                    case 5:
                        message.t = reader.float();
                        break;
                    case 6:
                        message.headingOffset = reader.float();
                        break;
                    case 7:
                        message.worldPosition = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoadPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.RoadPoint} RoadPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoadPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoadPoint message.
             * @function verify
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoadPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roadId != null && message.hasOwnProperty("roadId"))
                    if (!$util.isString(message.roadId))
                        return "roadId: string expected";
                if (message.laneSectionIndex != null && message.hasOwnProperty("laneSectionIndex"))
                    if (!$util.isInteger(message.laneSectionIndex))
                        return "laneSectionIndex: integer expected";
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    if (!$util.isInteger(message.laneIndex))
                        return "laneIndex: integer expected";
                if (message.s != null && message.hasOwnProperty("s"))
                    if (typeof message.s !== "number")
                        return "s: number expected";
                if (message.t != null && message.hasOwnProperty("t"))
                    if (typeof message.t !== "number")
                        return "t: number expected";
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    if (typeof message.headingOffset !== "number")
                        return "headingOffset: number expected";
                if (message.worldPosition != null && message.hasOwnProperty("worldPosition")) {
                    var error = $root.metamoto.types.Vector3.verify(message.worldPosition);
                    if (error)
                        return "worldPosition." + error;
                }
                return null;
            };

            /**
             * Creates a RoadPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.RoadPoint} RoadPoint
             */
            RoadPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.RoadPoint)
                    return object;
                var message = new $root.metamoto.types.RoadPoint();
                if (object.roadId != null)
                    message.roadId = String(object.roadId);
                if (object.laneSectionIndex != null)
                    message.laneSectionIndex = object.laneSectionIndex | 0;
                if (object.laneIndex != null)
                    message.laneIndex = object.laneIndex | 0;
                if (object.s != null)
                    message.s = Number(object.s);
                if (object.t != null)
                    message.t = Number(object.t);
                if (object.headingOffset != null)
                    message.headingOffset = Number(object.headingOffset);
                if (object.worldPosition != null) {
                    if (typeof object.worldPosition !== "object")
                        throw TypeError(".metamoto.types.RoadPoint.worldPosition: object expected");
                    message.worldPosition = $root.metamoto.types.Vector3.fromObject(object.worldPosition);
                }
                return message;
            };

            /**
             * Creates a plain object from a RoadPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.RoadPoint
             * @static
             * @param {metamoto.types.RoadPoint} message RoadPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoadPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.roadId = "";
                    object.laneSectionIndex = 0;
                    object.laneIndex = 0;
                    object.s = 0;
                    object.t = 0;
                    object.headingOffset = 0;
                    object.worldPosition = null;
                }
                if (message.roadId != null && message.hasOwnProperty("roadId"))
                    object.roadId = message.roadId;
                if (message.laneSectionIndex != null && message.hasOwnProperty("laneSectionIndex"))
                    object.laneSectionIndex = message.laneSectionIndex;
                if (message.laneIndex != null && message.hasOwnProperty("laneIndex"))
                    object.laneIndex = message.laneIndex;
                if (message.s != null && message.hasOwnProperty("s"))
                    object.s = options.json && !isFinite(message.s) ? String(message.s) : message.s;
                if (message.t != null && message.hasOwnProperty("t"))
                    object.t = options.json && !isFinite(message.t) ? String(message.t) : message.t;
                if (message.headingOffset != null && message.hasOwnProperty("headingOffset"))
                    object.headingOffset = options.json && !isFinite(message.headingOffset) ? String(message.headingOffset) : message.headingOffset;
                if (message.worldPosition != null && message.hasOwnProperty("worldPosition"))
                    object.worldPosition = $root.metamoto.types.Vector3.toObject(message.worldPosition, options);
                return object;
            };

            /**
             * Converts this RoadPoint to JSON.
             * @function toJSON
             * @memberof metamoto.types.RoadPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoadPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RoadPoint;
        })();

        types.Scenario = (function() {

            /**
             * Properties of a Scenario.
             * @memberof metamoto.types
             * @interface IScenario
             * @property {string|null} [id] Scenario id
             * @property {string|null} [name] Scenario name
             * @property {string|null} [scene] Scenario scene
             * @property {string|null} [description] Scenario description
             * @property {boolean|null} [readOnly] Scenario readOnly
             * @property {metamoto.types.IVersion|null} [version] Scenario version
             * @property {metamoto.types.Scenario.ISystem|null} [system] Scenario system
             * @property {metamoto.types.Scenario.IObjectives|null} [objectives] Scenario objectives
             * @property {metamoto.types.IEnvironment|null} [environment] Scenario environment
             * @property {metamoto.types.Scenario.IEgoVehicle|null} [egoVehicle] Scenario egoVehicle
             * @property {metamoto.types.Scenario.ITraffic|null} [traffic] Scenario traffic
             * @property {metamoto.types.Scenario.IPedestrians|null} [pedestrians] Scenario pedestrians
             * @property {Object.<string,metamoto.types.Scenario.ITrafficLight>|null} [trafficLights] Scenario trafficLights
             * @property {Array.<metamoto.types.IEvent>|null} [events] Scenario events
             * @property {Array.<metamoto.types.IAsset>|null} [assets] Scenario assets
             * @property {Array.<metamoto.types.Scenario.IEgoVehicle>|null} [egoVehicles] Scenario egoVehicles
             * @property {Object.<string,metamoto.types.Scenario.IIntersection>|null} [intersections] Scenario intersections
             * @property {Object.<string,metamoto.types.IRange>|null} [ranges] Scenario ranges
             */

            /**
             * Constructs a new Scenario.
             * @memberof metamoto.types
             * @classdesc Represents a Scenario.
             * @implements IScenario
             * @constructor
             * @param {metamoto.types.IScenario=} [properties] Properties to set
             */
            function Scenario(properties) {
                this.trafficLights = {};
                this.events = [];
                this.assets = [];
                this.egoVehicles = [];
                this.intersections = {};
                this.ranges = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Scenario id.
             * @member {string} id
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.id = "";

            /**
             * Scenario name.
             * @member {string} name
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.name = "";

            /**
             * Scenario scene.
             * @member {string} scene
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.scene = "";

            /**
             * Scenario description.
             * @member {string} description
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.description = "";

            /**
             * Scenario readOnly.
             * @member {boolean} readOnly
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.readOnly = false;

            /**
             * Scenario version.
             * @member {metamoto.types.IVersion|null|undefined} version
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.version = null;

            /**
             * Scenario system.
             * @member {metamoto.types.Scenario.ISystem|null|undefined} system
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.system = null;

            /**
             * Scenario objectives.
             * @member {metamoto.types.Scenario.IObjectives|null|undefined} objectives
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.objectives = null;

            /**
             * Scenario environment.
             * @member {metamoto.types.IEnvironment|null|undefined} environment
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.environment = null;

            /**
             * Scenario egoVehicle.
             * @member {metamoto.types.Scenario.IEgoVehicle|null|undefined} egoVehicle
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.egoVehicle = null;

            /**
             * Scenario traffic.
             * @member {metamoto.types.Scenario.ITraffic|null|undefined} traffic
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.traffic = null;

            /**
             * Scenario pedestrians.
             * @member {metamoto.types.Scenario.IPedestrians|null|undefined} pedestrians
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.pedestrians = null;

            /**
             * Scenario trafficLights.
             * @member {Object.<string,metamoto.types.Scenario.ITrafficLight>} trafficLights
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.trafficLights = $util.emptyObject;

            /**
             * Scenario events.
             * @member {Array.<metamoto.types.IEvent>} events
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.events = $util.emptyArray;

            /**
             * Scenario assets.
             * @member {Array.<metamoto.types.IAsset>} assets
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.assets = $util.emptyArray;

            /**
             * Scenario egoVehicles.
             * @member {Array.<metamoto.types.Scenario.IEgoVehicle>} egoVehicles
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.egoVehicles = $util.emptyArray;

            /**
             * Scenario intersections.
             * @member {Object.<string,metamoto.types.Scenario.IIntersection>} intersections
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.intersections = $util.emptyObject;

            /**
             * Scenario ranges.
             * @member {Object.<string,metamoto.types.IRange>} ranges
             * @memberof metamoto.types.Scenario
             * @instance
             */
            Scenario.prototype.ranges = $util.emptyObject;

            /**
             * Creates a new Scenario instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Scenario
             * @static
             * @param {metamoto.types.IScenario=} [properties] Properties to set
             * @returns {metamoto.types.Scenario} Scenario instance
             */
            Scenario.create = function create(properties) {
                return new Scenario(properties);
            };

            /**
             * Encodes the specified Scenario message. Does not implicitly {@link metamoto.types.Scenario.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Scenario
             * @static
             * @param {metamoto.types.IScenario} message Scenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scenario.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.scene != null && message.hasOwnProperty("scene"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.scene);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.readOnly);
                if (message.system != null && message.hasOwnProperty("system"))
                    $root.metamoto.types.Scenario.System.encode(message.system, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.objectives != null && message.hasOwnProperty("objectives"))
                    $root.metamoto.types.Scenario.Objectives.encode(message.objectives, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.environment != null && message.hasOwnProperty("environment"))
                    $root.metamoto.types.Environment.encode(message.environment, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    $root.metamoto.types.Scenario.EgoVehicle.encode(message.egoVehicle, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.traffic != null && message.hasOwnProperty("traffic"))
                    $root.metamoto.types.Scenario.Traffic.encode(message.traffic, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians"))
                    $root.metamoto.types.Scenario.Pedestrians.encode(message.pedestrians, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.trafficLights != null && message.hasOwnProperty("trafficLights"))
                    for (var keys = Object.keys(message.trafficLights), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 12, wireType 2 =*/98).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Scenario.TrafficLight.encode(message.trafficLights[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.events != null && message.events.length)
                    for (var i = 0; i < message.events.length; ++i)
                        $root.metamoto.types.Event.encode(message.events[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.assets != null && message.assets.length)
                    for (var i = 0; i < message.assets.length; ++i)
                        $root.metamoto.types.Asset.encode(message.assets[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.egoVehicles != null && message.egoVehicles.length)
                    for (var i = 0; i < message.egoVehicles.length; ++i)
                        $root.metamoto.types.Scenario.EgoVehicle.encode(message.egoVehicles[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.intersections != null && message.hasOwnProperty("intersections"))
                    for (var keys = Object.keys(message.intersections), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 16, wireType 2 =*/130).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Scenario.Intersection.encode(message.intersections[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.metamoto.types.Version.encode(message.version, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.ranges != null && message.hasOwnProperty("ranges"))
                    for (var keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Range.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Scenario message, length delimited. Does not implicitly {@link metamoto.types.Scenario.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Scenario
             * @static
             * @param {metamoto.types.IScenario} message Scenario message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scenario.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Scenario message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Scenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Scenario} Scenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scenario.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.scene = reader.string();
                        break;
                    case 4:
                        message.description = reader.string();
                        break;
                    case 5:
                        message.readOnly = reader.bool();
                        break;
                    case 17:
                        message.version = $root.metamoto.types.Version.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.system = $root.metamoto.types.Scenario.System.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.objectives = $root.metamoto.types.Scenario.Objectives.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.environment = $root.metamoto.types.Environment.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.egoVehicle = $root.metamoto.types.Scenario.EgoVehicle.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.traffic = $root.metamoto.types.Scenario.Traffic.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.pedestrians = $root.metamoto.types.Scenario.Pedestrians.decode(reader, reader.uint32());
                        break;
                    case 12:
                        reader.skip().pos++;
                        if (message.trafficLights === $util.emptyObject)
                            message.trafficLights = {};
                        key = reader.string();
                        reader.pos++;
                        message.trafficLights[key] = $root.metamoto.types.Scenario.TrafficLight.decode(reader, reader.uint32());
                        break;
                    case 13:
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.metamoto.types.Event.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (!(message.assets && message.assets.length))
                            message.assets = [];
                        message.assets.push($root.metamoto.types.Asset.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        if (!(message.egoVehicles && message.egoVehicles.length))
                            message.egoVehicles = [];
                        message.egoVehicles.push($root.metamoto.types.Scenario.EgoVehicle.decode(reader, reader.uint32()));
                        break;
                    case 16:
                        reader.skip().pos++;
                        if (message.intersections === $util.emptyObject)
                            message.intersections = {};
                        key = reader.string();
                        reader.pos++;
                        message.intersections[key] = $root.metamoto.types.Scenario.Intersection.decode(reader, reader.uint32());
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.ranges === $util.emptyObject)
                            message.ranges = {};
                        key = reader.string();
                        reader.pos++;
                        message.ranges[key] = $root.metamoto.types.Range.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Scenario message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Scenario
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Scenario} Scenario
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scenario.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Scenario message.
             * @function verify
             * @memberof metamoto.types.Scenario
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Scenario.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    if (!$util.isString(message.scene))
                        return "scene: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.metamoto.types.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                if (message.system != null && message.hasOwnProperty("system")) {
                    var error = $root.metamoto.types.Scenario.System.verify(message.system);
                    if (error)
                        return "system." + error;
                }
                if (message.objectives != null && message.hasOwnProperty("objectives")) {
                    var error = $root.metamoto.types.Scenario.Objectives.verify(message.objectives);
                    if (error)
                        return "objectives." + error;
                }
                if (message.environment != null && message.hasOwnProperty("environment")) {
                    var error = $root.metamoto.types.Environment.verify(message.environment);
                    if (error)
                        return "environment." + error;
                }
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle")) {
                    var error = $root.metamoto.types.Scenario.EgoVehicle.verify(message.egoVehicle);
                    if (error)
                        return "egoVehicle." + error;
                }
                if (message.traffic != null && message.hasOwnProperty("traffic")) {
                    var error = $root.metamoto.types.Scenario.Traffic.verify(message.traffic);
                    if (error)
                        return "traffic." + error;
                }
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians")) {
                    var error = $root.metamoto.types.Scenario.Pedestrians.verify(message.pedestrians);
                    if (error)
                        return "pedestrians." + error;
                }
                if (message.trafficLights != null && message.hasOwnProperty("trafficLights")) {
                    if (!$util.isObject(message.trafficLights))
                        return "trafficLights: object expected";
                    var key = Object.keys(message.trafficLights);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Scenario.TrafficLight.verify(message.trafficLights[key[i]]);
                        if (error)
                            return "trafficLights." + error;
                    }
                }
                if (message.events != null && message.hasOwnProperty("events")) {
                    if (!Array.isArray(message.events))
                        return "events: array expected";
                    for (var i = 0; i < message.events.length; ++i) {
                        var error = $root.metamoto.types.Event.verify(message.events[i]);
                        if (error)
                            return "events." + error;
                    }
                }
                if (message.assets != null && message.hasOwnProperty("assets")) {
                    if (!Array.isArray(message.assets))
                        return "assets: array expected";
                    for (var i = 0; i < message.assets.length; ++i) {
                        var error = $root.metamoto.types.Asset.verify(message.assets[i]);
                        if (error)
                            return "assets." + error;
                    }
                }
                if (message.egoVehicles != null && message.hasOwnProperty("egoVehicles")) {
                    if (!Array.isArray(message.egoVehicles))
                        return "egoVehicles: array expected";
                    for (var i = 0; i < message.egoVehicles.length; ++i) {
                        var error = $root.metamoto.types.Scenario.EgoVehicle.verify(message.egoVehicles[i]);
                        if (error)
                            return "egoVehicles." + error;
                    }
                }
                if (message.intersections != null && message.hasOwnProperty("intersections")) {
                    if (!$util.isObject(message.intersections))
                        return "intersections: object expected";
                    var key = Object.keys(message.intersections);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Scenario.Intersection.verify(message.intersections[key[i]]);
                        if (error)
                            return "intersections." + error;
                    }
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!$util.isObject(message.ranges))
                        return "ranges: object expected";
                    var key = Object.keys(message.ranges);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Range.verify(message.ranges[key[i]]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Scenario message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Scenario
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Scenario} Scenario
             */
            Scenario.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Scenario)
                    return object;
                var message = new $root.metamoto.types.Scenario();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.scene != null)
                    message.scene = String(object.scene);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".metamoto.types.Scenario.version: object expected");
                    message.version = $root.metamoto.types.Version.fromObject(object.version);
                }
                if (object.system != null) {
                    if (typeof object.system !== "object")
                        throw TypeError(".metamoto.types.Scenario.system: object expected");
                    message.system = $root.metamoto.types.Scenario.System.fromObject(object.system);
                }
                if (object.objectives != null) {
                    if (typeof object.objectives !== "object")
                        throw TypeError(".metamoto.types.Scenario.objectives: object expected");
                    message.objectives = $root.metamoto.types.Scenario.Objectives.fromObject(object.objectives);
                }
                if (object.environment != null) {
                    if (typeof object.environment !== "object")
                        throw TypeError(".metamoto.types.Scenario.environment: object expected");
                    message.environment = $root.metamoto.types.Environment.fromObject(object.environment);
                }
                if (object.egoVehicle != null) {
                    if (typeof object.egoVehicle !== "object")
                        throw TypeError(".metamoto.types.Scenario.egoVehicle: object expected");
                    message.egoVehicle = $root.metamoto.types.Scenario.EgoVehicle.fromObject(object.egoVehicle);
                }
                if (object.traffic != null) {
                    if (typeof object.traffic !== "object")
                        throw TypeError(".metamoto.types.Scenario.traffic: object expected");
                    message.traffic = $root.metamoto.types.Scenario.Traffic.fromObject(object.traffic);
                }
                if (object.pedestrians != null) {
                    if (typeof object.pedestrians !== "object")
                        throw TypeError(".metamoto.types.Scenario.pedestrians: object expected");
                    message.pedestrians = $root.metamoto.types.Scenario.Pedestrians.fromObject(object.pedestrians);
                }
                if (object.trafficLights) {
                    if (typeof object.trafficLights !== "object")
                        throw TypeError(".metamoto.types.Scenario.trafficLights: object expected");
                    message.trafficLights = {};
                    for (var keys = Object.keys(object.trafficLights), i = 0; i < keys.length; ++i) {
                        if (typeof object.trafficLights[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.Scenario.trafficLights: object expected");
                        message.trafficLights[keys[i]] = $root.metamoto.types.Scenario.TrafficLight.fromObject(object.trafficLights[keys[i]]);
                    }
                }
                if (object.events) {
                    if (!Array.isArray(object.events))
                        throw TypeError(".metamoto.types.Scenario.events: array expected");
                    message.events = [];
                    for (var i = 0; i < object.events.length; ++i) {
                        if (typeof object.events[i] !== "object")
                            throw TypeError(".metamoto.types.Scenario.events: object expected");
                        message.events[i] = $root.metamoto.types.Event.fromObject(object.events[i]);
                    }
                }
                if (object.assets) {
                    if (!Array.isArray(object.assets))
                        throw TypeError(".metamoto.types.Scenario.assets: array expected");
                    message.assets = [];
                    for (var i = 0; i < object.assets.length; ++i) {
                        if (typeof object.assets[i] !== "object")
                            throw TypeError(".metamoto.types.Scenario.assets: object expected");
                        message.assets[i] = $root.metamoto.types.Asset.fromObject(object.assets[i]);
                    }
                }
                if (object.egoVehicles) {
                    if (!Array.isArray(object.egoVehicles))
                        throw TypeError(".metamoto.types.Scenario.egoVehicles: array expected");
                    message.egoVehicles = [];
                    for (var i = 0; i < object.egoVehicles.length; ++i) {
                        if (typeof object.egoVehicles[i] !== "object")
                            throw TypeError(".metamoto.types.Scenario.egoVehicles: object expected");
                        message.egoVehicles[i] = $root.metamoto.types.Scenario.EgoVehicle.fromObject(object.egoVehicles[i]);
                    }
                }
                if (object.intersections) {
                    if (typeof object.intersections !== "object")
                        throw TypeError(".metamoto.types.Scenario.intersections: object expected");
                    message.intersections = {};
                    for (var keys = Object.keys(object.intersections), i = 0; i < keys.length; ++i) {
                        if (typeof object.intersections[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.Scenario.intersections: object expected");
                        message.intersections[keys[i]] = $root.metamoto.types.Scenario.Intersection.fromObject(object.intersections[keys[i]]);
                    }
                }
                if (object.ranges) {
                    if (typeof object.ranges !== "object")
                        throw TypeError(".metamoto.types.Scenario.ranges: object expected");
                    message.ranges = {};
                    for (var keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                        if (typeof object.ranges[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.Scenario.ranges: object expected");
                        message.ranges[keys[i]] = $root.metamoto.types.Range.fromObject(object.ranges[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Scenario message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Scenario
             * @static
             * @param {metamoto.types.Scenario} message Scenario
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Scenario.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.events = [];
                    object.assets = [];
                    object.egoVehicles = [];
                }
                if (options.objects || options.defaults) {
                    object.trafficLights = {};
                    object.intersections = {};
                    object.ranges = {};
                }
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.scene = "";
                    object.description = "";
                    object.readOnly = false;
                    object.system = null;
                    object.objectives = null;
                    object.environment = null;
                    object.egoVehicle = null;
                    object.traffic = null;
                    object.pedestrians = null;
                    object.version = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = message.scene;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                if (message.system != null && message.hasOwnProperty("system"))
                    object.system = $root.metamoto.types.Scenario.System.toObject(message.system, options);
                if (message.objectives != null && message.hasOwnProperty("objectives"))
                    object.objectives = $root.metamoto.types.Scenario.Objectives.toObject(message.objectives, options);
                if (message.environment != null && message.hasOwnProperty("environment"))
                    object.environment = $root.metamoto.types.Environment.toObject(message.environment, options);
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    object.egoVehicle = $root.metamoto.types.Scenario.EgoVehicle.toObject(message.egoVehicle, options);
                if (message.traffic != null && message.hasOwnProperty("traffic"))
                    object.traffic = $root.metamoto.types.Scenario.Traffic.toObject(message.traffic, options);
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians"))
                    object.pedestrians = $root.metamoto.types.Scenario.Pedestrians.toObject(message.pedestrians, options);
                var keys2;
                if (message.trafficLights && (keys2 = Object.keys(message.trafficLights)).length) {
                    object.trafficLights = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.trafficLights[keys2[j]] = $root.metamoto.types.Scenario.TrafficLight.toObject(message.trafficLights[keys2[j]], options);
                }
                if (message.events && message.events.length) {
                    object.events = [];
                    for (var j = 0; j < message.events.length; ++j)
                        object.events[j] = $root.metamoto.types.Event.toObject(message.events[j], options);
                }
                if (message.assets && message.assets.length) {
                    object.assets = [];
                    for (var j = 0; j < message.assets.length; ++j)
                        object.assets[j] = $root.metamoto.types.Asset.toObject(message.assets[j], options);
                }
                if (message.egoVehicles && message.egoVehicles.length) {
                    object.egoVehicles = [];
                    for (var j = 0; j < message.egoVehicles.length; ++j)
                        object.egoVehicles[j] = $root.metamoto.types.Scenario.EgoVehicle.toObject(message.egoVehicles[j], options);
                }
                if (message.intersections && (keys2 = Object.keys(message.intersections)).length) {
                    object.intersections = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.intersections[keys2[j]] = $root.metamoto.types.Scenario.Intersection.toObject(message.intersections[keys2[j]], options);
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.metamoto.types.Version.toObject(message.version, options);
                if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                    object.ranges = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.ranges[keys2[j]] = $root.metamoto.types.Range.toObject(message.ranges[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Scenario to JSON.
             * @function toJSON
             * @memberof metamoto.types.Scenario
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Scenario.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Scenario.System = (function() {

                /**
                 * Properties of a System.
                 * @memberof metamoto.types.Scenario
                 * @interface ISystem
                 * @property {number|null} [randomSeed] System randomSeed
                 * @property {string|null} [host] System host
                 * @property {boolean|null} [recordGroundTruth] System recordGroundTruth
                 * @property {boolean|null} [profile] System profile
                 * @property {number|null} [physicsRate] System physicsRate
                 * @property {metamoto.types.Scenario.System.IEncoder|null} [encoder] System encoder
                 * @property {metamoto.types.Scenario.System.ILogger|null} [logger] System logger
                 * @property {metamoto.types.Scenario.System.IRayTracer|null} [rayTracer] System rayTracer
                 * @property {Object.<string,metamoto.types.Scenario.System.IService>|null} [services] System services
                 * @property {metamoto.types.Scenario.System.LevelOfDetail|null} [cameraLod] System cameraLod
                 * @property {metamoto.types.Scenario.System.LevelOfDetail|null} [rayTracerLod] System rayTracerLod
                 */

                /**
                 * Constructs a new System.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents a System.
                 * @implements ISystem
                 * @constructor
                 * @param {metamoto.types.Scenario.ISystem=} [properties] Properties to set
                 */
                function System(properties) {
                    this.services = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * System randomSeed.
                 * @member {number} randomSeed
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.randomSeed = 0;

                /**
                 * System host.
                 * @member {string} host
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.host = "";

                /**
                 * System recordGroundTruth.
                 * @member {boolean} recordGroundTruth
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.recordGroundTruth = false;

                /**
                 * System profile.
                 * @member {boolean} profile
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.profile = false;

                /**
                 * System physicsRate.
                 * @member {number} physicsRate
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.physicsRate = 0;

                /**
                 * System encoder.
                 * @member {metamoto.types.Scenario.System.IEncoder|null|undefined} encoder
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.encoder = null;

                /**
                 * System logger.
                 * @member {metamoto.types.Scenario.System.ILogger|null|undefined} logger
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.logger = null;

                /**
                 * System rayTracer.
                 * @member {metamoto.types.Scenario.System.IRayTracer|null|undefined} rayTracer
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.rayTracer = null;

                /**
                 * System services.
                 * @member {Object.<string,metamoto.types.Scenario.System.IService>} services
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.services = $util.emptyObject;

                /**
                 * System cameraLod.
                 * @member {metamoto.types.Scenario.System.LevelOfDetail} cameraLod
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.cameraLod = 0;

                /**
                 * System rayTracerLod.
                 * @member {metamoto.types.Scenario.System.LevelOfDetail} rayTracerLod
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 */
                System.prototype.rayTracerLod = 0;

                /**
                 * Creates a new System instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {metamoto.types.Scenario.ISystem=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.System} System instance
                 */
                System.create = function create(properties) {
                    return new System(properties);
                };

                /**
                 * Encodes the specified System message. Does not implicitly {@link metamoto.types.Scenario.System.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {metamoto.types.Scenario.ISystem} message System message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                System.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.randomSeed);
                    if (message.host != null && message.hasOwnProperty("host"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
                    if (message.recordGroundTruth != null && message.hasOwnProperty("recordGroundTruth"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recordGroundTruth);
                    if (message.profile != null && message.hasOwnProperty("profile"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.profile);
                    if (message.physicsRate != null && message.hasOwnProperty("physicsRate"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.physicsRate);
                    if (message.encoder != null && message.hasOwnProperty("encoder"))
                        $root.metamoto.types.Scenario.System.Encoder.encode(message.encoder, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.logger != null && message.hasOwnProperty("logger"))
                        $root.metamoto.types.Scenario.System.Logger.encode(message.logger, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.rayTracer != null && message.hasOwnProperty("rayTracer"))
                        $root.metamoto.types.Scenario.System.RayTracer.encode(message.rayTracer, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.services != null && message.hasOwnProperty("services"))
                        for (var keys = Object.keys(message.services), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 9, wireType 2 =*/74).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.metamoto.types.Scenario.System.Service.encode(message.services[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.cameraLod != null && message.hasOwnProperty("cameraLod"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.cameraLod);
                    if (message.rayTracerLod != null && message.hasOwnProperty("rayTracerLod"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.rayTracerLod);
                    return writer;
                };

                /**
                 * Encodes the specified System message, length delimited. Does not implicitly {@link metamoto.types.Scenario.System.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {metamoto.types.Scenario.ISystem} message System message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                System.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a System message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.System} System
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                System.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.System(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.randomSeed = reader.int32();
                            break;
                        case 2:
                            message.host = reader.string();
                            break;
                        case 3:
                            message.recordGroundTruth = reader.bool();
                            break;
                        case 4:
                            message.profile = reader.bool();
                            break;
                        case 5:
                            message.physicsRate = reader.float();
                            break;
                        case 6:
                            message.encoder = $root.metamoto.types.Scenario.System.Encoder.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.logger = $root.metamoto.types.Scenario.System.Logger.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.rayTracer = $root.metamoto.types.Scenario.System.RayTracer.decode(reader, reader.uint32());
                            break;
                        case 9:
                            reader.skip().pos++;
                            if (message.services === $util.emptyObject)
                                message.services = {};
                            key = reader.string();
                            reader.pos++;
                            message.services[key] = $root.metamoto.types.Scenario.System.Service.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.cameraLod = reader.int32();
                            break;
                        case 11:
                            message.rayTracerLod = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a System message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.System} System
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                System.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a System message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                System.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                        if (!$util.isInteger(message.randomSeed))
                            return "randomSeed: integer expected";
                    if (message.host != null && message.hasOwnProperty("host"))
                        if (!$util.isString(message.host))
                            return "host: string expected";
                    if (message.recordGroundTruth != null && message.hasOwnProperty("recordGroundTruth"))
                        if (typeof message.recordGroundTruth !== "boolean")
                            return "recordGroundTruth: boolean expected";
                    if (message.profile != null && message.hasOwnProperty("profile"))
                        if (typeof message.profile !== "boolean")
                            return "profile: boolean expected";
                    if (message.physicsRate != null && message.hasOwnProperty("physicsRate"))
                        if (typeof message.physicsRate !== "number")
                            return "physicsRate: number expected";
                    if (message.encoder != null && message.hasOwnProperty("encoder")) {
                        var error = $root.metamoto.types.Scenario.System.Encoder.verify(message.encoder);
                        if (error)
                            return "encoder." + error;
                    }
                    if (message.logger != null && message.hasOwnProperty("logger")) {
                        var error = $root.metamoto.types.Scenario.System.Logger.verify(message.logger);
                        if (error)
                            return "logger." + error;
                    }
                    if (message.rayTracer != null && message.hasOwnProperty("rayTracer")) {
                        var error = $root.metamoto.types.Scenario.System.RayTracer.verify(message.rayTracer);
                        if (error)
                            return "rayTracer." + error;
                    }
                    if (message.services != null && message.hasOwnProperty("services")) {
                        if (!$util.isObject(message.services))
                            return "services: object expected";
                        var key = Object.keys(message.services);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.metamoto.types.Scenario.System.Service.verify(message.services[key[i]]);
                            if (error)
                                return "services." + error;
                        }
                    }
                    if (message.cameraLod != null && message.hasOwnProperty("cameraLod"))
                        switch (message.cameraLod) {
                        default:
                            return "cameraLod: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.rayTracerLod != null && message.hasOwnProperty("rayTracerLod"))
                        switch (message.rayTracerLod) {
                        default:
                            return "rayTracerLod: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a System message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.System} System
                 */
                System.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.System)
                        return object;
                    var message = new $root.metamoto.types.Scenario.System();
                    if (object.randomSeed != null)
                        message.randomSeed = object.randomSeed | 0;
                    if (object.host != null)
                        message.host = String(object.host);
                    if (object.recordGroundTruth != null)
                        message.recordGroundTruth = Boolean(object.recordGroundTruth);
                    if (object.profile != null)
                        message.profile = Boolean(object.profile);
                    if (object.physicsRate != null)
                        message.physicsRate = Number(object.physicsRate);
                    if (object.encoder != null) {
                        if (typeof object.encoder !== "object")
                            throw TypeError(".metamoto.types.Scenario.System.encoder: object expected");
                        message.encoder = $root.metamoto.types.Scenario.System.Encoder.fromObject(object.encoder);
                    }
                    if (object.logger != null) {
                        if (typeof object.logger !== "object")
                            throw TypeError(".metamoto.types.Scenario.System.logger: object expected");
                        message.logger = $root.metamoto.types.Scenario.System.Logger.fromObject(object.logger);
                    }
                    if (object.rayTracer != null) {
                        if (typeof object.rayTracer !== "object")
                            throw TypeError(".metamoto.types.Scenario.System.rayTracer: object expected");
                        message.rayTracer = $root.metamoto.types.Scenario.System.RayTracer.fromObject(object.rayTracer);
                    }
                    if (object.services) {
                        if (typeof object.services !== "object")
                            throw TypeError(".metamoto.types.Scenario.System.services: object expected");
                        message.services = {};
                        for (var keys = Object.keys(object.services), i = 0; i < keys.length; ++i) {
                            if (typeof object.services[keys[i]] !== "object")
                                throw TypeError(".metamoto.types.Scenario.System.services: object expected");
                            message.services[keys[i]] = $root.metamoto.types.Scenario.System.Service.fromObject(object.services[keys[i]]);
                        }
                    }
                    switch (object.cameraLod) {
                    case "DYNAMIC":
                    case 0:
                        message.cameraLod = 0;
                        break;
                    case "HIGH":
                    case 1:
                        message.cameraLod = 1;
                        break;
                    case "MEDIUM":
                    case 2:
                        message.cameraLod = 2;
                        break;
                    case "LOW":
                    case 3:
                        message.cameraLod = 3;
                        break;
                    }
                    switch (object.rayTracerLod) {
                    case "DYNAMIC":
                    case 0:
                        message.rayTracerLod = 0;
                        break;
                    case "HIGH":
                    case 1:
                        message.rayTracerLod = 1;
                        break;
                    case "MEDIUM":
                    case 2:
                        message.rayTracerLod = 2;
                        break;
                    case "LOW":
                    case 3:
                        message.rayTracerLod = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a System message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.System
                 * @static
                 * @param {metamoto.types.Scenario.System} message System
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                System.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.services = {};
                    if (options.defaults) {
                        object.randomSeed = 0;
                        object.host = "";
                        object.recordGroundTruth = false;
                        object.profile = false;
                        object.physicsRate = 0;
                        object.encoder = null;
                        object.logger = null;
                        object.rayTracer = null;
                        object.cameraLod = options.enums === String ? "DYNAMIC" : 0;
                        object.rayTracerLod = options.enums === String ? "DYNAMIC" : 0;
                    }
                    if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                        object.randomSeed = message.randomSeed;
                    if (message.host != null && message.hasOwnProperty("host"))
                        object.host = message.host;
                    if (message.recordGroundTruth != null && message.hasOwnProperty("recordGroundTruth"))
                        object.recordGroundTruth = message.recordGroundTruth;
                    if (message.profile != null && message.hasOwnProperty("profile"))
                        object.profile = message.profile;
                    if (message.physicsRate != null && message.hasOwnProperty("physicsRate"))
                        object.physicsRate = options.json && !isFinite(message.physicsRate) ? String(message.physicsRate) : message.physicsRate;
                    if (message.encoder != null && message.hasOwnProperty("encoder"))
                        object.encoder = $root.metamoto.types.Scenario.System.Encoder.toObject(message.encoder, options);
                    if (message.logger != null && message.hasOwnProperty("logger"))
                        object.logger = $root.metamoto.types.Scenario.System.Logger.toObject(message.logger, options);
                    if (message.rayTracer != null && message.hasOwnProperty("rayTracer"))
                        object.rayTracer = $root.metamoto.types.Scenario.System.RayTracer.toObject(message.rayTracer, options);
                    var keys2;
                    if (message.services && (keys2 = Object.keys(message.services)).length) {
                        object.services = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.services[keys2[j]] = $root.metamoto.types.Scenario.System.Service.toObject(message.services[keys2[j]], options);
                    }
                    if (message.cameraLod != null && message.hasOwnProperty("cameraLod"))
                        object.cameraLod = options.enums === String ? $root.metamoto.types.Scenario.System.LevelOfDetail[message.cameraLod] : message.cameraLod;
                    if (message.rayTracerLod != null && message.hasOwnProperty("rayTracerLod"))
                        object.rayTracerLod = options.enums === String ? $root.metamoto.types.Scenario.System.LevelOfDetail[message.rayTracerLod] : message.rayTracerLod;
                    return object;
                };

                /**
                 * Converts this System to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.System
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                System.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                System.Encoder = (function() {

                    /**
                     * Properties of an Encoder.
                     * @memberof metamoto.types.Scenario.System
                     * @interface IEncoder
                     * @property {string|null} [ffmpegExe] Encoder ffmpegExe
                     * @property {string|null} [ffmpegCodec] Encoder ffmpegCodec
                     * @property {string|null} [ffmpegCodecOptions] Encoder ffmpegCodecOptions
                     */

                    /**
                     * Constructs a new Encoder.
                     * @memberof metamoto.types.Scenario.System
                     * @classdesc Represents an Encoder.
                     * @implements IEncoder
                     * @constructor
                     * @param {metamoto.types.Scenario.System.IEncoder=} [properties] Properties to set
                     */
                    function Encoder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Encoder ffmpegExe.
                     * @member {string} ffmpegExe
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @instance
                     */
                    Encoder.prototype.ffmpegExe = "";

                    /**
                     * Encoder ffmpegCodec.
                     * @member {string} ffmpegCodec
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @instance
                     */
                    Encoder.prototype.ffmpegCodec = "";

                    /**
                     * Encoder ffmpegCodecOptions.
                     * @member {string} ffmpegCodecOptions
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @instance
                     */
                    Encoder.prototype.ffmpegCodecOptions = "";

                    /**
                     * Creates a new Encoder instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {metamoto.types.Scenario.System.IEncoder=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.System.Encoder} Encoder instance
                     */
                    Encoder.create = function create(properties) {
                        return new Encoder(properties);
                    };

                    /**
                     * Encodes the specified Encoder message. Does not implicitly {@link metamoto.types.Scenario.System.Encoder.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {metamoto.types.Scenario.System.IEncoder} message Encoder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Encoder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ffmpegExe != null && message.hasOwnProperty("ffmpegExe"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ffmpegExe);
                        if (message.ffmpegCodec != null && message.hasOwnProperty("ffmpegCodec"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ffmpegCodec);
                        if (message.ffmpegCodecOptions != null && message.hasOwnProperty("ffmpegCodecOptions"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.ffmpegCodecOptions);
                        return writer;
                    };

                    /**
                     * Encodes the specified Encoder message, length delimited. Does not implicitly {@link metamoto.types.Scenario.System.Encoder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {metamoto.types.Scenario.System.IEncoder} message Encoder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Encoder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Encoder message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.System.Encoder} Encoder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Encoder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.System.Encoder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ffmpegExe = reader.string();
                                break;
                            case 2:
                                message.ffmpegCodec = reader.string();
                                break;
                            case 3:
                                message.ffmpegCodecOptions = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Encoder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.System.Encoder} Encoder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Encoder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Encoder message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Encoder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ffmpegExe != null && message.hasOwnProperty("ffmpegExe"))
                            if (!$util.isString(message.ffmpegExe))
                                return "ffmpegExe: string expected";
                        if (message.ffmpegCodec != null && message.hasOwnProperty("ffmpegCodec"))
                            if (!$util.isString(message.ffmpegCodec))
                                return "ffmpegCodec: string expected";
                        if (message.ffmpegCodecOptions != null && message.hasOwnProperty("ffmpegCodecOptions"))
                            if (!$util.isString(message.ffmpegCodecOptions))
                                return "ffmpegCodecOptions: string expected";
                        return null;
                    };

                    /**
                     * Creates an Encoder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.System.Encoder} Encoder
                     */
                    Encoder.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.System.Encoder)
                            return object;
                        var message = new $root.metamoto.types.Scenario.System.Encoder();
                        if (object.ffmpegExe != null)
                            message.ffmpegExe = String(object.ffmpegExe);
                        if (object.ffmpegCodec != null)
                            message.ffmpegCodec = String(object.ffmpegCodec);
                        if (object.ffmpegCodecOptions != null)
                            message.ffmpegCodecOptions = String(object.ffmpegCodecOptions);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Encoder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @static
                     * @param {metamoto.types.Scenario.System.Encoder} message Encoder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Encoder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ffmpegExe = "";
                            object.ffmpegCodec = "";
                            object.ffmpegCodecOptions = "";
                        }
                        if (message.ffmpegExe != null && message.hasOwnProperty("ffmpegExe"))
                            object.ffmpegExe = message.ffmpegExe;
                        if (message.ffmpegCodec != null && message.hasOwnProperty("ffmpegCodec"))
                            object.ffmpegCodec = message.ffmpegCodec;
                        if (message.ffmpegCodecOptions != null && message.hasOwnProperty("ffmpegCodecOptions"))
                            object.ffmpegCodecOptions = message.ffmpegCodecOptions;
                        return object;
                    };

                    /**
                     * Converts this Encoder to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.System.Encoder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Encoder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Encoder;
                })();

                System.Logger = (function() {

                    /**
                     * Properties of a Logger.
                     * @memberof metamoto.types.Scenario.System
                     * @interface ILogger
                     * @property {string|null} [mode] Logger mode
                     * @property {string|null} [filename] Logger filename
                     * @property {string|null} [address] Logger address
                     * @property {number|null} [port] Logger port
                     */

                    /**
                     * Constructs a new Logger.
                     * @memberof metamoto.types.Scenario.System
                     * @classdesc Represents a Logger.
                     * @implements ILogger
                     * @constructor
                     * @param {metamoto.types.Scenario.System.ILogger=} [properties] Properties to set
                     */
                    function Logger(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Logger mode.
                     * @member {string} mode
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @instance
                     */
                    Logger.prototype.mode = "";

                    /**
                     * Logger filename.
                     * @member {string} filename
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @instance
                     */
                    Logger.prototype.filename = "";

                    /**
                     * Logger address.
                     * @member {string} address
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @instance
                     */
                    Logger.prototype.address = "";

                    /**
                     * Logger port.
                     * @member {number} port
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @instance
                     */
                    Logger.prototype.port = 0;

                    /**
                     * Creates a new Logger instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {metamoto.types.Scenario.System.ILogger=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.System.Logger} Logger instance
                     */
                    Logger.create = function create(properties) {
                        return new Logger(properties);
                    };

                    /**
                     * Encodes the specified Logger message. Does not implicitly {@link metamoto.types.Scenario.System.Logger.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {metamoto.types.Scenario.System.ILogger} message Logger message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Logger.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.mode);
                        if (message.filename != null && message.hasOwnProperty("filename"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.filename);
                        if (message.address != null && message.hasOwnProperty("address"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
                        if (message.port != null && message.hasOwnProperty("port"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.port);
                        return writer;
                    };

                    /**
                     * Encodes the specified Logger message, length delimited. Does not implicitly {@link metamoto.types.Scenario.System.Logger.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {metamoto.types.Scenario.System.ILogger} message Logger message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Logger.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Logger message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.System.Logger} Logger
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Logger.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.System.Logger();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.mode = reader.string();
                                break;
                            case 2:
                                message.filename = reader.string();
                                break;
                            case 3:
                                message.address = reader.string();
                                break;
                            case 4:
                                message.port = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Logger message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.System.Logger} Logger
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Logger.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Logger message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Logger.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            if (!$util.isString(message.mode))
                                return "mode: string expected";
                        if (message.filename != null && message.hasOwnProperty("filename"))
                            if (!$util.isString(message.filename))
                                return "filename: string expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        if (message.port != null && message.hasOwnProperty("port"))
                            if (!$util.isInteger(message.port))
                                return "port: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Logger message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.System.Logger} Logger
                     */
                    Logger.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.System.Logger)
                            return object;
                        var message = new $root.metamoto.types.Scenario.System.Logger();
                        if (object.mode != null)
                            message.mode = String(object.mode);
                        if (object.filename != null)
                            message.filename = String(object.filename);
                        if (object.address != null)
                            message.address = String(object.address);
                        if (object.port != null)
                            message.port = object.port | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Logger message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @static
                     * @param {metamoto.types.Scenario.System.Logger} message Logger
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Logger.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.mode = "";
                            object.filename = "";
                            object.address = "";
                            object.port = 0;
                        }
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            object.mode = message.mode;
                        if (message.filename != null && message.hasOwnProperty("filename"))
                            object.filename = message.filename;
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        if (message.port != null && message.hasOwnProperty("port"))
                            object.port = message.port;
                        return object;
                    };

                    /**
                     * Converts this Logger to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.System.Logger
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Logger.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Logger;
                })();

                System.RayTracer = (function() {

                    /**
                     * Properties of a RayTracer.
                     * @memberof metamoto.types.Scenario.System
                     * @interface IRayTracer
                     * @property {string|null} [url] RayTracer url
                     * @property {boolean|null} [fileMode] RayTracer fileMode
                     * @property {number|null} [fileThreshold] RayTracer fileThreshold
                     */

                    /**
                     * Constructs a new RayTracer.
                     * @memberof metamoto.types.Scenario.System
                     * @classdesc Represents a RayTracer.
                     * @implements IRayTracer
                     * @constructor
                     * @param {metamoto.types.Scenario.System.IRayTracer=} [properties] Properties to set
                     */
                    function RayTracer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RayTracer url.
                     * @member {string} url
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @instance
                     */
                    RayTracer.prototype.url = "";

                    /**
                     * RayTracer fileMode.
                     * @member {boolean} fileMode
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @instance
                     */
                    RayTracer.prototype.fileMode = false;

                    /**
                     * RayTracer fileThreshold.
                     * @member {number} fileThreshold
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @instance
                     */
                    RayTracer.prototype.fileThreshold = 0;

                    /**
                     * Creates a new RayTracer instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {metamoto.types.Scenario.System.IRayTracer=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.System.RayTracer} RayTracer instance
                     */
                    RayTracer.create = function create(properties) {
                        return new RayTracer(properties);
                    };

                    /**
                     * Encodes the specified RayTracer message. Does not implicitly {@link metamoto.types.Scenario.System.RayTracer.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {metamoto.types.Scenario.System.IRayTracer} message RayTracer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RayTracer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.url != null && message.hasOwnProperty("url"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                        if (message.fileMode != null && message.hasOwnProperty("fileMode"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fileMode);
                        if (message.fileThreshold != null && message.hasOwnProperty("fileThreshold"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fileThreshold);
                        return writer;
                    };

                    /**
                     * Encodes the specified RayTracer message, length delimited. Does not implicitly {@link metamoto.types.Scenario.System.RayTracer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {metamoto.types.Scenario.System.IRayTracer} message RayTracer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RayTracer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RayTracer message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.System.RayTracer} RayTracer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RayTracer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.System.RayTracer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.url = reader.string();
                                break;
                            case 2:
                                message.fileMode = reader.bool();
                                break;
                            case 3:
                                message.fileThreshold = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RayTracer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.System.RayTracer} RayTracer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RayTracer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RayTracer message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RayTracer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        if (message.fileMode != null && message.hasOwnProperty("fileMode"))
                            if (typeof message.fileMode !== "boolean")
                                return "fileMode: boolean expected";
                        if (message.fileThreshold != null && message.hasOwnProperty("fileThreshold"))
                            if (!$util.isInteger(message.fileThreshold))
                                return "fileThreshold: integer expected";
                        return null;
                    };

                    /**
                     * Creates a RayTracer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.System.RayTracer} RayTracer
                     */
                    RayTracer.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.System.RayTracer)
                            return object;
                        var message = new $root.metamoto.types.Scenario.System.RayTracer();
                        if (object.url != null)
                            message.url = String(object.url);
                        if (object.fileMode != null)
                            message.fileMode = Boolean(object.fileMode);
                        if (object.fileThreshold != null)
                            message.fileThreshold = object.fileThreshold | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a RayTracer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @static
                     * @param {metamoto.types.Scenario.System.RayTracer} message RayTracer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RayTracer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.url = "";
                            object.fileMode = false;
                            object.fileThreshold = 0;
                        }
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        if (message.fileMode != null && message.hasOwnProperty("fileMode"))
                            object.fileMode = message.fileMode;
                        if (message.fileThreshold != null && message.hasOwnProperty("fileThreshold"))
                            object.fileThreshold = message.fileThreshold;
                        return object;
                    };

                    /**
                     * Converts this RayTracer to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.System.RayTracer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RayTracer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RayTracer;
                })();

                System.Service = (function() {

                    /**
                     * Properties of a Service.
                     * @memberof metamoto.types.Scenario.System
                     * @interface IService
                     * @property {number|null} [port] Service port
                     * @property {number|null} [externalPort] Service externalPort
                     */

                    /**
                     * Constructs a new Service.
                     * @memberof metamoto.types.Scenario.System
                     * @classdesc Represents a Service.
                     * @implements IService
                     * @constructor
                     * @param {metamoto.types.Scenario.System.IService=} [properties] Properties to set
                     */
                    function Service(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Service port.
                     * @member {number} port
                     * @memberof metamoto.types.Scenario.System.Service
                     * @instance
                     */
                    Service.prototype.port = 0;

                    /**
                     * Service externalPort.
                     * @member {number} externalPort
                     * @memberof metamoto.types.Scenario.System.Service
                     * @instance
                     */
                    Service.prototype.externalPort = 0;

                    /**
                     * Creates a new Service instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {metamoto.types.Scenario.System.IService=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.System.Service} Service instance
                     */
                    Service.create = function create(properties) {
                        return new Service(properties);
                    };

                    /**
                     * Encodes the specified Service message. Does not implicitly {@link metamoto.types.Scenario.System.Service.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {metamoto.types.Scenario.System.IService} message Service message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Service.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.port != null && message.hasOwnProperty("port"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.port);
                        if (message.externalPort != null && message.hasOwnProperty("externalPort"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.externalPort);
                        return writer;
                    };

                    /**
                     * Encodes the specified Service message, length delimited. Does not implicitly {@link metamoto.types.Scenario.System.Service.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {metamoto.types.Scenario.System.IService} message Service message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Service.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Service message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.System.Service} Service
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Service.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.System.Service();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.port = reader.int32();
                                break;
                            case 2:
                                message.externalPort = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Service message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.System.Service} Service
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Service.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Service message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Service.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.port != null && message.hasOwnProperty("port"))
                            if (!$util.isInteger(message.port))
                                return "port: integer expected";
                        if (message.externalPort != null && message.hasOwnProperty("externalPort"))
                            if (!$util.isInteger(message.externalPort))
                                return "externalPort: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Service message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.System.Service} Service
                     */
                    Service.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.System.Service)
                            return object;
                        var message = new $root.metamoto.types.Scenario.System.Service();
                        if (object.port != null)
                            message.port = object.port | 0;
                        if (object.externalPort != null)
                            message.externalPort = object.externalPort | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Service message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.System.Service
                     * @static
                     * @param {metamoto.types.Scenario.System.Service} message Service
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Service.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.port = 0;
                            object.externalPort = 0;
                        }
                        if (message.port != null && message.hasOwnProperty("port"))
                            object.port = message.port;
                        if (message.externalPort != null && message.hasOwnProperty("externalPort"))
                            object.externalPort = message.externalPort;
                        return object;
                    };

                    /**
                     * Converts this Service to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.System.Service
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Service.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Service;
                })();

                /**
                 * LevelOfDetail enum.
                 * @name metamoto.types.Scenario.System.LevelOfDetail
                 * @enum {string}
                 * @property {number} DYNAMIC=0 DYNAMIC value
                 * @property {number} HIGH=1 HIGH value
                 * @property {number} MEDIUM=2 MEDIUM value
                 * @property {number} LOW=3 LOW value
                 */
                System.LevelOfDetail = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DYNAMIC"] = 0;
                    values[valuesById[1] = "HIGH"] = 1;
                    values[valuesById[2] = "MEDIUM"] = 2;
                    values[valuesById[3] = "LOW"] = 3;
                    return values;
                })();

                return System;
            })();

            Scenario.Objectives = (function() {

                /**
                 * Properties of an Objectives.
                 * @memberof metamoto.types.Scenario
                 * @interface IObjectives
                 * @property {number|null} [duration] Objectives duration
                 * @property {metamoto.types.IVector3|null} [destinationWorldPoint] Objectives destinationWorldPoint
                 * @property {metamoto.types.IRoadPoint|null} [destinationRoadPoint] Objectives destinationRoadPoint
                 * @property {number|null} [destinationRadius] Objectives destinationRadius
                 * @property {Array.<metamoto.types.IInfraction>|null} [infractions] Objectives infractions
                 * @property {number|null} [randomFailureProbability] Objectives randomFailureProbability
                 * @property {boolean|null} [monitorAllVehicles] Objectives monitorAllVehicles
                 */

                /**
                 * Constructs a new Objectives.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents an Objectives.
                 * @implements IObjectives
                 * @constructor
                 * @param {metamoto.types.Scenario.IObjectives=} [properties] Properties to set
                 */
                function Objectives(properties) {
                    this.infractions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Objectives duration.
                 * @member {number} duration
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.duration = 0;

                /**
                 * Objectives destinationWorldPoint.
                 * @member {metamoto.types.IVector3|null|undefined} destinationWorldPoint
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.destinationWorldPoint = null;

                /**
                 * Objectives destinationRoadPoint.
                 * @member {metamoto.types.IRoadPoint|null|undefined} destinationRoadPoint
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.destinationRoadPoint = null;

                /**
                 * Objectives destinationRadius.
                 * @member {number} destinationRadius
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.destinationRadius = 0;

                /**
                 * Objectives infractions.
                 * @member {Array.<metamoto.types.IInfraction>} infractions
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.infractions = $util.emptyArray;

                /**
                 * Objectives randomFailureProbability.
                 * @member {number} randomFailureProbability
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.randomFailureProbability = 0;

                /**
                 * Objectives monitorAllVehicles.
                 * @member {boolean} monitorAllVehicles
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Objectives.prototype.monitorAllVehicles = false;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Objectives destinationOneof.
                 * @member {"destinationWorldPoint"|"destinationRoadPoint"|undefined} destinationOneof
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 */
                Object.defineProperty(Objectives.prototype, "destinationOneof", {
                    get: $util.oneOfGetter($oneOfFields = ["destinationWorldPoint", "destinationRoadPoint"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Objectives instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {metamoto.types.Scenario.IObjectives=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.Objectives} Objectives instance
                 */
                Objectives.create = function create(properties) {
                    return new Objectives(properties);
                };

                /**
                 * Encodes the specified Objectives message. Does not implicitly {@link metamoto.types.Scenario.Objectives.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {metamoto.types.Scenario.IObjectives} message Objectives message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Objectives.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.duration);
                    if (message.destinationWorldPoint != null && message.hasOwnProperty("destinationWorldPoint"))
                        $root.metamoto.types.Vector3.encode(message.destinationWorldPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.destinationRoadPoint != null && message.hasOwnProperty("destinationRoadPoint"))
                        $root.metamoto.types.RoadPoint.encode(message.destinationRoadPoint, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.destinationRadius != null && message.hasOwnProperty("destinationRadius"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.destinationRadius);
                    if (message.infractions != null && message.infractions.length)
                        for (var i = 0; i < message.infractions.length; ++i)
                            $root.metamoto.types.Infraction.encode(message.infractions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.randomFailureProbability != null && message.hasOwnProperty("randomFailureProbability"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.randomFailureProbability);
                    if (message.monitorAllVehicles != null && message.hasOwnProperty("monitorAllVehicles"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.monitorAllVehicles);
                    return writer;
                };

                /**
                 * Encodes the specified Objectives message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Objectives.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {metamoto.types.Scenario.IObjectives} message Objectives message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Objectives.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Objectives message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.Objectives} Objectives
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Objectives.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Objectives();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.duration = reader.float();
                            break;
                        case 2:
                            message.destinationWorldPoint = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.destinationRoadPoint = $root.metamoto.types.RoadPoint.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.destinationRadius = reader.float();
                            break;
                        case 5:
                            if (!(message.infractions && message.infractions.length))
                                message.infractions = [];
                            message.infractions.push($root.metamoto.types.Infraction.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.randomFailureProbability = reader.float();
                            break;
                        case 7:
                            message.monitorAllVehicles = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Objectives message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.Objectives} Objectives
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Objectives.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Objectives message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Objectives.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        if (typeof message.duration !== "number")
                            return "duration: number expected";
                    if (message.destinationWorldPoint != null && message.hasOwnProperty("destinationWorldPoint")) {
                        properties.destinationOneof = 1;
                        {
                            var error = $root.metamoto.types.Vector3.verify(message.destinationWorldPoint);
                            if (error)
                                return "destinationWorldPoint." + error;
                        }
                    }
                    if (message.destinationRoadPoint != null && message.hasOwnProperty("destinationRoadPoint")) {
                        if (properties.destinationOneof === 1)
                            return "destinationOneof: multiple values";
                        properties.destinationOneof = 1;
                        {
                            var error = $root.metamoto.types.RoadPoint.verify(message.destinationRoadPoint);
                            if (error)
                                return "destinationRoadPoint." + error;
                        }
                    }
                    if (message.destinationRadius != null && message.hasOwnProperty("destinationRadius"))
                        if (typeof message.destinationRadius !== "number")
                            return "destinationRadius: number expected";
                    if (message.infractions != null && message.hasOwnProperty("infractions")) {
                        if (!Array.isArray(message.infractions))
                            return "infractions: array expected";
                        for (var i = 0; i < message.infractions.length; ++i) {
                            var error = $root.metamoto.types.Infraction.verify(message.infractions[i]);
                            if (error)
                                return "infractions." + error;
                        }
                    }
                    if (message.randomFailureProbability != null && message.hasOwnProperty("randomFailureProbability"))
                        if (typeof message.randomFailureProbability !== "number")
                            return "randomFailureProbability: number expected";
                    if (message.monitorAllVehicles != null && message.hasOwnProperty("monitorAllVehicles"))
                        if (typeof message.monitorAllVehicles !== "boolean")
                            return "monitorAllVehicles: boolean expected";
                    return null;
                };

                /**
                 * Creates an Objectives message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.Objectives} Objectives
                 */
                Objectives.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.Objectives)
                        return object;
                    var message = new $root.metamoto.types.Scenario.Objectives();
                    if (object.duration != null)
                        message.duration = Number(object.duration);
                    if (object.destinationWorldPoint != null) {
                        if (typeof object.destinationWorldPoint !== "object")
                            throw TypeError(".metamoto.types.Scenario.Objectives.destinationWorldPoint: object expected");
                        message.destinationWorldPoint = $root.metamoto.types.Vector3.fromObject(object.destinationWorldPoint);
                    }
                    if (object.destinationRoadPoint != null) {
                        if (typeof object.destinationRoadPoint !== "object")
                            throw TypeError(".metamoto.types.Scenario.Objectives.destinationRoadPoint: object expected");
                        message.destinationRoadPoint = $root.metamoto.types.RoadPoint.fromObject(object.destinationRoadPoint);
                    }
                    if (object.destinationRadius != null)
                        message.destinationRadius = Number(object.destinationRadius);
                    if (object.infractions) {
                        if (!Array.isArray(object.infractions))
                            throw TypeError(".metamoto.types.Scenario.Objectives.infractions: array expected");
                        message.infractions = [];
                        for (var i = 0; i < object.infractions.length; ++i) {
                            if (typeof object.infractions[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Objectives.infractions: object expected");
                            message.infractions[i] = $root.metamoto.types.Infraction.fromObject(object.infractions[i]);
                        }
                    }
                    if (object.randomFailureProbability != null)
                        message.randomFailureProbability = Number(object.randomFailureProbability);
                    if (object.monitorAllVehicles != null)
                        message.monitorAllVehicles = Boolean(object.monitorAllVehicles);
                    return message;
                };

                /**
                 * Creates a plain object from an Objectives message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.Objectives
                 * @static
                 * @param {metamoto.types.Scenario.Objectives} message Objectives
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Objectives.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.infractions = [];
                    if (options.defaults) {
                        object.duration = 0;
                        object.destinationRadius = 0;
                        object.randomFailureProbability = 0;
                        object.monitorAllVehicles = false;
                    }
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                    if (message.destinationWorldPoint != null && message.hasOwnProperty("destinationWorldPoint")) {
                        object.destinationWorldPoint = $root.metamoto.types.Vector3.toObject(message.destinationWorldPoint, options);
                        if (options.oneofs)
                            object.destinationOneof = "destinationWorldPoint";
                    }
                    if (message.destinationRoadPoint != null && message.hasOwnProperty("destinationRoadPoint")) {
                        object.destinationRoadPoint = $root.metamoto.types.RoadPoint.toObject(message.destinationRoadPoint, options);
                        if (options.oneofs)
                            object.destinationOneof = "destinationRoadPoint";
                    }
                    if (message.destinationRadius != null && message.hasOwnProperty("destinationRadius"))
                        object.destinationRadius = options.json && !isFinite(message.destinationRadius) ? String(message.destinationRadius) : message.destinationRadius;
                    if (message.infractions && message.infractions.length) {
                        object.infractions = [];
                        for (var j = 0; j < message.infractions.length; ++j)
                            object.infractions[j] = $root.metamoto.types.Infraction.toObject(message.infractions[j], options);
                    }
                    if (message.randomFailureProbability != null && message.hasOwnProperty("randomFailureProbability"))
                        object.randomFailureProbability = options.json && !isFinite(message.randomFailureProbability) ? String(message.randomFailureProbability) : message.randomFailureProbability;
                    if (message.monitorAllVehicles != null && message.hasOwnProperty("monitorAllVehicles"))
                        object.monitorAllVehicles = message.monitorAllVehicles;
                    return object;
                };

                /**
                 * Converts this Objectives to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.Objectives
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Objectives.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Objectives;
            })();

            Scenario.EgoVehicle = (function() {

                /**
                 * Properties of an EgoVehicle.
                 * @memberof metamoto.types.Scenario
                 * @interface IEgoVehicle
                 * @property {Array.<metamoto.types.IWaypoint>|null} [path] EgoVehicle path
                 * @property {metamoto.types.IDriverModel|null} [driverModel] EgoVehicle driverModel
                 * @property {boolean|null} [randomSpawnPoint] EgoVehicle randomSpawnPoint
                 */

                /**
                 * Constructs a new EgoVehicle.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents an EgoVehicle.
                 * @implements IEgoVehicle
                 * @constructor
                 * @param {metamoto.types.Scenario.IEgoVehicle=} [properties] Properties to set
                 */
                function EgoVehicle(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EgoVehicle path.
                 * @member {Array.<metamoto.types.IWaypoint>} path
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @instance
                 */
                EgoVehicle.prototype.path = $util.emptyArray;

                /**
                 * EgoVehicle driverModel.
                 * @member {metamoto.types.IDriverModel|null|undefined} driverModel
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @instance
                 */
                EgoVehicle.prototype.driverModel = null;

                /**
                 * EgoVehicle randomSpawnPoint.
                 * @member {boolean} randomSpawnPoint
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @instance
                 */
                EgoVehicle.prototype.randomSpawnPoint = false;

                /**
                 * Creates a new EgoVehicle instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {metamoto.types.Scenario.IEgoVehicle=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.EgoVehicle} EgoVehicle instance
                 */
                EgoVehicle.create = function create(properties) {
                    return new EgoVehicle(properties);
                };

                /**
                 * Encodes the specified EgoVehicle message. Does not implicitly {@link metamoto.types.Scenario.EgoVehicle.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {metamoto.types.Scenario.IEgoVehicle} message EgoVehicle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EgoVehicle.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length)
                        for (var i = 0; i < message.path.length; ++i)
                            $root.metamoto.types.Waypoint.encode(message.path[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.driverModel != null && message.hasOwnProperty("driverModel"))
                        $root.metamoto.types.DriverModel.encode(message.driverModel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.randomSpawnPoint != null && message.hasOwnProperty("randomSpawnPoint"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.randomSpawnPoint);
                    return writer;
                };

                /**
                 * Encodes the specified EgoVehicle message, length delimited. Does not implicitly {@link metamoto.types.Scenario.EgoVehicle.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {metamoto.types.Scenario.IEgoVehicle} message EgoVehicle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EgoVehicle.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EgoVehicle message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.EgoVehicle} EgoVehicle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EgoVehicle.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.EgoVehicle();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            message.path.push($root.metamoto.types.Waypoint.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.driverModel = $root.metamoto.types.DriverModel.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.randomSpawnPoint = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EgoVehicle message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.EgoVehicle} EgoVehicle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EgoVehicle.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EgoVehicle message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EgoVehicle.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i) {
                            var error = $root.metamoto.types.Waypoint.verify(message.path[i]);
                            if (error)
                                return "path." + error;
                        }
                    }
                    if (message.driverModel != null && message.hasOwnProperty("driverModel")) {
                        var error = $root.metamoto.types.DriverModel.verify(message.driverModel);
                        if (error)
                            return "driverModel." + error;
                    }
                    if (message.randomSpawnPoint != null && message.hasOwnProperty("randomSpawnPoint"))
                        if (typeof message.randomSpawnPoint !== "boolean")
                            return "randomSpawnPoint: boolean expected";
                    return null;
                };

                /**
                 * Creates an EgoVehicle message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.EgoVehicle} EgoVehicle
                 */
                EgoVehicle.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.EgoVehicle)
                        return object;
                    var message = new $root.metamoto.types.Scenario.EgoVehicle();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".metamoto.types.Scenario.EgoVehicle.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i) {
                            if (typeof object.path[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.EgoVehicle.path: object expected");
                            message.path[i] = $root.metamoto.types.Waypoint.fromObject(object.path[i]);
                        }
                    }
                    if (object.driverModel != null) {
                        if (typeof object.driverModel !== "object")
                            throw TypeError(".metamoto.types.Scenario.EgoVehicle.driverModel: object expected");
                        message.driverModel = $root.metamoto.types.DriverModel.fromObject(object.driverModel);
                    }
                    if (object.randomSpawnPoint != null)
                        message.randomSpawnPoint = Boolean(object.randomSpawnPoint);
                    return message;
                };

                /**
                 * Creates a plain object from an EgoVehicle message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @static
                 * @param {metamoto.types.Scenario.EgoVehicle} message EgoVehicle
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EgoVehicle.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.driverModel = null;
                        object.randomSpawnPoint = false;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = $root.metamoto.types.Waypoint.toObject(message.path[j], options);
                    }
                    if (message.driverModel != null && message.hasOwnProperty("driverModel"))
                        object.driverModel = $root.metamoto.types.DriverModel.toObject(message.driverModel, options);
                    if (message.randomSpawnPoint != null && message.hasOwnProperty("randomSpawnPoint"))
                        object.randomSpawnPoint = message.randomSpawnPoint;
                    return object;
                };

                /**
                 * Converts this EgoVehicle to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.EgoVehicle
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EgoVehicle.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EgoVehicle;
            })();

            Scenario.Traffic = (function() {

                /**
                 * Properties of a Traffic.
                 * @memberof metamoto.types.Scenario
                 * @interface ITraffic
                 * @property {Array.<metamoto.types.IVector3>|null} [region] Traffic region
                 * @property {metamoto.types.Scenario.Traffic.IDistribution|null} [distribution] Traffic distribution
                 * @property {number|null} [numRandomVehicles] Traffic numRandomVehicles
                 * @property {number|null} [congestion] Traffic congestion
                 * @property {Array.<metamoto.types.ITrafficFlow>|null} [flows] Traffic flows
                 * @property {Array.<metamoto.types.ITrafficVehicle>|null} [vehicles] Traffic vehicles
                 * @property {metamoto.types.Scenario.Traffic.IDistribution|null} [parkedDistribution] Traffic parkedDistribution
                 * @property {number|null} [numRandomParkedVehicles] Traffic numRandomParkedVehicles
                 * @property {number|null} [parkingFullness] Traffic parkingFullness
                 * @property {Array.<metamoto.types.IParkedVehicle>|null} [parkedVehicles] Traffic parkedVehicles
                 */

                /**
                 * Constructs a new Traffic.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents a Traffic.
                 * @implements ITraffic
                 * @constructor
                 * @param {metamoto.types.Scenario.ITraffic=} [properties] Properties to set
                 */
                function Traffic(properties) {
                    this.region = [];
                    this.flows = [];
                    this.vehicles = [];
                    this.parkedVehicles = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Traffic region.
                 * @member {Array.<metamoto.types.IVector3>} region
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.region = $util.emptyArray;

                /**
                 * Traffic distribution.
                 * @member {metamoto.types.Scenario.Traffic.IDistribution|null|undefined} distribution
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.distribution = null;

                /**
                 * Traffic numRandomVehicles.
                 * @member {number} numRandomVehicles
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.numRandomVehicles = 0;

                /**
                 * Traffic congestion.
                 * @member {number} congestion
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.congestion = 0;

                /**
                 * Traffic flows.
                 * @member {Array.<metamoto.types.ITrafficFlow>} flows
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.flows = $util.emptyArray;

                /**
                 * Traffic vehicles.
                 * @member {Array.<metamoto.types.ITrafficVehicle>} vehicles
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.vehicles = $util.emptyArray;

                /**
                 * Traffic parkedDistribution.
                 * @member {metamoto.types.Scenario.Traffic.IDistribution|null|undefined} parkedDistribution
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.parkedDistribution = null;

                /**
                 * Traffic numRandomParkedVehicles.
                 * @member {number} numRandomParkedVehicles
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.numRandomParkedVehicles = 0;

                /**
                 * Traffic parkingFullness.
                 * @member {number} parkingFullness
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.parkingFullness = 0;

                /**
                 * Traffic parkedVehicles.
                 * @member {Array.<metamoto.types.IParkedVehicle>} parkedVehicles
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Traffic.prototype.parkedVehicles = $util.emptyArray;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Traffic randomOneof.
                 * @member {"numRandomVehicles"|"congestion"|undefined} randomOneof
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Object.defineProperty(Traffic.prototype, "randomOneof", {
                    get: $util.oneOfGetter($oneOfFields = ["numRandomVehicles", "congestion"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Traffic randomParkedOneof.
                 * @member {"numRandomParkedVehicles"|"parkingFullness"|undefined} randomParkedOneof
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 */
                Object.defineProperty(Traffic.prototype, "randomParkedOneof", {
                    get: $util.oneOfGetter($oneOfFields = ["numRandomParkedVehicles", "parkingFullness"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Traffic instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {metamoto.types.Scenario.ITraffic=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.Traffic} Traffic instance
                 */
                Traffic.create = function create(properties) {
                    return new Traffic(properties);
                };

                /**
                 * Encodes the specified Traffic message. Does not implicitly {@link metamoto.types.Scenario.Traffic.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {metamoto.types.Scenario.ITraffic} message Traffic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Traffic.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.region != null && message.region.length)
                        for (var i = 0; i < message.region.length; ++i)
                            $root.metamoto.types.Vector3.encode(message.region[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.distribution != null && message.hasOwnProperty("distribution"))
                        $root.metamoto.types.Scenario.Traffic.Distribution.encode(message.distribution, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.numRandomVehicles != null && message.hasOwnProperty("numRandomVehicles"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numRandomVehicles);
                    if (message.congestion != null && message.hasOwnProperty("congestion"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.congestion);
                    if (message.flows != null && message.flows.length)
                        for (var i = 0; i < message.flows.length; ++i)
                            $root.metamoto.types.TrafficFlow.encode(message.flows[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.vehicles != null && message.vehicles.length)
                        for (var i = 0; i < message.vehicles.length; ++i)
                            $root.metamoto.types.TrafficVehicle.encode(message.vehicles[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.parkedDistribution != null && message.hasOwnProperty("parkedDistribution"))
                        $root.metamoto.types.Scenario.Traffic.Distribution.encode(message.parkedDistribution, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.numRandomParkedVehicles != null && message.hasOwnProperty("numRandomParkedVehicles"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.numRandomParkedVehicles);
                    if (message.parkingFullness != null && message.hasOwnProperty("parkingFullness"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.parkingFullness);
                    if (message.parkedVehicles != null && message.parkedVehicles.length)
                        for (var i = 0; i < message.parkedVehicles.length; ++i)
                            $root.metamoto.types.ParkedVehicle.encode(message.parkedVehicles[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Traffic message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Traffic.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {metamoto.types.Scenario.ITraffic} message Traffic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Traffic.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Traffic message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.Traffic} Traffic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Traffic.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Traffic();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.region && message.region.length))
                                message.region = [];
                            message.region.push($root.metamoto.types.Vector3.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.distribution = $root.metamoto.types.Scenario.Traffic.Distribution.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.numRandomVehicles = reader.int32();
                            break;
                        case 4:
                            message.congestion = reader.float();
                            break;
                        case 5:
                            if (!(message.flows && message.flows.length))
                                message.flows = [];
                            message.flows.push($root.metamoto.types.TrafficFlow.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.vehicles && message.vehicles.length))
                                message.vehicles = [];
                            message.vehicles.push($root.metamoto.types.TrafficVehicle.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.parkedDistribution = $root.metamoto.types.Scenario.Traffic.Distribution.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.numRandomParkedVehicles = reader.int32();
                            break;
                        case 9:
                            message.parkingFullness = reader.float();
                            break;
                        case 10:
                            if (!(message.parkedVehicles && message.parkedVehicles.length))
                                message.parkedVehicles = [];
                            message.parkedVehicles.push($root.metamoto.types.ParkedVehicle.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Traffic message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.Traffic} Traffic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Traffic.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Traffic message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Traffic.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.region != null && message.hasOwnProperty("region")) {
                        if (!Array.isArray(message.region))
                            return "region: array expected";
                        for (var i = 0; i < message.region.length; ++i) {
                            var error = $root.metamoto.types.Vector3.verify(message.region[i]);
                            if (error)
                                return "region." + error;
                        }
                    }
                    if (message.distribution != null && message.hasOwnProperty("distribution")) {
                        var error = $root.metamoto.types.Scenario.Traffic.Distribution.verify(message.distribution);
                        if (error)
                            return "distribution." + error;
                    }
                    if (message.numRandomVehicles != null && message.hasOwnProperty("numRandomVehicles")) {
                        properties.randomOneof = 1;
                        if (!$util.isInteger(message.numRandomVehicles))
                            return "numRandomVehicles: integer expected";
                    }
                    if (message.congestion != null && message.hasOwnProperty("congestion")) {
                        if (properties.randomOneof === 1)
                            return "randomOneof: multiple values";
                        properties.randomOneof = 1;
                        if (typeof message.congestion !== "number")
                            return "congestion: number expected";
                    }
                    if (message.flows != null && message.hasOwnProperty("flows")) {
                        if (!Array.isArray(message.flows))
                            return "flows: array expected";
                        for (var i = 0; i < message.flows.length; ++i) {
                            var error = $root.metamoto.types.TrafficFlow.verify(message.flows[i]);
                            if (error)
                                return "flows." + error;
                        }
                    }
                    if (message.vehicles != null && message.hasOwnProperty("vehicles")) {
                        if (!Array.isArray(message.vehicles))
                            return "vehicles: array expected";
                        for (var i = 0; i < message.vehicles.length; ++i) {
                            var error = $root.metamoto.types.TrafficVehicle.verify(message.vehicles[i]);
                            if (error)
                                return "vehicles." + error;
                        }
                    }
                    if (message.parkedDistribution != null && message.hasOwnProperty("parkedDistribution")) {
                        var error = $root.metamoto.types.Scenario.Traffic.Distribution.verify(message.parkedDistribution);
                        if (error)
                            return "parkedDistribution." + error;
                    }
                    if (message.numRandomParkedVehicles != null && message.hasOwnProperty("numRandomParkedVehicles")) {
                        properties.randomParkedOneof = 1;
                        if (!$util.isInteger(message.numRandomParkedVehicles))
                            return "numRandomParkedVehicles: integer expected";
                    }
                    if (message.parkingFullness != null && message.hasOwnProperty("parkingFullness")) {
                        if (properties.randomParkedOneof === 1)
                            return "randomParkedOneof: multiple values";
                        properties.randomParkedOneof = 1;
                        if (typeof message.parkingFullness !== "number")
                            return "parkingFullness: number expected";
                    }
                    if (message.parkedVehicles != null && message.hasOwnProperty("parkedVehicles")) {
                        if (!Array.isArray(message.parkedVehicles))
                            return "parkedVehicles: array expected";
                        for (var i = 0; i < message.parkedVehicles.length; ++i) {
                            var error = $root.metamoto.types.ParkedVehicle.verify(message.parkedVehicles[i]);
                            if (error)
                                return "parkedVehicles." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Traffic message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.Traffic} Traffic
                 */
                Traffic.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.Traffic)
                        return object;
                    var message = new $root.metamoto.types.Scenario.Traffic();
                    if (object.region) {
                        if (!Array.isArray(object.region))
                            throw TypeError(".metamoto.types.Scenario.Traffic.region: array expected");
                        message.region = [];
                        for (var i = 0; i < object.region.length; ++i) {
                            if (typeof object.region[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.region: object expected");
                            message.region[i] = $root.metamoto.types.Vector3.fromObject(object.region[i]);
                        }
                    }
                    if (object.distribution != null) {
                        if (typeof object.distribution !== "object")
                            throw TypeError(".metamoto.types.Scenario.Traffic.distribution: object expected");
                        message.distribution = $root.metamoto.types.Scenario.Traffic.Distribution.fromObject(object.distribution);
                    }
                    if (object.numRandomVehicles != null)
                        message.numRandomVehicles = object.numRandomVehicles | 0;
                    if (object.congestion != null)
                        message.congestion = Number(object.congestion);
                    if (object.flows) {
                        if (!Array.isArray(object.flows))
                            throw TypeError(".metamoto.types.Scenario.Traffic.flows: array expected");
                        message.flows = [];
                        for (var i = 0; i < object.flows.length; ++i) {
                            if (typeof object.flows[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.flows: object expected");
                            message.flows[i] = $root.metamoto.types.TrafficFlow.fromObject(object.flows[i]);
                        }
                    }
                    if (object.vehicles) {
                        if (!Array.isArray(object.vehicles))
                            throw TypeError(".metamoto.types.Scenario.Traffic.vehicles: array expected");
                        message.vehicles = [];
                        for (var i = 0; i < object.vehicles.length; ++i) {
                            if (typeof object.vehicles[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.vehicles: object expected");
                            message.vehicles[i] = $root.metamoto.types.TrafficVehicle.fromObject(object.vehicles[i]);
                        }
                    }
                    if (object.parkedDistribution != null) {
                        if (typeof object.parkedDistribution !== "object")
                            throw TypeError(".metamoto.types.Scenario.Traffic.parkedDistribution: object expected");
                        message.parkedDistribution = $root.metamoto.types.Scenario.Traffic.Distribution.fromObject(object.parkedDistribution);
                    }
                    if (object.numRandomParkedVehicles != null)
                        message.numRandomParkedVehicles = object.numRandomParkedVehicles | 0;
                    if (object.parkingFullness != null)
                        message.parkingFullness = Number(object.parkingFullness);
                    if (object.parkedVehicles) {
                        if (!Array.isArray(object.parkedVehicles))
                            throw TypeError(".metamoto.types.Scenario.Traffic.parkedVehicles: array expected");
                        message.parkedVehicles = [];
                        for (var i = 0; i < object.parkedVehicles.length; ++i) {
                            if (typeof object.parkedVehicles[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.parkedVehicles: object expected");
                            message.parkedVehicles[i] = $root.metamoto.types.ParkedVehicle.fromObject(object.parkedVehicles[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Traffic message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.Traffic
                 * @static
                 * @param {metamoto.types.Scenario.Traffic} message Traffic
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Traffic.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.region = [];
                        object.flows = [];
                        object.vehicles = [];
                        object.parkedVehicles = [];
                    }
                    if (options.defaults) {
                        object.distribution = null;
                        object.parkedDistribution = null;
                    }
                    if (message.region && message.region.length) {
                        object.region = [];
                        for (var j = 0; j < message.region.length; ++j)
                            object.region[j] = $root.metamoto.types.Vector3.toObject(message.region[j], options);
                    }
                    if (message.distribution != null && message.hasOwnProperty("distribution"))
                        object.distribution = $root.metamoto.types.Scenario.Traffic.Distribution.toObject(message.distribution, options);
                    if (message.numRandomVehicles != null && message.hasOwnProperty("numRandomVehicles")) {
                        object.numRandomVehicles = message.numRandomVehicles;
                        if (options.oneofs)
                            object.randomOneof = "numRandomVehicles";
                    }
                    if (message.congestion != null && message.hasOwnProperty("congestion")) {
                        object.congestion = options.json && !isFinite(message.congestion) ? String(message.congestion) : message.congestion;
                        if (options.oneofs)
                            object.randomOneof = "congestion";
                    }
                    if (message.flows && message.flows.length) {
                        object.flows = [];
                        for (var j = 0; j < message.flows.length; ++j)
                            object.flows[j] = $root.metamoto.types.TrafficFlow.toObject(message.flows[j], options);
                    }
                    if (message.vehicles && message.vehicles.length) {
                        object.vehicles = [];
                        for (var j = 0; j < message.vehicles.length; ++j)
                            object.vehicles[j] = $root.metamoto.types.TrafficVehicle.toObject(message.vehicles[j], options);
                    }
                    if (message.parkedDistribution != null && message.hasOwnProperty("parkedDistribution"))
                        object.parkedDistribution = $root.metamoto.types.Scenario.Traffic.Distribution.toObject(message.parkedDistribution, options);
                    if (message.numRandomParkedVehicles != null && message.hasOwnProperty("numRandomParkedVehicles")) {
                        object.numRandomParkedVehicles = message.numRandomParkedVehicles;
                        if (options.oneofs)
                            object.randomParkedOneof = "numRandomParkedVehicles";
                    }
                    if (message.parkingFullness != null && message.hasOwnProperty("parkingFullness")) {
                        object.parkingFullness = options.json && !isFinite(message.parkingFullness) ? String(message.parkingFullness) : message.parkingFullness;
                        if (options.oneofs)
                            object.randomParkedOneof = "parkingFullness";
                    }
                    if (message.parkedVehicles && message.parkedVehicles.length) {
                        object.parkedVehicles = [];
                        for (var j = 0; j < message.parkedVehicles.length; ++j)
                            object.parkedVehicles[j] = $root.metamoto.types.ParkedVehicle.toObject(message.parkedVehicles[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Traffic to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.Traffic
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Traffic.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Traffic.Distribution = (function() {

                    /**
                     * Properties of a Distribution.
                     * @memberof metamoto.types.Scenario.Traffic
                     * @interface IDistribution
                     * @property {Object.<string,number>|null} [modelWeights] Distribution modelWeights
                     * @property {Object.<string,number>|null} [typeWeights] Distribution typeWeights
                     * @property {Object.<string,number>|null} [paintWeights] Distribution paintWeights
                     */

                    /**
                     * Constructs a new Distribution.
                     * @memberof metamoto.types.Scenario.Traffic
                     * @classdesc Represents a Distribution.
                     * @implements IDistribution
                     * @constructor
                     * @param {metamoto.types.Scenario.Traffic.IDistribution=} [properties] Properties to set
                     */
                    function Distribution(properties) {
                        this.modelWeights = {};
                        this.typeWeights = {};
                        this.paintWeights = {};
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Distribution modelWeights.
                     * @member {Object.<string,number>} modelWeights
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @instance
                     */
                    Distribution.prototype.modelWeights = $util.emptyObject;

                    /**
                     * Distribution typeWeights.
                     * @member {Object.<string,number>} typeWeights
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @instance
                     */
                    Distribution.prototype.typeWeights = $util.emptyObject;

                    /**
                     * Distribution paintWeights.
                     * @member {Object.<string,number>} paintWeights
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @instance
                     */
                    Distribution.prototype.paintWeights = $util.emptyObject;

                    /**
                     * Creates a new Distribution instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Traffic.IDistribution=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.Traffic.Distribution} Distribution instance
                     */
                    Distribution.create = function create(properties) {
                        return new Distribution(properties);
                    };

                    /**
                     * Encodes the specified Distribution message. Does not implicitly {@link metamoto.types.Scenario.Traffic.Distribution.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Traffic.IDistribution} message Distribution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Distribution.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.modelWeights != null && message.hasOwnProperty("modelWeights"))
                            for (var keys = Object.keys(message.modelWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.modelWeights[keys[i]]).ldelim();
                        if (message.typeWeights != null && message.hasOwnProperty("typeWeights"))
                            for (var keys = Object.keys(message.typeWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.typeWeights[keys[i]]).ldelim();
                        if (message.paintWeights != null && message.hasOwnProperty("paintWeights"))
                            for (var keys = Object.keys(message.paintWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.paintWeights[keys[i]]).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Distribution message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Traffic.Distribution.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Traffic.IDistribution} message Distribution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Distribution.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Distribution message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.Traffic.Distribution} Distribution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Distribution.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Traffic.Distribution(), key;
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                reader.skip().pos++;
                                if (message.modelWeights === $util.emptyObject)
                                    message.modelWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.modelWeights[key] = reader.float();
                                break;
                            case 2:
                                reader.skip().pos++;
                                if (message.typeWeights === $util.emptyObject)
                                    message.typeWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.typeWeights[key] = reader.float();
                                break;
                            case 3:
                                reader.skip().pos++;
                                if (message.paintWeights === $util.emptyObject)
                                    message.paintWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.paintWeights[key] = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Distribution message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.Traffic.Distribution} Distribution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Distribution.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Distribution message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Distribution.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.modelWeights != null && message.hasOwnProperty("modelWeights")) {
                            if (!$util.isObject(message.modelWeights))
                                return "modelWeights: object expected";
                            var key = Object.keys(message.modelWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.modelWeights[key[i]] !== "number")
                                    return "modelWeights: number{k:string} expected";
                        }
                        if (message.typeWeights != null && message.hasOwnProperty("typeWeights")) {
                            if (!$util.isObject(message.typeWeights))
                                return "typeWeights: object expected";
                            var key = Object.keys(message.typeWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.typeWeights[key[i]] !== "number")
                                    return "typeWeights: number{k:string} expected";
                        }
                        if (message.paintWeights != null && message.hasOwnProperty("paintWeights")) {
                            if (!$util.isObject(message.paintWeights))
                                return "paintWeights: object expected";
                            var key = Object.keys(message.paintWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.paintWeights[key[i]] !== "number")
                                    return "paintWeights: number{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Distribution message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.Traffic.Distribution} Distribution
                     */
                    Distribution.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.Traffic.Distribution)
                            return object;
                        var message = new $root.metamoto.types.Scenario.Traffic.Distribution();
                        if (object.modelWeights) {
                            if (typeof object.modelWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.Distribution.modelWeights: object expected");
                            message.modelWeights = {};
                            for (var keys = Object.keys(object.modelWeights), i = 0; i < keys.length; ++i)
                                message.modelWeights[keys[i]] = Number(object.modelWeights[keys[i]]);
                        }
                        if (object.typeWeights) {
                            if (typeof object.typeWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.Distribution.typeWeights: object expected");
                            message.typeWeights = {};
                            for (var keys = Object.keys(object.typeWeights), i = 0; i < keys.length; ++i)
                                message.typeWeights[keys[i]] = Number(object.typeWeights[keys[i]]);
                        }
                        if (object.paintWeights) {
                            if (typeof object.paintWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Traffic.Distribution.paintWeights: object expected");
                            message.paintWeights = {};
                            for (var keys = Object.keys(object.paintWeights), i = 0; i < keys.length; ++i)
                                message.paintWeights[keys[i]] = Number(object.paintWeights[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Distribution message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Traffic.Distribution} message Distribution
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Distribution.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.objects || options.defaults) {
                            object.modelWeights = {};
                            object.typeWeights = {};
                            object.paintWeights = {};
                        }
                        var keys2;
                        if (message.modelWeights && (keys2 = Object.keys(message.modelWeights)).length) {
                            object.modelWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.modelWeights[keys2[j]] = options.json && !isFinite(message.modelWeights[keys2[j]]) ? String(message.modelWeights[keys2[j]]) : message.modelWeights[keys2[j]];
                        }
                        if (message.typeWeights && (keys2 = Object.keys(message.typeWeights)).length) {
                            object.typeWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.typeWeights[keys2[j]] = options.json && !isFinite(message.typeWeights[keys2[j]]) ? String(message.typeWeights[keys2[j]]) : message.typeWeights[keys2[j]];
                        }
                        if (message.paintWeights && (keys2 = Object.keys(message.paintWeights)).length) {
                            object.paintWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.paintWeights[keys2[j]] = options.json && !isFinite(message.paintWeights[keys2[j]]) ? String(message.paintWeights[keys2[j]]) : message.paintWeights[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Distribution to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.Traffic.Distribution
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Distribution.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Distribution;
                })();

                return Traffic;
            })();

            Scenario.Pedestrians = (function() {

                /**
                 * Properties of a Pedestrians.
                 * @memberof metamoto.types.Scenario
                 * @interface IPedestrians
                 * @property {Array.<metamoto.types.IVector3>|null} [region] Pedestrians region
                 * @property {metamoto.types.Scenario.Pedestrians.IDistribution|null} [distribution] Pedestrians distribution
                 * @property {Array.<metamoto.types.IPedestrianConfiguration>|null} [pedestrians] Pedestrians pedestrians
                 * @property {number|null} [numRandomPedestrians] Pedestrians numRandomPedestrians
                 * @property {number|null} [pedestrianTraffic] Pedestrians pedestrianTraffic
                 */

                /**
                 * Constructs a new Pedestrians.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents a Pedestrians.
                 * @implements IPedestrians
                 * @constructor
                 * @param {metamoto.types.Scenario.IPedestrians=} [properties] Properties to set
                 */
                function Pedestrians(properties) {
                    this.region = [];
                    this.pedestrians = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pedestrians region.
                 * @member {Array.<metamoto.types.IVector3>} region
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Pedestrians.prototype.region = $util.emptyArray;

                /**
                 * Pedestrians distribution.
                 * @member {metamoto.types.Scenario.Pedestrians.IDistribution|null|undefined} distribution
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Pedestrians.prototype.distribution = null;

                /**
                 * Pedestrians pedestrians.
                 * @member {Array.<metamoto.types.IPedestrianConfiguration>} pedestrians
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Pedestrians.prototype.pedestrians = $util.emptyArray;

                /**
                 * Pedestrians numRandomPedestrians.
                 * @member {number} numRandomPedestrians
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Pedestrians.prototype.numRandomPedestrians = 0;

                /**
                 * Pedestrians pedestrianTraffic.
                 * @member {number} pedestrianTraffic
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Pedestrians.prototype.pedestrianTraffic = 0;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Pedestrians randomOneof.
                 * @member {"numRandomPedestrians"|"pedestrianTraffic"|undefined} randomOneof
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 */
                Object.defineProperty(Pedestrians.prototype, "randomOneof", {
                    get: $util.oneOfGetter($oneOfFields = ["numRandomPedestrians", "pedestrianTraffic"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Pedestrians instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {metamoto.types.Scenario.IPedestrians=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.Pedestrians} Pedestrians instance
                 */
                Pedestrians.create = function create(properties) {
                    return new Pedestrians(properties);
                };

                /**
                 * Encodes the specified Pedestrians message. Does not implicitly {@link metamoto.types.Scenario.Pedestrians.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {metamoto.types.Scenario.IPedestrians} message Pedestrians message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pedestrians.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.region != null && message.region.length)
                        for (var i = 0; i < message.region.length; ++i)
                            $root.metamoto.types.Vector3.encode(message.region[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.distribution != null && message.hasOwnProperty("distribution"))
                        $root.metamoto.types.Scenario.Pedestrians.Distribution.encode(message.distribution, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pedestrians != null && message.pedestrians.length)
                        for (var i = 0; i < message.pedestrians.length; ++i)
                            $root.metamoto.types.PedestrianConfiguration.encode(message.pedestrians[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.numRandomPedestrians != null && message.hasOwnProperty("numRandomPedestrians"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.numRandomPedestrians);
                    if (message.pedestrianTraffic != null && message.hasOwnProperty("pedestrianTraffic"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.pedestrianTraffic);
                    return writer;
                };

                /**
                 * Encodes the specified Pedestrians message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Pedestrians.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {metamoto.types.Scenario.IPedestrians} message Pedestrians message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pedestrians.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pedestrians message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.Pedestrians} Pedestrians
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pedestrians.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Pedestrians();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.region && message.region.length))
                                message.region = [];
                            message.region.push($root.metamoto.types.Vector3.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.distribution = $root.metamoto.types.Scenario.Pedestrians.Distribution.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.pedestrians && message.pedestrians.length))
                                message.pedestrians = [];
                            message.pedestrians.push($root.metamoto.types.PedestrianConfiguration.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.numRandomPedestrians = reader.int32();
                            break;
                        case 5:
                            message.pedestrianTraffic = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Pedestrians message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.Pedestrians} Pedestrians
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pedestrians.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pedestrians message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pedestrians.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.region != null && message.hasOwnProperty("region")) {
                        if (!Array.isArray(message.region))
                            return "region: array expected";
                        for (var i = 0; i < message.region.length; ++i) {
                            var error = $root.metamoto.types.Vector3.verify(message.region[i]);
                            if (error)
                                return "region." + error;
                        }
                    }
                    if (message.distribution != null && message.hasOwnProperty("distribution")) {
                        var error = $root.metamoto.types.Scenario.Pedestrians.Distribution.verify(message.distribution);
                        if (error)
                            return "distribution." + error;
                    }
                    if (message.pedestrians != null && message.hasOwnProperty("pedestrians")) {
                        if (!Array.isArray(message.pedestrians))
                            return "pedestrians: array expected";
                        for (var i = 0; i < message.pedestrians.length; ++i) {
                            var error = $root.metamoto.types.PedestrianConfiguration.verify(message.pedestrians[i]);
                            if (error)
                                return "pedestrians." + error;
                        }
                    }
                    if (message.numRandomPedestrians != null && message.hasOwnProperty("numRandomPedestrians")) {
                        properties.randomOneof = 1;
                        if (!$util.isInteger(message.numRandomPedestrians))
                            return "numRandomPedestrians: integer expected";
                    }
                    if (message.pedestrianTraffic != null && message.hasOwnProperty("pedestrianTraffic")) {
                        if (properties.randomOneof === 1)
                            return "randomOneof: multiple values";
                        properties.randomOneof = 1;
                        if (typeof message.pedestrianTraffic !== "number")
                            return "pedestrianTraffic: number expected";
                    }
                    return null;
                };

                /**
                 * Creates a Pedestrians message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.Pedestrians} Pedestrians
                 */
                Pedestrians.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.Pedestrians)
                        return object;
                    var message = new $root.metamoto.types.Scenario.Pedestrians();
                    if (object.region) {
                        if (!Array.isArray(object.region))
                            throw TypeError(".metamoto.types.Scenario.Pedestrians.region: array expected");
                        message.region = [];
                        for (var i = 0; i < object.region.length; ++i) {
                            if (typeof object.region[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Pedestrians.region: object expected");
                            message.region[i] = $root.metamoto.types.Vector3.fromObject(object.region[i]);
                        }
                    }
                    if (object.distribution != null) {
                        if (typeof object.distribution !== "object")
                            throw TypeError(".metamoto.types.Scenario.Pedestrians.distribution: object expected");
                        message.distribution = $root.metamoto.types.Scenario.Pedestrians.Distribution.fromObject(object.distribution);
                    }
                    if (object.pedestrians) {
                        if (!Array.isArray(object.pedestrians))
                            throw TypeError(".metamoto.types.Scenario.Pedestrians.pedestrians: array expected");
                        message.pedestrians = [];
                        for (var i = 0; i < object.pedestrians.length; ++i) {
                            if (typeof object.pedestrians[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Pedestrians.pedestrians: object expected");
                            message.pedestrians[i] = $root.metamoto.types.PedestrianConfiguration.fromObject(object.pedestrians[i]);
                        }
                    }
                    if (object.numRandomPedestrians != null)
                        message.numRandomPedestrians = object.numRandomPedestrians | 0;
                    if (object.pedestrianTraffic != null)
                        message.pedestrianTraffic = Number(object.pedestrianTraffic);
                    return message;
                };

                /**
                 * Creates a plain object from a Pedestrians message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @static
                 * @param {metamoto.types.Scenario.Pedestrians} message Pedestrians
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pedestrians.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.region = [];
                        object.pedestrians = [];
                    }
                    if (options.defaults)
                        object.distribution = null;
                    if (message.region && message.region.length) {
                        object.region = [];
                        for (var j = 0; j < message.region.length; ++j)
                            object.region[j] = $root.metamoto.types.Vector3.toObject(message.region[j], options);
                    }
                    if (message.distribution != null && message.hasOwnProperty("distribution"))
                        object.distribution = $root.metamoto.types.Scenario.Pedestrians.Distribution.toObject(message.distribution, options);
                    if (message.pedestrians && message.pedestrians.length) {
                        object.pedestrians = [];
                        for (var j = 0; j < message.pedestrians.length; ++j)
                            object.pedestrians[j] = $root.metamoto.types.PedestrianConfiguration.toObject(message.pedestrians[j], options);
                    }
                    if (message.numRandomPedestrians != null && message.hasOwnProperty("numRandomPedestrians")) {
                        object.numRandomPedestrians = message.numRandomPedestrians;
                        if (options.oneofs)
                            object.randomOneof = "numRandomPedestrians";
                    }
                    if (message.pedestrianTraffic != null && message.hasOwnProperty("pedestrianTraffic")) {
                        object.pedestrianTraffic = options.json && !isFinite(message.pedestrianTraffic) ? String(message.pedestrianTraffic) : message.pedestrianTraffic;
                        if (options.oneofs)
                            object.randomOneof = "pedestrianTraffic";
                    }
                    return object;
                };

                /**
                 * Converts this Pedestrians to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.Pedestrians
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pedestrians.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Pedestrians.Distribution = (function() {

                    /**
                     * Properties of a Distribution.
                     * @memberof metamoto.types.Scenario.Pedestrians
                     * @interface IDistribution
                     * @property {Object.<string,number>|null} [nameWeights] Distribution nameWeights
                     * @property {Object.<string,number>|null} [typeWeights] Distribution typeWeights
                     * @property {Object.<string,number>|null} [stateWeights] Distribution stateWeights
                     */

                    /**
                     * Constructs a new Distribution.
                     * @memberof metamoto.types.Scenario.Pedestrians
                     * @classdesc Represents a Distribution.
                     * @implements IDistribution
                     * @constructor
                     * @param {metamoto.types.Scenario.Pedestrians.IDistribution=} [properties] Properties to set
                     */
                    function Distribution(properties) {
                        this.nameWeights = {};
                        this.typeWeights = {};
                        this.stateWeights = {};
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Distribution nameWeights.
                     * @member {Object.<string,number>} nameWeights
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @instance
                     */
                    Distribution.prototype.nameWeights = $util.emptyObject;

                    /**
                     * Distribution typeWeights.
                     * @member {Object.<string,number>} typeWeights
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @instance
                     */
                    Distribution.prototype.typeWeights = $util.emptyObject;

                    /**
                     * Distribution stateWeights.
                     * @member {Object.<string,number>} stateWeights
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @instance
                     */
                    Distribution.prototype.stateWeights = $util.emptyObject;

                    /**
                     * Creates a new Distribution instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Pedestrians.IDistribution=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.Pedestrians.Distribution} Distribution instance
                     */
                    Distribution.create = function create(properties) {
                        return new Distribution(properties);
                    };

                    /**
                     * Encodes the specified Distribution message. Does not implicitly {@link metamoto.types.Scenario.Pedestrians.Distribution.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Pedestrians.IDistribution} message Distribution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Distribution.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nameWeights != null && message.hasOwnProperty("nameWeights"))
                            for (var keys = Object.keys(message.nameWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.nameWeights[keys[i]]).ldelim();
                        if (message.typeWeights != null && message.hasOwnProperty("typeWeights"))
                            for (var keys = Object.keys(message.typeWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.typeWeights[keys[i]]).ldelim();
                        if (message.stateWeights != null && message.hasOwnProperty("stateWeights"))
                            for (var keys = Object.keys(message.stateWeights), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.stateWeights[keys[i]]).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Distribution message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Pedestrians.Distribution.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Pedestrians.IDistribution} message Distribution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Distribution.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Distribution message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.Pedestrians.Distribution} Distribution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Distribution.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Pedestrians.Distribution(), key;
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                reader.skip().pos++;
                                if (message.nameWeights === $util.emptyObject)
                                    message.nameWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.nameWeights[key] = reader.float();
                                break;
                            case 2:
                                reader.skip().pos++;
                                if (message.typeWeights === $util.emptyObject)
                                    message.typeWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.typeWeights[key] = reader.float();
                                break;
                            case 3:
                                reader.skip().pos++;
                                if (message.stateWeights === $util.emptyObject)
                                    message.stateWeights = {};
                                key = reader.string();
                                reader.pos++;
                                message.stateWeights[key] = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Distribution message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.Pedestrians.Distribution} Distribution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Distribution.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Distribution message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Distribution.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nameWeights != null && message.hasOwnProperty("nameWeights")) {
                            if (!$util.isObject(message.nameWeights))
                                return "nameWeights: object expected";
                            var key = Object.keys(message.nameWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.nameWeights[key[i]] !== "number")
                                    return "nameWeights: number{k:string} expected";
                        }
                        if (message.typeWeights != null && message.hasOwnProperty("typeWeights")) {
                            if (!$util.isObject(message.typeWeights))
                                return "typeWeights: object expected";
                            var key = Object.keys(message.typeWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.typeWeights[key[i]] !== "number")
                                    return "typeWeights: number{k:string} expected";
                        }
                        if (message.stateWeights != null && message.hasOwnProperty("stateWeights")) {
                            if (!$util.isObject(message.stateWeights))
                                return "stateWeights: object expected";
                            var key = Object.keys(message.stateWeights);
                            for (var i = 0; i < key.length; ++i)
                                if (typeof message.stateWeights[key[i]] !== "number")
                                    return "stateWeights: number{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Distribution message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.Pedestrians.Distribution} Distribution
                     */
                    Distribution.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.Pedestrians.Distribution)
                            return object;
                        var message = new $root.metamoto.types.Scenario.Pedestrians.Distribution();
                        if (object.nameWeights) {
                            if (typeof object.nameWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Pedestrians.Distribution.nameWeights: object expected");
                            message.nameWeights = {};
                            for (var keys = Object.keys(object.nameWeights), i = 0; i < keys.length; ++i)
                                message.nameWeights[keys[i]] = Number(object.nameWeights[keys[i]]);
                        }
                        if (object.typeWeights) {
                            if (typeof object.typeWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Pedestrians.Distribution.typeWeights: object expected");
                            message.typeWeights = {};
                            for (var keys = Object.keys(object.typeWeights), i = 0; i < keys.length; ++i)
                                message.typeWeights[keys[i]] = Number(object.typeWeights[keys[i]]);
                        }
                        if (object.stateWeights) {
                            if (typeof object.stateWeights !== "object")
                                throw TypeError(".metamoto.types.Scenario.Pedestrians.Distribution.stateWeights: object expected");
                            message.stateWeights = {};
                            for (var keys = Object.keys(object.stateWeights), i = 0; i < keys.length; ++i)
                                message.stateWeights[keys[i]] = Number(object.stateWeights[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Distribution message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @static
                     * @param {metamoto.types.Scenario.Pedestrians.Distribution} message Distribution
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Distribution.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.objects || options.defaults) {
                            object.nameWeights = {};
                            object.typeWeights = {};
                            object.stateWeights = {};
                        }
                        var keys2;
                        if (message.nameWeights && (keys2 = Object.keys(message.nameWeights)).length) {
                            object.nameWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.nameWeights[keys2[j]] = options.json && !isFinite(message.nameWeights[keys2[j]]) ? String(message.nameWeights[keys2[j]]) : message.nameWeights[keys2[j]];
                        }
                        if (message.typeWeights && (keys2 = Object.keys(message.typeWeights)).length) {
                            object.typeWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.typeWeights[keys2[j]] = options.json && !isFinite(message.typeWeights[keys2[j]]) ? String(message.typeWeights[keys2[j]]) : message.typeWeights[keys2[j]];
                        }
                        if (message.stateWeights && (keys2 = Object.keys(message.stateWeights)).length) {
                            object.stateWeights = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.stateWeights[keys2[j]] = options.json && !isFinite(message.stateWeights[keys2[j]]) ? String(message.stateWeights[keys2[j]]) : message.stateWeights[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Distribution to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.Pedestrians.Distribution
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Distribution.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Distribution;
                })();

                return Pedestrians;
            })();

            Scenario.TrafficLight = (function() {

                /**
                 * Properties of a TrafficLight.
                 * @memberof metamoto.types.Scenario
                 * @interface ITrafficLight
                 * @property {Array.<metamoto.types.Scenario.TrafficLight.IDirection>|null} [directions] TrafficLight directions
                 * @property {number|null} [allRedTime] TrafficLight allRedTime
                 * @property {string|null} [startGreenDirection] TrafficLight startGreenDirection
                 * @property {number|null} [startCycleOffset] TrafficLight startCycleOffset
                 */

                /**
                 * Constructs a new TrafficLight.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents a TrafficLight.
                 * @implements ITrafficLight
                 * @constructor
                 * @param {metamoto.types.Scenario.ITrafficLight=} [properties] Properties to set
                 */
                function TrafficLight(properties) {
                    this.directions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrafficLight directions.
                 * @member {Array.<metamoto.types.Scenario.TrafficLight.IDirection>} directions
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @instance
                 */
                TrafficLight.prototype.directions = $util.emptyArray;

                /**
                 * TrafficLight allRedTime.
                 * @member {number} allRedTime
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @instance
                 */
                TrafficLight.prototype.allRedTime = 0;

                /**
                 * TrafficLight startGreenDirection.
                 * @member {string} startGreenDirection
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @instance
                 */
                TrafficLight.prototype.startGreenDirection = "";

                /**
                 * TrafficLight startCycleOffset.
                 * @member {number} startCycleOffset
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @instance
                 */
                TrafficLight.prototype.startCycleOffset = 0;

                /**
                 * Creates a new TrafficLight instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {metamoto.types.Scenario.ITrafficLight=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.TrafficLight} TrafficLight instance
                 */
                TrafficLight.create = function create(properties) {
                    return new TrafficLight(properties);
                };

                /**
                 * Encodes the specified TrafficLight message. Does not implicitly {@link metamoto.types.Scenario.TrafficLight.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {metamoto.types.Scenario.ITrafficLight} message TrafficLight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficLight.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.directions != null && message.directions.length)
                        for (var i = 0; i < message.directions.length; ++i)
                            $root.metamoto.types.Scenario.TrafficLight.Direction.encode(message.directions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.allRedTime != null && message.hasOwnProperty("allRedTime"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.allRedTime);
                    if (message.startGreenDirection != null && message.hasOwnProperty("startGreenDirection"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.startGreenDirection);
                    if (message.startCycleOffset != null && message.hasOwnProperty("startCycleOffset"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.startCycleOffset);
                    return writer;
                };

                /**
                 * Encodes the specified TrafficLight message, length delimited. Does not implicitly {@link metamoto.types.Scenario.TrafficLight.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {metamoto.types.Scenario.ITrafficLight} message TrafficLight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficLight.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrafficLight message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.TrafficLight} TrafficLight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficLight.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.TrafficLight();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.directions && message.directions.length))
                                message.directions = [];
                            message.directions.push($root.metamoto.types.Scenario.TrafficLight.Direction.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.allRedTime = reader.float();
                            break;
                        case 3:
                            message.startGreenDirection = reader.string();
                            break;
                        case 4:
                            message.startCycleOffset = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrafficLight message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.TrafficLight} TrafficLight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficLight.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrafficLight message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrafficLight.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.directions != null && message.hasOwnProperty("directions")) {
                        if (!Array.isArray(message.directions))
                            return "directions: array expected";
                        for (var i = 0; i < message.directions.length; ++i) {
                            var error = $root.metamoto.types.Scenario.TrafficLight.Direction.verify(message.directions[i]);
                            if (error)
                                return "directions." + error;
                        }
                    }
                    if (message.allRedTime != null && message.hasOwnProperty("allRedTime"))
                        if (typeof message.allRedTime !== "number")
                            return "allRedTime: number expected";
                    if (message.startGreenDirection != null && message.hasOwnProperty("startGreenDirection"))
                        if (!$util.isString(message.startGreenDirection))
                            return "startGreenDirection: string expected";
                    if (message.startCycleOffset != null && message.hasOwnProperty("startCycleOffset"))
                        if (typeof message.startCycleOffset !== "number")
                            return "startCycleOffset: number expected";
                    return null;
                };

                /**
                 * Creates a TrafficLight message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.TrafficLight} TrafficLight
                 */
                TrafficLight.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.TrafficLight)
                        return object;
                    var message = new $root.metamoto.types.Scenario.TrafficLight();
                    if (object.directions) {
                        if (!Array.isArray(object.directions))
                            throw TypeError(".metamoto.types.Scenario.TrafficLight.directions: array expected");
                        message.directions = [];
                        for (var i = 0; i < object.directions.length; ++i) {
                            if (typeof object.directions[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.TrafficLight.directions: object expected");
                            message.directions[i] = $root.metamoto.types.Scenario.TrafficLight.Direction.fromObject(object.directions[i]);
                        }
                    }
                    if (object.allRedTime != null)
                        message.allRedTime = Number(object.allRedTime);
                    if (object.startGreenDirection != null)
                        message.startGreenDirection = String(object.startGreenDirection);
                    if (object.startCycleOffset != null)
                        message.startCycleOffset = Number(object.startCycleOffset);
                    return message;
                };

                /**
                 * Creates a plain object from a TrafficLight message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @static
                 * @param {metamoto.types.Scenario.TrafficLight} message TrafficLight
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrafficLight.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.directions = [];
                    if (options.defaults) {
                        object.allRedTime = 0;
                        object.startGreenDirection = "";
                        object.startCycleOffset = 0;
                    }
                    if (message.directions && message.directions.length) {
                        object.directions = [];
                        for (var j = 0; j < message.directions.length; ++j)
                            object.directions[j] = $root.metamoto.types.Scenario.TrafficLight.Direction.toObject(message.directions[j], options);
                    }
                    if (message.allRedTime != null && message.hasOwnProperty("allRedTime"))
                        object.allRedTime = options.json && !isFinite(message.allRedTime) ? String(message.allRedTime) : message.allRedTime;
                    if (message.startGreenDirection != null && message.hasOwnProperty("startGreenDirection"))
                        object.startGreenDirection = message.startGreenDirection;
                    if (message.startCycleOffset != null && message.hasOwnProperty("startCycleOffset"))
                        object.startCycleOffset = options.json && !isFinite(message.startCycleOffset) ? String(message.startCycleOffset) : message.startCycleOffset;
                    return object;
                };

                /**
                 * Converts this TrafficLight to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.TrafficLight
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrafficLight.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TrafficLight.Direction = (function() {

                    /**
                     * Properties of a Direction.
                     * @memberof metamoto.types.Scenario.TrafficLight
                     * @interface IDirection
                     * @property {string|null} [id] Direction id
                     * @property {google.protobuf.IFloatValue|null} [greenTime] Direction greenTime
                     * @property {google.protobuf.IFloatValue|null} [yellowTime] Direction yellowTime
                     * @property {google.protobuf.IFloatValue|null} [crosswalkWalkTime] Direction crosswalkWalkTime
                     * @property {string|null} [synchronizeWithDirectionId] Direction synchronizeWithDirectionId
                     */

                    /**
                     * Constructs a new Direction.
                     * @memberof metamoto.types.Scenario.TrafficLight
                     * @classdesc Represents a Direction.
                     * @implements IDirection
                     * @constructor
                     * @param {metamoto.types.Scenario.TrafficLight.IDirection=} [properties] Properties to set
                     */
                    function Direction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Direction id.
                     * @member {string} id
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     */
                    Direction.prototype.id = "";

                    /**
                     * Direction greenTime.
                     * @member {google.protobuf.IFloatValue|null|undefined} greenTime
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     */
                    Direction.prototype.greenTime = null;

                    /**
                     * Direction yellowTime.
                     * @member {google.protobuf.IFloatValue|null|undefined} yellowTime
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     */
                    Direction.prototype.yellowTime = null;

                    /**
                     * Direction crosswalkWalkTime.
                     * @member {google.protobuf.IFloatValue|null|undefined} crosswalkWalkTime
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     */
                    Direction.prototype.crosswalkWalkTime = null;

                    /**
                     * Direction synchronizeWithDirectionId.
                     * @member {string} synchronizeWithDirectionId
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     */
                    Direction.prototype.synchronizeWithDirectionId = "";

                    /**
                     * Creates a new Direction instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {metamoto.types.Scenario.TrafficLight.IDirection=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.TrafficLight.Direction} Direction instance
                     */
                    Direction.create = function create(properties) {
                        return new Direction(properties);
                    };

                    /**
                     * Encodes the specified Direction message. Does not implicitly {@link metamoto.types.Scenario.TrafficLight.Direction.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {metamoto.types.Scenario.TrafficLight.IDirection} message Direction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Direction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.greenTime != null && message.hasOwnProperty("greenTime"))
                            $root.google.protobuf.FloatValue.encode(message.greenTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.yellowTime != null && message.hasOwnProperty("yellowTime"))
                            $root.google.protobuf.FloatValue.encode(message.yellowTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.crosswalkWalkTime != null && message.hasOwnProperty("crosswalkWalkTime"))
                            $root.google.protobuf.FloatValue.encode(message.crosswalkWalkTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.synchronizeWithDirectionId != null && message.hasOwnProperty("synchronizeWithDirectionId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.synchronizeWithDirectionId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Direction message, length delimited. Does not implicitly {@link metamoto.types.Scenario.TrafficLight.Direction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {metamoto.types.Scenario.TrafficLight.IDirection} message Direction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Direction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Direction message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.TrafficLight.Direction} Direction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Direction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.TrafficLight.Direction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.greenTime = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.yellowTime = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.crosswalkWalkTime = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.synchronizeWithDirectionId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Direction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.TrafficLight.Direction} Direction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Direction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Direction message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Direction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.greenTime != null && message.hasOwnProperty("greenTime")) {
                            var error = $root.google.protobuf.FloatValue.verify(message.greenTime);
                            if (error)
                                return "greenTime." + error;
                        }
                        if (message.yellowTime != null && message.hasOwnProperty("yellowTime")) {
                            var error = $root.google.protobuf.FloatValue.verify(message.yellowTime);
                            if (error)
                                return "yellowTime." + error;
                        }
                        if (message.crosswalkWalkTime != null && message.hasOwnProperty("crosswalkWalkTime")) {
                            var error = $root.google.protobuf.FloatValue.verify(message.crosswalkWalkTime);
                            if (error)
                                return "crosswalkWalkTime." + error;
                        }
                        if (message.synchronizeWithDirectionId != null && message.hasOwnProperty("synchronizeWithDirectionId"))
                            if (!$util.isString(message.synchronizeWithDirectionId))
                                return "synchronizeWithDirectionId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Direction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.TrafficLight.Direction} Direction
                     */
                    Direction.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.TrafficLight.Direction)
                            return object;
                        var message = new $root.metamoto.types.Scenario.TrafficLight.Direction();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.greenTime != null) {
                            if (typeof object.greenTime !== "object")
                                throw TypeError(".metamoto.types.Scenario.TrafficLight.Direction.greenTime: object expected");
                            message.greenTime = $root.google.protobuf.FloatValue.fromObject(object.greenTime);
                        }
                        if (object.yellowTime != null) {
                            if (typeof object.yellowTime !== "object")
                                throw TypeError(".metamoto.types.Scenario.TrafficLight.Direction.yellowTime: object expected");
                            message.yellowTime = $root.google.protobuf.FloatValue.fromObject(object.yellowTime);
                        }
                        if (object.crosswalkWalkTime != null) {
                            if (typeof object.crosswalkWalkTime !== "object")
                                throw TypeError(".metamoto.types.Scenario.TrafficLight.Direction.crosswalkWalkTime: object expected");
                            message.crosswalkWalkTime = $root.google.protobuf.FloatValue.fromObject(object.crosswalkWalkTime);
                        }
                        if (object.synchronizeWithDirectionId != null)
                            message.synchronizeWithDirectionId = String(object.synchronizeWithDirectionId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Direction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @static
                     * @param {metamoto.types.Scenario.TrafficLight.Direction} message Direction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Direction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.greenTime = null;
                            object.yellowTime = null;
                            object.crosswalkWalkTime = null;
                            object.synchronizeWithDirectionId = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.greenTime != null && message.hasOwnProperty("greenTime"))
                            object.greenTime = $root.google.protobuf.FloatValue.toObject(message.greenTime, options);
                        if (message.yellowTime != null && message.hasOwnProperty("yellowTime"))
                            object.yellowTime = $root.google.protobuf.FloatValue.toObject(message.yellowTime, options);
                        if (message.crosswalkWalkTime != null && message.hasOwnProperty("crosswalkWalkTime"))
                            object.crosswalkWalkTime = $root.google.protobuf.FloatValue.toObject(message.crosswalkWalkTime, options);
                        if (message.synchronizeWithDirectionId != null && message.hasOwnProperty("synchronizeWithDirectionId"))
                            object.synchronizeWithDirectionId = message.synchronizeWithDirectionId;
                        return object;
                    };

                    /**
                     * Converts this Direction to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.TrafficLight.Direction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Direction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Direction;
                })();

                return TrafficLight;
            })();

            Scenario.Intersection = (function() {

                /**
                 * Properties of an Intersection.
                 * @memberof metamoto.types.Scenario
                 * @interface IIntersection
                 * @property {Array.<metamoto.types.Scenario.Intersection.IPhase>|null} [phases] Intersection phases
                 * @property {number|null} [startingPhaseIndex] Intersection startingPhaseIndex
                 * @property {number|null} [startingDurationOffset] Intersection startingDurationOffset
                 * @property {metamoto.types.IVector3|null} [position] Intersection position
                 * @property {string|null} [vectorId] Intersection vectorId
                 */

                /**
                 * Constructs a new Intersection.
                 * @memberof metamoto.types.Scenario
                 * @classdesc Represents an Intersection.
                 * @implements IIntersection
                 * @constructor
                 * @param {metamoto.types.Scenario.IIntersection=} [properties] Properties to set
                 */
                function Intersection(properties) {
                    this.phases = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Intersection phases.
                 * @member {Array.<metamoto.types.Scenario.Intersection.IPhase>} phases
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 */
                Intersection.prototype.phases = $util.emptyArray;

                /**
                 * Intersection startingPhaseIndex.
                 * @member {number} startingPhaseIndex
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 */
                Intersection.prototype.startingPhaseIndex = 0;

                /**
                 * Intersection startingDurationOffset.
                 * @member {number} startingDurationOffset
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 */
                Intersection.prototype.startingDurationOffset = 0;

                /**
                 * Intersection position.
                 * @member {metamoto.types.IVector3|null|undefined} position
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 */
                Intersection.prototype.position = null;

                /**
                 * Intersection vectorId.
                 * @member {string} vectorId
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 */
                Intersection.prototype.vectorId = "";

                /**
                 * Creates a new Intersection instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {metamoto.types.Scenario.IIntersection=} [properties] Properties to set
                 * @returns {metamoto.types.Scenario.Intersection} Intersection instance
                 */
                Intersection.create = function create(properties) {
                    return new Intersection(properties);
                };

                /**
                 * Encodes the specified Intersection message. Does not implicitly {@link metamoto.types.Scenario.Intersection.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {metamoto.types.Scenario.IIntersection} message Intersection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Intersection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phases != null && message.phases.length)
                        for (var i = 0; i < message.phases.length; ++i)
                            $root.metamoto.types.Scenario.Intersection.Phase.encode(message.phases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.startingPhaseIndex != null && message.hasOwnProperty("startingPhaseIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startingPhaseIndex);
                    if (message.startingDurationOffset != null && message.hasOwnProperty("startingDurationOffset"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.startingDurationOffset);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.metamoto.types.Vector3.encode(message.position, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.vectorId);
                    return writer;
                };

                /**
                 * Encodes the specified Intersection message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Intersection.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {metamoto.types.Scenario.IIntersection} message Intersection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Intersection.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Intersection message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Scenario.Intersection} Intersection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Intersection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Intersection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.phases && message.phases.length))
                                message.phases = [];
                            message.phases.push($root.metamoto.types.Scenario.Intersection.Phase.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.startingPhaseIndex = reader.int32();
                            break;
                        case 3:
                            message.startingDurationOffset = reader.float();
                            break;
                        case 4:
                            message.position = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.vectorId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Intersection message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Scenario.Intersection} Intersection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Intersection.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Intersection message.
                 * @function verify
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Intersection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.phases != null && message.hasOwnProperty("phases")) {
                        if (!Array.isArray(message.phases))
                            return "phases: array expected";
                        for (var i = 0; i < message.phases.length; ++i) {
                            var error = $root.metamoto.types.Scenario.Intersection.Phase.verify(message.phases[i]);
                            if (error)
                                return "phases." + error;
                        }
                    }
                    if (message.startingPhaseIndex != null && message.hasOwnProperty("startingPhaseIndex"))
                        if (!$util.isInteger(message.startingPhaseIndex))
                            return "startingPhaseIndex: integer expected";
                    if (message.startingDurationOffset != null && message.hasOwnProperty("startingDurationOffset"))
                        if (typeof message.startingDurationOffset !== "number")
                            return "startingDurationOffset: number expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.metamoto.types.Vector3.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                        if (!$util.isString(message.vectorId))
                            return "vectorId: string expected";
                    return null;
                };

                /**
                 * Creates an Intersection message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Scenario.Intersection} Intersection
                 */
                Intersection.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Scenario.Intersection)
                        return object;
                    var message = new $root.metamoto.types.Scenario.Intersection();
                    if (object.phases) {
                        if (!Array.isArray(object.phases))
                            throw TypeError(".metamoto.types.Scenario.Intersection.phases: array expected");
                        message.phases = [];
                        for (var i = 0; i < object.phases.length; ++i) {
                            if (typeof object.phases[i] !== "object")
                                throw TypeError(".metamoto.types.Scenario.Intersection.phases: object expected");
                            message.phases[i] = $root.metamoto.types.Scenario.Intersection.Phase.fromObject(object.phases[i]);
                        }
                    }
                    if (object.startingPhaseIndex != null)
                        message.startingPhaseIndex = object.startingPhaseIndex | 0;
                    if (object.startingDurationOffset != null)
                        message.startingDurationOffset = Number(object.startingDurationOffset);
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".metamoto.types.Scenario.Intersection.position: object expected");
                        message.position = $root.metamoto.types.Vector3.fromObject(object.position);
                    }
                    if (object.vectorId != null)
                        message.vectorId = String(object.vectorId);
                    return message;
                };

                /**
                 * Creates a plain object from an Intersection message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Scenario.Intersection
                 * @static
                 * @param {metamoto.types.Scenario.Intersection} message Intersection
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Intersection.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.phases = [];
                    if (options.defaults) {
                        object.startingPhaseIndex = 0;
                        object.startingDurationOffset = 0;
                        object.position = null;
                        object.vectorId = "";
                    }
                    if (message.phases && message.phases.length) {
                        object.phases = [];
                        for (var j = 0; j < message.phases.length; ++j)
                            object.phases[j] = $root.metamoto.types.Scenario.Intersection.Phase.toObject(message.phases[j], options);
                    }
                    if (message.startingPhaseIndex != null && message.hasOwnProperty("startingPhaseIndex"))
                        object.startingPhaseIndex = message.startingPhaseIndex;
                    if (message.startingDurationOffset != null && message.hasOwnProperty("startingDurationOffset"))
                        object.startingDurationOffset = options.json && !isFinite(message.startingDurationOffset) ? String(message.startingDurationOffset) : message.startingDurationOffset;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.metamoto.types.Vector3.toObject(message.position, options);
                    if (message.vectorId != null && message.hasOwnProperty("vectorId"))
                        object.vectorId = message.vectorId;
                    return object;
                };

                /**
                 * Converts this Intersection to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Scenario.Intersection
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Intersection.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Intersection.SignalState = (function() {

                    /**
                     * Properties of a SignalState.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @interface ISignalState
                     * @property {string|null} [signalId] SignalState signalId
                     * @property {string|null} [stateName] SignalState stateName
                     */

                    /**
                     * Constructs a new SignalState.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @classdesc Represents a SignalState.
                     * @implements ISignalState
                     * @constructor
                     * @param {metamoto.types.Scenario.Intersection.ISignalState=} [properties] Properties to set
                     */
                    function SignalState(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SignalState signalId.
                     * @member {string} signalId
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @instance
                     */
                    SignalState.prototype.signalId = "";

                    /**
                     * SignalState stateName.
                     * @member {string} stateName
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @instance
                     */
                    SignalState.prototype.stateName = "";

                    /**
                     * Creates a new SignalState instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.ISignalState=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.Intersection.SignalState} SignalState instance
                     */
                    SignalState.create = function create(properties) {
                        return new SignalState(properties);
                    };

                    /**
                     * Encodes the specified SignalState message. Does not implicitly {@link metamoto.types.Scenario.Intersection.SignalState.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.ISignalState} message SignalState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalState.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signalId != null && message.hasOwnProperty("signalId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
                        if (message.stateName != null && message.hasOwnProperty("stateName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.stateName);
                        return writer;
                    };

                    /**
                     * Encodes the specified SignalState message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Intersection.SignalState.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.ISignalState} message SignalState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalState.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SignalState message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.Intersection.SignalState} SignalState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalState.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Intersection.SignalState();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signalId = reader.string();
                                break;
                            case 2:
                                message.stateName = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SignalState message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.Intersection.SignalState} SignalState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalState.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SignalState message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SignalState.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signalId != null && message.hasOwnProperty("signalId"))
                            if (!$util.isString(message.signalId))
                                return "signalId: string expected";
                        if (message.stateName != null && message.hasOwnProperty("stateName"))
                            if (!$util.isString(message.stateName))
                                return "stateName: string expected";
                        return null;
                    };

                    /**
                     * Creates a SignalState message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.Intersection.SignalState} SignalState
                     */
                    SignalState.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.Intersection.SignalState)
                            return object;
                        var message = new $root.metamoto.types.Scenario.Intersection.SignalState();
                        if (object.signalId != null)
                            message.signalId = String(object.signalId);
                        if (object.stateName != null)
                            message.stateName = String(object.stateName);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SignalState message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.SignalState} message SignalState
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SignalState.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.signalId = "";
                            object.stateName = "";
                        }
                        if (message.signalId != null && message.hasOwnProperty("signalId"))
                            object.signalId = message.signalId;
                        if (message.stateName != null && message.hasOwnProperty("stateName"))
                            object.stateName = message.stateName;
                        return object;
                    };

                    /**
                     * Converts this SignalState to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.Intersection.SignalState
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SignalState.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SignalState;
                })();

                Intersection.IntersectionState = (function() {

                    /**
                     * Properties of an IntersectionState.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @interface IIntersectionState
                     * @property {number|null} [duration] IntersectionState duration
                     * @property {Array.<metamoto.types.Scenario.Intersection.ISignalState>|null} [signalStates] IntersectionState signalStates
                     */

                    /**
                     * Constructs a new IntersectionState.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @classdesc Represents an IntersectionState.
                     * @implements IIntersectionState
                     * @constructor
                     * @param {metamoto.types.Scenario.Intersection.IIntersectionState=} [properties] Properties to set
                     */
                    function IntersectionState(properties) {
                        this.signalStates = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IntersectionState duration.
                     * @member {number} duration
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @instance
                     */
                    IntersectionState.prototype.duration = 0;

                    /**
                     * IntersectionState signalStates.
                     * @member {Array.<metamoto.types.Scenario.Intersection.ISignalState>} signalStates
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @instance
                     */
                    IntersectionState.prototype.signalStates = $util.emptyArray;

                    /**
                     * Creates a new IntersectionState instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IIntersectionState=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.Intersection.IntersectionState} IntersectionState instance
                     */
                    IntersectionState.create = function create(properties) {
                        return new IntersectionState(properties);
                    };

                    /**
                     * Encodes the specified IntersectionState message. Does not implicitly {@link metamoto.types.Scenario.Intersection.IntersectionState.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IIntersectionState} message IntersectionState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IntersectionState.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.duration);
                        if (message.signalStates != null && message.signalStates.length)
                            for (var i = 0; i < message.signalStates.length; ++i)
                                $root.metamoto.types.Scenario.Intersection.SignalState.encode(message.signalStates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified IntersectionState message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Intersection.IntersectionState.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IIntersectionState} message IntersectionState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IntersectionState.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an IntersectionState message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.Intersection.IntersectionState} IntersectionState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IntersectionState.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Intersection.IntersectionState();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.duration = reader.float();
                                break;
                            case 2:
                                if (!(message.signalStates && message.signalStates.length))
                                    message.signalStates = [];
                                message.signalStates.push($root.metamoto.types.Scenario.Intersection.SignalState.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an IntersectionState message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.Intersection.IntersectionState} IntersectionState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IntersectionState.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an IntersectionState message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IntersectionState.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            if (typeof message.duration !== "number")
                                return "duration: number expected";
                        if (message.signalStates != null && message.hasOwnProperty("signalStates")) {
                            if (!Array.isArray(message.signalStates))
                                return "signalStates: array expected";
                            for (var i = 0; i < message.signalStates.length; ++i) {
                                var error = $root.metamoto.types.Scenario.Intersection.SignalState.verify(message.signalStates[i]);
                                if (error)
                                    return "signalStates." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an IntersectionState message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.Intersection.IntersectionState} IntersectionState
                     */
                    IntersectionState.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.Intersection.IntersectionState)
                            return object;
                        var message = new $root.metamoto.types.Scenario.Intersection.IntersectionState();
                        if (object.duration != null)
                            message.duration = Number(object.duration);
                        if (object.signalStates) {
                            if (!Array.isArray(object.signalStates))
                                throw TypeError(".metamoto.types.Scenario.Intersection.IntersectionState.signalStates: array expected");
                            message.signalStates = [];
                            for (var i = 0; i < object.signalStates.length; ++i) {
                                if (typeof object.signalStates[i] !== "object")
                                    throw TypeError(".metamoto.types.Scenario.Intersection.IntersectionState.signalStates: object expected");
                                message.signalStates[i] = $root.metamoto.types.Scenario.Intersection.SignalState.fromObject(object.signalStates[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an IntersectionState message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IntersectionState} message IntersectionState
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IntersectionState.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.signalStates = [];
                        if (options.defaults)
                            object.duration = 0;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                        if (message.signalStates && message.signalStates.length) {
                            object.signalStates = [];
                            for (var j = 0; j < message.signalStates.length; ++j)
                                object.signalStates[j] = $root.metamoto.types.Scenario.Intersection.SignalState.toObject(message.signalStates[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this IntersectionState to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.Intersection.IntersectionState
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IntersectionState.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IntersectionState;
                })();

                Intersection.Phase = (function() {

                    /**
                     * Properties of a Phase.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @interface IPhase
                     * @property {Array.<metamoto.types.Scenario.Intersection.IIntersectionState>|null} [intersectionStates] Phase intersectionStates
                     */

                    /**
                     * Constructs a new Phase.
                     * @memberof metamoto.types.Scenario.Intersection
                     * @classdesc Represents a Phase.
                     * @implements IPhase
                     * @constructor
                     * @param {metamoto.types.Scenario.Intersection.IPhase=} [properties] Properties to set
                     */
                    function Phase(properties) {
                        this.intersectionStates = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Phase intersectionStates.
                     * @member {Array.<metamoto.types.Scenario.Intersection.IIntersectionState>} intersectionStates
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @instance
                     */
                    Phase.prototype.intersectionStates = $util.emptyArray;

                    /**
                     * Creates a new Phase instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IPhase=} [properties] Properties to set
                     * @returns {metamoto.types.Scenario.Intersection.Phase} Phase instance
                     */
                    Phase.create = function create(properties) {
                        return new Phase(properties);
                    };

                    /**
                     * Encodes the specified Phase message. Does not implicitly {@link metamoto.types.Scenario.Intersection.Phase.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IPhase} message Phase message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Phase.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.intersectionStates != null && message.intersectionStates.length)
                            for (var i = 0; i < message.intersectionStates.length; ++i)
                                $root.metamoto.types.Scenario.Intersection.IntersectionState.encode(message.intersectionStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Phase message, length delimited. Does not implicitly {@link metamoto.types.Scenario.Intersection.Phase.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.IPhase} message Phase message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Phase.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Phase message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.Scenario.Intersection.Phase} Phase
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Phase.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scenario.Intersection.Phase();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.intersectionStates && message.intersectionStates.length))
                                    message.intersectionStates = [];
                                message.intersectionStates.push($root.metamoto.types.Scenario.Intersection.IntersectionState.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Phase message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.Scenario.Intersection.Phase} Phase
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Phase.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Phase message.
                     * @function verify
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Phase.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.intersectionStates != null && message.hasOwnProperty("intersectionStates")) {
                            if (!Array.isArray(message.intersectionStates))
                                return "intersectionStates: array expected";
                            for (var i = 0; i < message.intersectionStates.length; ++i) {
                                var error = $root.metamoto.types.Scenario.Intersection.IntersectionState.verify(message.intersectionStates[i]);
                                if (error)
                                    return "intersectionStates." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Phase message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.Scenario.Intersection.Phase} Phase
                     */
                    Phase.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.Scenario.Intersection.Phase)
                            return object;
                        var message = new $root.metamoto.types.Scenario.Intersection.Phase();
                        if (object.intersectionStates) {
                            if (!Array.isArray(object.intersectionStates))
                                throw TypeError(".metamoto.types.Scenario.Intersection.Phase.intersectionStates: array expected");
                            message.intersectionStates = [];
                            for (var i = 0; i < object.intersectionStates.length; ++i) {
                                if (typeof object.intersectionStates[i] !== "object")
                                    throw TypeError(".metamoto.types.Scenario.Intersection.Phase.intersectionStates: object expected");
                                message.intersectionStates[i] = $root.metamoto.types.Scenario.Intersection.IntersectionState.fromObject(object.intersectionStates[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Phase message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @static
                     * @param {metamoto.types.Scenario.Intersection.Phase} message Phase
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Phase.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.intersectionStates = [];
                        if (message.intersectionStates && message.intersectionStates.length) {
                            object.intersectionStates = [];
                            for (var j = 0; j < message.intersectionStates.length; ++j)
                                object.intersectionStates[j] = $root.metamoto.types.Scenario.Intersection.IntersectionState.toObject(message.intersectionStates[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Phase to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.Scenario.Intersection.Phase
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Phase.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Phase;
                })();

                return Intersection;
            })();

            return Scenario;
        })();

        types.Infraction = (function() {

            /**
             * Properties of an Infraction.
             * @memberof metamoto.types
             * @interface IInfraction
             * @property {metamoto.types.Infraction.Type|null} [type] Infraction type
             * @property {google.protobuf.IFloatValue|null} [failValue] Infraction failValue
             * @property {google.protobuf.IFloatValue|null} [stopValue] Infraction stopValue
             * @property {Array.<google.protobuf.IFloatValue>|null} [otherValues] Infraction otherValues
             */

            /**
             * Constructs a new Infraction.
             * @memberof metamoto.types
             * @classdesc Represents an Infraction.
             * @implements IInfraction
             * @constructor
             * @param {metamoto.types.IInfraction=} [properties] Properties to set
             */
            function Infraction(properties) {
                this.otherValues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Infraction type.
             * @member {metamoto.types.Infraction.Type} type
             * @memberof metamoto.types.Infraction
             * @instance
             */
            Infraction.prototype.type = 0;

            /**
             * Infraction failValue.
             * @member {google.protobuf.IFloatValue|null|undefined} failValue
             * @memberof metamoto.types.Infraction
             * @instance
             */
            Infraction.prototype.failValue = null;

            /**
             * Infraction stopValue.
             * @member {google.protobuf.IFloatValue|null|undefined} stopValue
             * @memberof metamoto.types.Infraction
             * @instance
             */
            Infraction.prototype.stopValue = null;

            /**
             * Infraction otherValues.
             * @member {Array.<google.protobuf.IFloatValue>} otherValues
             * @memberof metamoto.types.Infraction
             * @instance
             */
            Infraction.prototype.otherValues = $util.emptyArray;

            /**
             * Creates a new Infraction instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Infraction
             * @static
             * @param {metamoto.types.IInfraction=} [properties] Properties to set
             * @returns {metamoto.types.Infraction} Infraction instance
             */
            Infraction.create = function create(properties) {
                return new Infraction(properties);
            };

            /**
             * Encodes the specified Infraction message. Does not implicitly {@link metamoto.types.Infraction.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Infraction
             * @static
             * @param {metamoto.types.IInfraction} message Infraction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Infraction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.failValue != null && message.hasOwnProperty("failValue"))
                    $root.google.protobuf.FloatValue.encode(message.failValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.stopValue != null && message.hasOwnProperty("stopValue"))
                    $root.google.protobuf.FloatValue.encode(message.stopValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.otherValues != null && message.otherValues.length)
                    for (var i = 0; i < message.otherValues.length; ++i)
                        $root.google.protobuf.FloatValue.encode(message.otherValues[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Infraction message, length delimited. Does not implicitly {@link metamoto.types.Infraction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Infraction
             * @static
             * @param {metamoto.types.IInfraction} message Infraction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Infraction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Infraction message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Infraction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Infraction} Infraction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Infraction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Infraction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.failValue = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.stopValue = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.otherValues && message.otherValues.length))
                            message.otherValues = [];
                        message.otherValues.push($root.google.protobuf.FloatValue.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Infraction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Infraction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Infraction} Infraction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Infraction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Infraction message.
             * @function verify
             * @memberof metamoto.types.Infraction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Infraction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.failValue != null && message.hasOwnProperty("failValue")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.failValue);
                    if (error)
                        return "failValue." + error;
                }
                if (message.stopValue != null && message.hasOwnProperty("stopValue")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.stopValue);
                    if (error)
                        return "stopValue." + error;
                }
                if (message.otherValues != null && message.hasOwnProperty("otherValues")) {
                    if (!Array.isArray(message.otherValues))
                        return "otherValues: array expected";
                    for (var i = 0; i < message.otherValues.length; ++i) {
                        var error = $root.google.protobuf.FloatValue.verify(message.otherValues[i]);
                        if (error)
                            return "otherValues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Infraction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Infraction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Infraction} Infraction
             */
            Infraction.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Infraction)
                    return object;
                var message = new $root.metamoto.types.Infraction();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "VEHICLE_COLLISION":
                case 2:
                    message.type = 2;
                    break;
                case "PEDESTRIAN_COLLISION":
                case 3:
                    message.type = 3;
                    break;
                case "ENVIRONMENT_COLLISION":
                case 4:
                    message.type = 4;
                    break;
                case "OBSTACLE_COLLISION":
                case 5:
                    message.type = 5;
                    break;
                case "TRAFFIC_LIGHT":
                case 6:
                    message.type = 6;
                    break;
                case "STOP_SIGN":
                case 7:
                    message.type = 7;
                    break;
                case "SPEED_LIMIT":
                case 8:
                    message.type = 8;
                    break;
                case "HARD_BRAKE":
                case 9:
                    message.type = 9;
                    break;
                case "WRONG_WAY":
                case 10:
                    message.type = 10;
                    break;
                case "OFF_ROAD":
                case 11:
                    message.type = 11;
                    break;
                case "EXTERNAL_WARNING":
                case 12:
                    message.type = 12;
                    break;
                case "EXTERNAL_FAILURE":
                case 13:
                    message.type = 13;
                    break;
                case "EXTERNAL_PASS":
                case 14:
                    message.type = 14;
                    break;
                case "EXTERNAL_STOP":
                case 15:
                    message.type = 15;
                    break;
                }
                if (object.failValue != null) {
                    if (typeof object.failValue !== "object")
                        throw TypeError(".metamoto.types.Infraction.failValue: object expected");
                    message.failValue = $root.google.protobuf.FloatValue.fromObject(object.failValue);
                }
                if (object.stopValue != null) {
                    if (typeof object.stopValue !== "object")
                        throw TypeError(".metamoto.types.Infraction.stopValue: object expected");
                    message.stopValue = $root.google.protobuf.FloatValue.fromObject(object.stopValue);
                }
                if (object.otherValues) {
                    if (!Array.isArray(object.otherValues))
                        throw TypeError(".metamoto.types.Infraction.otherValues: array expected");
                    message.otherValues = [];
                    for (var i = 0; i < object.otherValues.length; ++i) {
                        if (typeof object.otherValues[i] !== "object")
                            throw TypeError(".metamoto.types.Infraction.otherValues: object expected");
                        message.otherValues[i] = $root.google.protobuf.FloatValue.fromObject(object.otherValues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Infraction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Infraction
             * @static
             * @param {metamoto.types.Infraction} message Infraction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Infraction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.otherValues = [];
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.failValue = null;
                    object.stopValue = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Infraction.Type[message.type] : message.type;
                if (message.failValue != null && message.hasOwnProperty("failValue"))
                    object.failValue = $root.google.protobuf.FloatValue.toObject(message.failValue, options);
                if (message.stopValue != null && message.hasOwnProperty("stopValue"))
                    object.stopValue = $root.google.protobuf.FloatValue.toObject(message.stopValue, options);
                if (message.otherValues && message.otherValues.length) {
                    object.otherValues = [];
                    for (var j = 0; j < message.otherValues.length; ++j)
                        object.otherValues[j] = $root.google.protobuf.FloatValue.toObject(message.otherValues[j], options);
                }
                return object;
            };

            /**
             * Converts this Infraction to JSON.
             * @function toJSON
             * @memberof metamoto.types.Infraction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Infraction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Infraction.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} VEHICLE_COLLISION=2 VEHICLE_COLLISION value
             * @property {number} PEDESTRIAN_COLLISION=3 PEDESTRIAN_COLLISION value
             * @property {number} ENVIRONMENT_COLLISION=4 ENVIRONMENT_COLLISION value
             * @property {number} OBSTACLE_COLLISION=5 OBSTACLE_COLLISION value
             * @property {number} TRAFFIC_LIGHT=6 TRAFFIC_LIGHT value
             * @property {number} STOP_SIGN=7 STOP_SIGN value
             * @property {number} SPEED_LIMIT=8 SPEED_LIMIT value
             * @property {number} HARD_BRAKE=9 HARD_BRAKE value
             * @property {number} WRONG_WAY=10 WRONG_WAY value
             * @property {number} OFF_ROAD=11 OFF_ROAD value
             * @property {number} EXTERNAL_WARNING=12 EXTERNAL_WARNING value
             * @property {number} EXTERNAL_FAILURE=13 EXTERNAL_FAILURE value
             * @property {number} EXTERNAL_PASS=14 EXTERNAL_PASS value
             * @property {number} EXTERNAL_STOP=15 EXTERNAL_STOP value
             */
            Infraction.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "VEHICLE_COLLISION"] = 2;
                values[valuesById[3] = "PEDESTRIAN_COLLISION"] = 3;
                values[valuesById[4] = "ENVIRONMENT_COLLISION"] = 4;
                values[valuesById[5] = "OBSTACLE_COLLISION"] = 5;
                values[valuesById[6] = "TRAFFIC_LIGHT"] = 6;
                values[valuesById[7] = "STOP_SIGN"] = 7;
                values[valuesById[8] = "SPEED_LIMIT"] = 8;
                values[valuesById[9] = "HARD_BRAKE"] = 9;
                values[valuesById[10] = "WRONG_WAY"] = 10;
                values[valuesById[11] = "OFF_ROAD"] = 11;
                values[valuesById[12] = "EXTERNAL_WARNING"] = 12;
                values[valuesById[13] = "EXTERNAL_FAILURE"] = 13;
                values[valuesById[14] = "EXTERNAL_PASS"] = 14;
                values[valuesById[15] = "EXTERNAL_STOP"] = 15;
                return values;
            })();

            return Infraction;
        })();

        types.DriverModel = (function() {

            /**
             * Properties of a DriverModel.
             * @memberof metamoto.types
             * @interface IDriverModel
             * @property {number|null} [collisionAvoidance] DriverModel collisionAvoidance
             * @property {number|null} [speedCoefficient] DriverModel speedCoefficient
             * @property {boolean|null} [obeysLights] DriverModel obeysLights
             * @property {boolean|null} [randomPath] DriverModel randomPath
             * @property {number|null} [laneChangeOptimization] DriverModel laneChangeOptimization
             * @property {number|null} [laneCenterDeviation] DriverModel laneCenterDeviation
             * @property {number|null} [timegapMultiplier] DriverModel timegapMultiplier
             * @property {metamoto.types.DriverModel.IBrakingBehavior|null} [brakingBehavior] DriverModel brakingBehavior
             */

            /**
             * Constructs a new DriverModel.
             * @memberof metamoto.types
             * @classdesc Represents a DriverModel.
             * @implements IDriverModel
             * @constructor
             * @param {metamoto.types.IDriverModel=} [properties] Properties to set
             */
            function DriverModel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DriverModel collisionAvoidance.
             * @member {number} collisionAvoidance
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.collisionAvoidance = 0;

            /**
             * DriverModel speedCoefficient.
             * @member {number} speedCoefficient
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.speedCoefficient = 0;

            /**
             * DriverModel obeysLights.
             * @member {boolean} obeysLights
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.obeysLights = false;

            /**
             * DriverModel randomPath.
             * @member {boolean} randomPath
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.randomPath = false;

            /**
             * DriverModel laneChangeOptimization.
             * @member {number} laneChangeOptimization
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.laneChangeOptimization = 0;

            /**
             * DriverModel laneCenterDeviation.
             * @member {number} laneCenterDeviation
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.laneCenterDeviation = 0;

            /**
             * DriverModel timegapMultiplier.
             * @member {number} timegapMultiplier
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.timegapMultiplier = 0;

            /**
             * DriverModel brakingBehavior.
             * @member {metamoto.types.DriverModel.IBrakingBehavior|null|undefined} brakingBehavior
             * @memberof metamoto.types.DriverModel
             * @instance
             */
            DriverModel.prototype.brakingBehavior = null;

            /**
             * Creates a new DriverModel instance using the specified properties.
             * @function create
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {metamoto.types.IDriverModel=} [properties] Properties to set
             * @returns {metamoto.types.DriverModel} DriverModel instance
             */
            DriverModel.create = function create(properties) {
                return new DriverModel(properties);
            };

            /**
             * Encodes the specified DriverModel message. Does not implicitly {@link metamoto.types.DriverModel.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {metamoto.types.IDriverModel} message DriverModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DriverModel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collisionAvoidance != null && message.hasOwnProperty("collisionAvoidance"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.collisionAvoidance);
                if (message.speedCoefficient != null && message.hasOwnProperty("speedCoefficient"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.speedCoefficient);
                if (message.obeysLights != null && message.hasOwnProperty("obeysLights"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.obeysLights);
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.randomPath);
                if (message.laneChangeOptimization != null && message.hasOwnProperty("laneChangeOptimization"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.laneChangeOptimization);
                if (message.laneCenterDeviation != null && message.hasOwnProperty("laneCenterDeviation"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.laneCenterDeviation);
                if (message.timegapMultiplier != null && message.hasOwnProperty("timegapMultiplier"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.timegapMultiplier);
                if (message.brakingBehavior != null && message.hasOwnProperty("brakingBehavior"))
                    $root.metamoto.types.DriverModel.BrakingBehavior.encode(message.brakingBehavior, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DriverModel message, length delimited. Does not implicitly {@link metamoto.types.DriverModel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {metamoto.types.IDriverModel} message DriverModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DriverModel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DriverModel message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.DriverModel} DriverModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DriverModel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.DriverModel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collisionAvoidance = reader.float();
                        break;
                    case 2:
                        message.speedCoefficient = reader.float();
                        break;
                    case 3:
                        message.obeysLights = reader.bool();
                        break;
                    case 4:
                        message.randomPath = reader.bool();
                        break;
                    case 5:
                        message.laneChangeOptimization = reader.float();
                        break;
                    case 6:
                        message.laneCenterDeviation = reader.float();
                        break;
                    case 7:
                        message.timegapMultiplier = reader.float();
                        break;
                    case 9:
                        message.brakingBehavior = $root.metamoto.types.DriverModel.BrakingBehavior.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DriverModel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.DriverModel} DriverModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DriverModel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DriverModel message.
             * @function verify
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DriverModel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collisionAvoidance != null && message.hasOwnProperty("collisionAvoidance"))
                    if (typeof message.collisionAvoidance !== "number")
                        return "collisionAvoidance: number expected";
                if (message.speedCoefficient != null && message.hasOwnProperty("speedCoefficient"))
                    if (typeof message.speedCoefficient !== "number")
                        return "speedCoefficient: number expected";
                if (message.obeysLights != null && message.hasOwnProperty("obeysLights"))
                    if (typeof message.obeysLights !== "boolean")
                        return "obeysLights: boolean expected";
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    if (typeof message.randomPath !== "boolean")
                        return "randomPath: boolean expected";
                if (message.laneChangeOptimization != null && message.hasOwnProperty("laneChangeOptimization"))
                    if (typeof message.laneChangeOptimization !== "number")
                        return "laneChangeOptimization: number expected";
                if (message.laneCenterDeviation != null && message.hasOwnProperty("laneCenterDeviation"))
                    if (typeof message.laneCenterDeviation !== "number")
                        return "laneCenterDeviation: number expected";
                if (message.timegapMultiplier != null && message.hasOwnProperty("timegapMultiplier"))
                    if (typeof message.timegapMultiplier !== "number")
                        return "timegapMultiplier: number expected";
                if (message.brakingBehavior != null && message.hasOwnProperty("brakingBehavior")) {
                    var error = $root.metamoto.types.DriverModel.BrakingBehavior.verify(message.brakingBehavior);
                    if (error)
                        return "brakingBehavior." + error;
                }
                return null;
            };

            /**
             * Creates a DriverModel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.DriverModel} DriverModel
             */
            DriverModel.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.DriverModel)
                    return object;
                var message = new $root.metamoto.types.DriverModel();
                if (object.collisionAvoidance != null)
                    message.collisionAvoidance = Number(object.collisionAvoidance);
                if (object.speedCoefficient != null)
                    message.speedCoefficient = Number(object.speedCoefficient);
                if (object.obeysLights != null)
                    message.obeysLights = Boolean(object.obeysLights);
                if (object.randomPath != null)
                    message.randomPath = Boolean(object.randomPath);
                if (object.laneChangeOptimization != null)
                    message.laneChangeOptimization = Number(object.laneChangeOptimization);
                if (object.laneCenterDeviation != null)
                    message.laneCenterDeviation = Number(object.laneCenterDeviation);
                if (object.timegapMultiplier != null)
                    message.timegapMultiplier = Number(object.timegapMultiplier);
                if (object.brakingBehavior != null) {
                    if (typeof object.brakingBehavior !== "object")
                        throw TypeError(".metamoto.types.DriverModel.brakingBehavior: object expected");
                    message.brakingBehavior = $root.metamoto.types.DriverModel.BrakingBehavior.fromObject(object.brakingBehavior);
                }
                return message;
            };

            /**
             * Creates a plain object from a DriverModel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.DriverModel
             * @static
             * @param {metamoto.types.DriverModel} message DriverModel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DriverModel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collisionAvoidance = 0;
                    object.speedCoefficient = 0;
                    object.obeysLights = false;
                    object.randomPath = false;
                    object.laneChangeOptimization = 0;
                    object.laneCenterDeviation = 0;
                    object.timegapMultiplier = 0;
                    object.brakingBehavior = null;
                }
                if (message.collisionAvoidance != null && message.hasOwnProperty("collisionAvoidance"))
                    object.collisionAvoidance = options.json && !isFinite(message.collisionAvoidance) ? String(message.collisionAvoidance) : message.collisionAvoidance;
                if (message.speedCoefficient != null && message.hasOwnProperty("speedCoefficient"))
                    object.speedCoefficient = options.json && !isFinite(message.speedCoefficient) ? String(message.speedCoefficient) : message.speedCoefficient;
                if (message.obeysLights != null && message.hasOwnProperty("obeysLights"))
                    object.obeysLights = message.obeysLights;
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    object.randomPath = message.randomPath;
                if (message.laneChangeOptimization != null && message.hasOwnProperty("laneChangeOptimization"))
                    object.laneChangeOptimization = options.json && !isFinite(message.laneChangeOptimization) ? String(message.laneChangeOptimization) : message.laneChangeOptimization;
                if (message.laneCenterDeviation != null && message.hasOwnProperty("laneCenterDeviation"))
                    object.laneCenterDeviation = options.json && !isFinite(message.laneCenterDeviation) ? String(message.laneCenterDeviation) : message.laneCenterDeviation;
                if (message.timegapMultiplier != null && message.hasOwnProperty("timegapMultiplier"))
                    object.timegapMultiplier = options.json && !isFinite(message.timegapMultiplier) ? String(message.timegapMultiplier) : message.timegapMultiplier;
                if (message.brakingBehavior != null && message.hasOwnProperty("brakingBehavior"))
                    object.brakingBehavior = $root.metamoto.types.DriverModel.BrakingBehavior.toObject(message.brakingBehavior, options);
                return object;
            };

            /**
             * Converts this DriverModel to JSON.
             * @function toJSON
             * @memberof metamoto.types.DriverModel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DriverModel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DriverModel.BrakingBehavior = (function() {

                /**
                 * Properties of a BrakingBehavior.
                 * @memberof metamoto.types.DriverModel
                 * @interface IBrakingBehavior
                 * @property {number|null} [coastDecelerationThreshold] BrakingBehavior coastDecelerationThreshold
                 * @property {number|null} [coastSpeedThreshold] BrakingBehavior coastSpeedThreshold
                 * @property {number|null} [minBrake] BrakingBehavior minBrake
                 */

                /**
                 * Constructs a new BrakingBehavior.
                 * @memberof metamoto.types.DriverModel
                 * @classdesc Represents a BrakingBehavior.
                 * @implements IBrakingBehavior
                 * @constructor
                 * @param {metamoto.types.DriverModel.IBrakingBehavior=} [properties] Properties to set
                 */
                function BrakingBehavior(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BrakingBehavior coastDecelerationThreshold.
                 * @member {number} coastDecelerationThreshold
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @instance
                 */
                BrakingBehavior.prototype.coastDecelerationThreshold = 0;

                /**
                 * BrakingBehavior coastSpeedThreshold.
                 * @member {number} coastSpeedThreshold
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @instance
                 */
                BrakingBehavior.prototype.coastSpeedThreshold = 0;

                /**
                 * BrakingBehavior minBrake.
                 * @member {number} minBrake
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @instance
                 */
                BrakingBehavior.prototype.minBrake = 0;

                /**
                 * Creates a new BrakingBehavior instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {metamoto.types.DriverModel.IBrakingBehavior=} [properties] Properties to set
                 * @returns {metamoto.types.DriverModel.BrakingBehavior} BrakingBehavior instance
                 */
                BrakingBehavior.create = function create(properties) {
                    return new BrakingBehavior(properties);
                };

                /**
                 * Encodes the specified BrakingBehavior message. Does not implicitly {@link metamoto.types.DriverModel.BrakingBehavior.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {metamoto.types.DriverModel.IBrakingBehavior} message BrakingBehavior message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrakingBehavior.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.coastSpeedThreshold != null && message.hasOwnProperty("coastSpeedThreshold"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.coastSpeedThreshold);
                    if (message.minBrake != null && message.hasOwnProperty("minBrake"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.minBrake);
                    if (message.coastDecelerationThreshold != null && message.hasOwnProperty("coastDecelerationThreshold"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.coastDecelerationThreshold);
                    return writer;
                };

                /**
                 * Encodes the specified BrakingBehavior message, length delimited. Does not implicitly {@link metamoto.types.DriverModel.BrakingBehavior.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {metamoto.types.DriverModel.IBrakingBehavior} message BrakingBehavior message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrakingBehavior.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BrakingBehavior message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.DriverModel.BrakingBehavior} BrakingBehavior
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrakingBehavior.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.DriverModel.BrakingBehavior();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 7:
                            message.coastDecelerationThreshold = reader.float();
                            break;
                        case 1:
                            message.coastSpeedThreshold = reader.float();
                            break;
                        case 2:
                            message.minBrake = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BrakingBehavior message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.DriverModel.BrakingBehavior} BrakingBehavior
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrakingBehavior.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BrakingBehavior message.
                 * @function verify
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BrakingBehavior.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.coastDecelerationThreshold != null && message.hasOwnProperty("coastDecelerationThreshold"))
                        if (typeof message.coastDecelerationThreshold !== "number")
                            return "coastDecelerationThreshold: number expected";
                    if (message.coastSpeedThreshold != null && message.hasOwnProperty("coastSpeedThreshold"))
                        if (typeof message.coastSpeedThreshold !== "number")
                            return "coastSpeedThreshold: number expected";
                    if (message.minBrake != null && message.hasOwnProperty("minBrake"))
                        if (typeof message.minBrake !== "number")
                            return "minBrake: number expected";
                    return null;
                };

                /**
                 * Creates a BrakingBehavior message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.DriverModel.BrakingBehavior} BrakingBehavior
                 */
                BrakingBehavior.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.DriverModel.BrakingBehavior)
                        return object;
                    var message = new $root.metamoto.types.DriverModel.BrakingBehavior();
                    if (object.coastDecelerationThreshold != null)
                        message.coastDecelerationThreshold = Number(object.coastDecelerationThreshold);
                    if (object.coastSpeedThreshold != null)
                        message.coastSpeedThreshold = Number(object.coastSpeedThreshold);
                    if (object.minBrake != null)
                        message.minBrake = Number(object.minBrake);
                    return message;
                };

                /**
                 * Creates a plain object from a BrakingBehavior message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @static
                 * @param {metamoto.types.DriverModel.BrakingBehavior} message BrakingBehavior
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrakingBehavior.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.coastSpeedThreshold = 0;
                        object.minBrake = 0;
                        object.coastDecelerationThreshold = 0;
                    }
                    if (message.coastSpeedThreshold != null && message.hasOwnProperty("coastSpeedThreshold"))
                        object.coastSpeedThreshold = options.json && !isFinite(message.coastSpeedThreshold) ? String(message.coastSpeedThreshold) : message.coastSpeedThreshold;
                    if (message.minBrake != null && message.hasOwnProperty("minBrake"))
                        object.minBrake = options.json && !isFinite(message.minBrake) ? String(message.minBrake) : message.minBrake;
                    if (message.coastDecelerationThreshold != null && message.hasOwnProperty("coastDecelerationThreshold"))
                        object.coastDecelerationThreshold = options.json && !isFinite(message.coastDecelerationThreshold) ? String(message.coastDecelerationThreshold) : message.coastDecelerationThreshold;
                    return object;
                };

                /**
                 * Converts this BrakingBehavior to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.DriverModel.BrakingBehavior
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrakingBehavior.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BrakingBehavior;
            })();

            return DriverModel;
        })();

        types.TrafficFlow = (function() {

            /**
             * Properties of a TrafficFlow.
             * @memberof metamoto.types
             * @interface ITrafficFlow
             * @property {number|null} [id] TrafficFlow id
             * @property {metamoto.types.TrafficFlow.ILaneSpan|null} [source] TrafficFlow source
             * @property {Array.<metamoto.types.TrafficFlow.ILaneSpan>|null} [sinks] TrafficFlow sinks
             * @property {metamoto.types.INormalDistribution|null} [generationRate] TrafficFlow generationRate
             * @property {number|null} [speed] TrafficFlow speed
             * @property {boolean|null} [populate] TrafficFlow populate
             */

            /**
             * Constructs a new TrafficFlow.
             * @memberof metamoto.types
             * @classdesc Represents a TrafficFlow.
             * @implements ITrafficFlow
             * @constructor
             * @param {metamoto.types.ITrafficFlow=} [properties] Properties to set
             */
            function TrafficFlow(properties) {
                this.sinks = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TrafficFlow id.
             * @member {number} id
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.id = 0;

            /**
             * TrafficFlow source.
             * @member {metamoto.types.TrafficFlow.ILaneSpan|null|undefined} source
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.source = null;

            /**
             * TrafficFlow sinks.
             * @member {Array.<metamoto.types.TrafficFlow.ILaneSpan>} sinks
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.sinks = $util.emptyArray;

            /**
             * TrafficFlow generationRate.
             * @member {metamoto.types.INormalDistribution|null|undefined} generationRate
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.generationRate = null;

            /**
             * TrafficFlow speed.
             * @member {number} speed
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.speed = 0;

            /**
             * TrafficFlow populate.
             * @member {boolean} populate
             * @memberof metamoto.types.TrafficFlow
             * @instance
             */
            TrafficFlow.prototype.populate = false;

            /**
             * Creates a new TrafficFlow instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {metamoto.types.ITrafficFlow=} [properties] Properties to set
             * @returns {metamoto.types.TrafficFlow} TrafficFlow instance
             */
            TrafficFlow.create = function create(properties) {
                return new TrafficFlow(properties);
            };

            /**
             * Encodes the specified TrafficFlow message. Does not implicitly {@link metamoto.types.TrafficFlow.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {metamoto.types.ITrafficFlow} message TrafficFlow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficFlow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.source != null && message.hasOwnProperty("source"))
                    $root.metamoto.types.TrafficFlow.LaneSpan.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sinks != null && message.sinks.length)
                    for (var i = 0; i < message.sinks.length; ++i)
                        $root.metamoto.types.TrafficFlow.LaneSpan.encode(message.sinks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.generationRate != null && message.hasOwnProperty("generationRate"))
                    $root.metamoto.types.NormalDistribution.encode(message.generationRate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.speed != null && message.hasOwnProperty("speed"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.speed);
                if (message.populate != null && message.hasOwnProperty("populate"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.populate);
                return writer;
            };

            /**
             * Encodes the specified TrafficFlow message, length delimited. Does not implicitly {@link metamoto.types.TrafficFlow.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {metamoto.types.ITrafficFlow} message TrafficFlow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficFlow.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TrafficFlow message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TrafficFlow} TrafficFlow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficFlow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TrafficFlow();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.source = $root.metamoto.types.TrafficFlow.LaneSpan.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.sinks && message.sinks.length))
                            message.sinks = [];
                        message.sinks.push($root.metamoto.types.TrafficFlow.LaneSpan.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.generationRate = $root.metamoto.types.NormalDistribution.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.speed = reader.float();
                        break;
                    case 6:
                        message.populate = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TrafficFlow message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TrafficFlow} TrafficFlow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficFlow.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TrafficFlow message.
             * @function verify
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TrafficFlow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.source != null && message.hasOwnProperty("source")) {
                    var error = $root.metamoto.types.TrafficFlow.LaneSpan.verify(message.source);
                    if (error)
                        return "source." + error;
                }
                if (message.sinks != null && message.hasOwnProperty("sinks")) {
                    if (!Array.isArray(message.sinks))
                        return "sinks: array expected";
                    for (var i = 0; i < message.sinks.length; ++i) {
                        var error = $root.metamoto.types.TrafficFlow.LaneSpan.verify(message.sinks[i]);
                        if (error)
                            return "sinks." + error;
                    }
                }
                if (message.generationRate != null && message.hasOwnProperty("generationRate")) {
                    var error = $root.metamoto.types.NormalDistribution.verify(message.generationRate);
                    if (error)
                        return "generationRate." + error;
                }
                if (message.speed != null && message.hasOwnProperty("speed"))
                    if (typeof message.speed !== "number")
                        return "speed: number expected";
                if (message.populate != null && message.hasOwnProperty("populate"))
                    if (typeof message.populate !== "boolean")
                        return "populate: boolean expected";
                return null;
            };

            /**
             * Creates a TrafficFlow message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TrafficFlow} TrafficFlow
             */
            TrafficFlow.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TrafficFlow)
                    return object;
                var message = new $root.metamoto.types.TrafficFlow();
                if (object.id != null)
                    message.id = object.id | 0;
                if (object.source != null) {
                    if (typeof object.source !== "object")
                        throw TypeError(".metamoto.types.TrafficFlow.source: object expected");
                    message.source = $root.metamoto.types.TrafficFlow.LaneSpan.fromObject(object.source);
                }
                if (object.sinks) {
                    if (!Array.isArray(object.sinks))
                        throw TypeError(".metamoto.types.TrafficFlow.sinks: array expected");
                    message.sinks = [];
                    for (var i = 0; i < object.sinks.length; ++i) {
                        if (typeof object.sinks[i] !== "object")
                            throw TypeError(".metamoto.types.TrafficFlow.sinks: object expected");
                        message.sinks[i] = $root.metamoto.types.TrafficFlow.LaneSpan.fromObject(object.sinks[i]);
                    }
                }
                if (object.generationRate != null) {
                    if (typeof object.generationRate !== "object")
                        throw TypeError(".metamoto.types.TrafficFlow.generationRate: object expected");
                    message.generationRate = $root.metamoto.types.NormalDistribution.fromObject(object.generationRate);
                }
                if (object.speed != null)
                    message.speed = Number(object.speed);
                if (object.populate != null)
                    message.populate = Boolean(object.populate);
                return message;
            };

            /**
             * Creates a plain object from a TrafficFlow message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TrafficFlow
             * @static
             * @param {metamoto.types.TrafficFlow} message TrafficFlow
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TrafficFlow.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sinks = [];
                if (options.defaults) {
                    object.id = 0;
                    object.source = null;
                    object.generationRate = null;
                    object.speed = 0;
                    object.populate = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = $root.metamoto.types.TrafficFlow.LaneSpan.toObject(message.source, options);
                if (message.sinks && message.sinks.length) {
                    object.sinks = [];
                    for (var j = 0; j < message.sinks.length; ++j)
                        object.sinks[j] = $root.metamoto.types.TrafficFlow.LaneSpan.toObject(message.sinks[j], options);
                }
                if (message.generationRate != null && message.hasOwnProperty("generationRate"))
                    object.generationRate = $root.metamoto.types.NormalDistribution.toObject(message.generationRate, options);
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                if (message.populate != null && message.hasOwnProperty("populate"))
                    object.populate = message.populate;
                return object;
            };

            /**
             * Converts this TrafficFlow to JSON.
             * @function toJSON
             * @memberof metamoto.types.TrafficFlow
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TrafficFlow.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            TrafficFlow.LaneSpan = (function() {

                /**
                 * Properties of a LaneSpan.
                 * @memberof metamoto.types.TrafficFlow
                 * @interface ILaneSpan
                 * @property {string|null} [roadId] LaneSpan roadId
                 * @property {number|null} [s] LaneSpan s
                 * @property {Array.<number>|null} [lanes] LaneSpan lanes
                 * @property {Array.<metamoto.types.IVector3>|null} [positions] LaneSpan positions
                 */

                /**
                 * Constructs a new LaneSpan.
                 * @memberof metamoto.types.TrafficFlow
                 * @classdesc Represents a LaneSpan.
                 * @implements ILaneSpan
                 * @constructor
                 * @param {metamoto.types.TrafficFlow.ILaneSpan=} [properties] Properties to set
                 */
                function LaneSpan(properties) {
                    this.lanes = [];
                    this.positions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LaneSpan roadId.
                 * @member {string} roadId
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @instance
                 */
                LaneSpan.prototype.roadId = "";

                /**
                 * LaneSpan s.
                 * @member {number} s
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @instance
                 */
                LaneSpan.prototype.s = 0;

                /**
                 * LaneSpan lanes.
                 * @member {Array.<number>} lanes
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @instance
                 */
                LaneSpan.prototype.lanes = $util.emptyArray;

                /**
                 * LaneSpan positions.
                 * @member {Array.<metamoto.types.IVector3>} positions
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @instance
                 */
                LaneSpan.prototype.positions = $util.emptyArray;

                /**
                 * Creates a new LaneSpan instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {metamoto.types.TrafficFlow.ILaneSpan=} [properties] Properties to set
                 * @returns {metamoto.types.TrafficFlow.LaneSpan} LaneSpan instance
                 */
                LaneSpan.create = function create(properties) {
                    return new LaneSpan(properties);
                };

                /**
                 * Encodes the specified LaneSpan message. Does not implicitly {@link metamoto.types.TrafficFlow.LaneSpan.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {metamoto.types.TrafficFlow.ILaneSpan} message LaneSpan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaneSpan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.roadId);
                    if (message.s != null && message.hasOwnProperty("s"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.s);
                    if (message.lanes != null && message.lanes.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (var i = 0; i < message.lanes.length; ++i)
                            writer.int32(message.lanes[i]);
                        writer.ldelim();
                    }
                    if (message.positions != null && message.positions.length)
                        for (var i = 0; i < message.positions.length; ++i)
                            $root.metamoto.types.Vector3.encode(message.positions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LaneSpan message, length delimited. Does not implicitly {@link metamoto.types.TrafficFlow.LaneSpan.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {metamoto.types.TrafficFlow.ILaneSpan} message LaneSpan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaneSpan.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LaneSpan message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TrafficFlow.LaneSpan} LaneSpan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaneSpan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TrafficFlow.LaneSpan();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.roadId = reader.string();
                            break;
                        case 2:
                            message.s = reader.float();
                            break;
                        case 3:
                            if (!(message.lanes && message.lanes.length))
                                message.lanes = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.lanes.push(reader.int32());
                            } else
                                message.lanes.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.positions && message.positions.length))
                                message.positions = [];
                            message.positions.push($root.metamoto.types.Vector3.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LaneSpan message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TrafficFlow.LaneSpan} LaneSpan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaneSpan.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LaneSpan message.
                 * @function verify
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaneSpan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        if (!$util.isString(message.roadId))
                            return "roadId: string expected";
                    if (message.s != null && message.hasOwnProperty("s"))
                        if (typeof message.s !== "number")
                            return "s: number expected";
                    if (message.lanes != null && message.hasOwnProperty("lanes")) {
                        if (!Array.isArray(message.lanes))
                            return "lanes: array expected";
                        for (var i = 0; i < message.lanes.length; ++i)
                            if (!$util.isInteger(message.lanes[i]))
                                return "lanes: integer[] expected";
                    }
                    if (message.positions != null && message.hasOwnProperty("positions")) {
                        if (!Array.isArray(message.positions))
                            return "positions: array expected";
                        for (var i = 0; i < message.positions.length; ++i) {
                            var error = $root.metamoto.types.Vector3.verify(message.positions[i]);
                            if (error)
                                return "positions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a LaneSpan message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TrafficFlow.LaneSpan} LaneSpan
                 */
                LaneSpan.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TrafficFlow.LaneSpan)
                        return object;
                    var message = new $root.metamoto.types.TrafficFlow.LaneSpan();
                    if (object.roadId != null)
                        message.roadId = String(object.roadId);
                    if (object.s != null)
                        message.s = Number(object.s);
                    if (object.lanes) {
                        if (!Array.isArray(object.lanes))
                            throw TypeError(".metamoto.types.TrafficFlow.LaneSpan.lanes: array expected");
                        message.lanes = [];
                        for (var i = 0; i < object.lanes.length; ++i)
                            message.lanes[i] = object.lanes[i] | 0;
                    }
                    if (object.positions) {
                        if (!Array.isArray(object.positions))
                            throw TypeError(".metamoto.types.TrafficFlow.LaneSpan.positions: array expected");
                        message.positions = [];
                        for (var i = 0; i < object.positions.length; ++i) {
                            if (typeof object.positions[i] !== "object")
                                throw TypeError(".metamoto.types.TrafficFlow.LaneSpan.positions: object expected");
                            message.positions[i] = $root.metamoto.types.Vector3.fromObject(object.positions[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LaneSpan message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @static
                 * @param {metamoto.types.TrafficFlow.LaneSpan} message LaneSpan
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LaneSpan.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.lanes = [];
                        object.positions = [];
                    }
                    if (options.defaults) {
                        object.roadId = "";
                        object.s = 0;
                    }
                    if (message.roadId != null && message.hasOwnProperty("roadId"))
                        object.roadId = message.roadId;
                    if (message.s != null && message.hasOwnProperty("s"))
                        object.s = options.json && !isFinite(message.s) ? String(message.s) : message.s;
                    if (message.lanes && message.lanes.length) {
                        object.lanes = [];
                        for (var j = 0; j < message.lanes.length; ++j)
                            object.lanes[j] = message.lanes[j];
                    }
                    if (message.positions && message.positions.length) {
                        object.positions = [];
                        for (var j = 0; j < message.positions.length; ++j)
                            object.positions[j] = $root.metamoto.types.Vector3.toObject(message.positions[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this LaneSpan to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TrafficFlow.LaneSpan
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LaneSpan.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LaneSpan;
            })();

            return TrafficFlow;
        })();

        types.TrafficVehicle = (function() {

            /**
             * Properties of a TrafficVehicle.
             * @memberof metamoto.types
             * @interface ITrafficVehicle
             * @property {string|null} [displayName] TrafficVehicle displayName
             * @property {metamoto.types.IVehicleInstance|null} [instance] TrafficVehicle instance
             * @property {Array.<metamoto.types.IWaypoint>|null} [path] TrafficVehicle path
             * @property {metamoto.types.IDriverModel|null} [driverModel] TrafficVehicle driverModel
             * @property {number|null} [flowId] TrafficVehicle flowId
             */

            /**
             * Constructs a new TrafficVehicle.
             * @memberof metamoto.types
             * @classdesc Represents a TrafficVehicle.
             * @implements ITrafficVehicle
             * @constructor
             * @param {metamoto.types.ITrafficVehicle=} [properties] Properties to set
             */
            function TrafficVehicle(properties) {
                this.path = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TrafficVehicle displayName.
             * @member {string} displayName
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             */
            TrafficVehicle.prototype.displayName = "";

            /**
             * TrafficVehicle instance.
             * @member {metamoto.types.IVehicleInstance|null|undefined} instance
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             */
            TrafficVehicle.prototype.instance = null;

            /**
             * TrafficVehicle path.
             * @member {Array.<metamoto.types.IWaypoint>} path
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             */
            TrafficVehicle.prototype.path = $util.emptyArray;

            /**
             * TrafficVehicle driverModel.
             * @member {metamoto.types.IDriverModel|null|undefined} driverModel
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             */
            TrafficVehicle.prototype.driverModel = null;

            /**
             * TrafficVehicle flowId.
             * @member {number} flowId
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             */
            TrafficVehicle.prototype.flowId = 0;

            /**
             * Creates a new TrafficVehicle instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {metamoto.types.ITrafficVehicle=} [properties] Properties to set
             * @returns {metamoto.types.TrafficVehicle} TrafficVehicle instance
             */
            TrafficVehicle.create = function create(properties) {
                return new TrafficVehicle(properties);
            };

            /**
             * Encodes the specified TrafficVehicle message. Does not implicitly {@link metamoto.types.TrafficVehicle.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {metamoto.types.ITrafficVehicle} message TrafficVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficVehicle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.instance != null && message.hasOwnProperty("instance"))
                    $root.metamoto.types.VehicleInstance.encode(message.instance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.path != null && message.path.length)
                    for (var i = 0; i < message.path.length; ++i)
                        $root.metamoto.types.Waypoint.encode(message.path[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.driverModel != null && message.hasOwnProperty("driverModel"))
                    $root.metamoto.types.DriverModel.encode(message.driverModel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.flowId != null && message.hasOwnProperty("flowId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flowId);
                return writer;
            };

            /**
             * Encodes the specified TrafficVehicle message, length delimited. Does not implicitly {@link metamoto.types.TrafficVehicle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {metamoto.types.ITrafficVehicle} message TrafficVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficVehicle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TrafficVehicle message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TrafficVehicle} TrafficVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficVehicle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TrafficVehicle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 2:
                        message.instance = $root.metamoto.types.VehicleInstance.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push($root.metamoto.types.Waypoint.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.driverModel = $root.metamoto.types.DriverModel.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.flowId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TrafficVehicle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TrafficVehicle} TrafficVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficVehicle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TrafficVehicle message.
             * @function verify
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TrafficVehicle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.instance != null && message.hasOwnProperty("instance")) {
                    var error = $root.metamoto.types.VehicleInstance.verify(message.instance);
                    if (error)
                        return "instance." + error;
                }
                if (message.path != null && message.hasOwnProperty("path")) {
                    if (!Array.isArray(message.path))
                        return "path: array expected";
                    for (var i = 0; i < message.path.length; ++i) {
                        var error = $root.metamoto.types.Waypoint.verify(message.path[i]);
                        if (error)
                            return "path." + error;
                    }
                }
                if (message.driverModel != null && message.hasOwnProperty("driverModel")) {
                    var error = $root.metamoto.types.DriverModel.verify(message.driverModel);
                    if (error)
                        return "driverModel." + error;
                }
                if (message.flowId != null && message.hasOwnProperty("flowId"))
                    if (!$util.isInteger(message.flowId))
                        return "flowId: integer expected";
                return null;
            };

            /**
             * Creates a TrafficVehicle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TrafficVehicle} TrafficVehicle
             */
            TrafficVehicle.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TrafficVehicle)
                    return object;
                var message = new $root.metamoto.types.TrafficVehicle();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.instance != null) {
                    if (typeof object.instance !== "object")
                        throw TypeError(".metamoto.types.TrafficVehicle.instance: object expected");
                    message.instance = $root.metamoto.types.VehicleInstance.fromObject(object.instance);
                }
                if (object.path) {
                    if (!Array.isArray(object.path))
                        throw TypeError(".metamoto.types.TrafficVehicle.path: array expected");
                    message.path = [];
                    for (var i = 0; i < object.path.length; ++i) {
                        if (typeof object.path[i] !== "object")
                            throw TypeError(".metamoto.types.TrafficVehicle.path: object expected");
                        message.path[i] = $root.metamoto.types.Waypoint.fromObject(object.path[i]);
                    }
                }
                if (object.driverModel != null) {
                    if (typeof object.driverModel !== "object")
                        throw TypeError(".metamoto.types.TrafficVehicle.driverModel: object expected");
                    message.driverModel = $root.metamoto.types.DriverModel.fromObject(object.driverModel);
                }
                if (object.flowId != null)
                    message.flowId = object.flowId | 0;
                return message;
            };

            /**
             * Creates a plain object from a TrafficVehicle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TrafficVehicle
             * @static
             * @param {metamoto.types.TrafficVehicle} message TrafficVehicle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TrafficVehicle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.path = [];
                if (options.defaults) {
                    object.displayName = "";
                    object.instance = null;
                    object.driverModel = null;
                    object.flowId = 0;
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.instance != null && message.hasOwnProperty("instance"))
                    object.instance = $root.metamoto.types.VehicleInstance.toObject(message.instance, options);
                if (message.path && message.path.length) {
                    object.path = [];
                    for (var j = 0; j < message.path.length; ++j)
                        object.path[j] = $root.metamoto.types.Waypoint.toObject(message.path[j], options);
                }
                if (message.driverModel != null && message.hasOwnProperty("driverModel"))
                    object.driverModel = $root.metamoto.types.DriverModel.toObject(message.driverModel, options);
                if (message.flowId != null && message.hasOwnProperty("flowId"))
                    object.flowId = message.flowId;
                return object;
            };

            /**
             * Converts this TrafficVehicle to JSON.
             * @function toJSON
             * @memberof metamoto.types.TrafficVehicle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TrafficVehicle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrafficVehicle;
        })();

        types.ParkedVehicle = (function() {

            /**
             * Properties of a ParkedVehicle.
             * @memberof metamoto.types
             * @interface IParkedVehicle
             * @property {string|null} [displayName] ParkedVehicle displayName
             * @property {metamoto.types.IVehicleInstance|null} [instance] ParkedVehicle instance
             * @property {metamoto.types.IPose|null} [worldPoint] ParkedVehicle worldPoint
             * @property {metamoto.types.IRoadPoint|null} [roadPoint] ParkedVehicle roadPoint
             */

            /**
             * Constructs a new ParkedVehicle.
             * @memberof metamoto.types
             * @classdesc Represents a ParkedVehicle.
             * @implements IParkedVehicle
             * @constructor
             * @param {metamoto.types.IParkedVehicle=} [properties] Properties to set
             */
            function ParkedVehicle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParkedVehicle displayName.
             * @member {string} displayName
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             */
            ParkedVehicle.prototype.displayName = "";

            /**
             * ParkedVehicle instance.
             * @member {metamoto.types.IVehicleInstance|null|undefined} instance
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             */
            ParkedVehicle.prototype.instance = null;

            /**
             * ParkedVehicle worldPoint.
             * @member {metamoto.types.IPose|null|undefined} worldPoint
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             */
            ParkedVehicle.prototype.worldPoint = null;

            /**
             * ParkedVehicle roadPoint.
             * @member {metamoto.types.IRoadPoint|null|undefined} roadPoint
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             */
            ParkedVehicle.prototype.roadPoint = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ParkedVehicle pointOneof.
             * @member {"worldPoint"|"roadPoint"|undefined} pointOneof
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             */
            Object.defineProperty(ParkedVehicle.prototype, "pointOneof", {
                get: $util.oneOfGetter($oneOfFields = ["worldPoint", "roadPoint"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ParkedVehicle instance using the specified properties.
             * @function create
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {metamoto.types.IParkedVehicle=} [properties] Properties to set
             * @returns {metamoto.types.ParkedVehicle} ParkedVehicle instance
             */
            ParkedVehicle.create = function create(properties) {
                return new ParkedVehicle(properties);
            };

            /**
             * Encodes the specified ParkedVehicle message. Does not implicitly {@link metamoto.types.ParkedVehicle.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {metamoto.types.IParkedVehicle} message ParkedVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParkedVehicle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.instance != null && message.hasOwnProperty("instance"))
                    $root.metamoto.types.VehicleInstance.encode(message.instance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint"))
                    $root.metamoto.types.Pose.encode(message.worldPoint, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint"))
                    $root.metamoto.types.RoadPoint.encode(message.roadPoint, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ParkedVehicle message, length delimited. Does not implicitly {@link metamoto.types.ParkedVehicle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {metamoto.types.IParkedVehicle} message ParkedVehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParkedVehicle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ParkedVehicle message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.ParkedVehicle} ParkedVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParkedVehicle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.ParkedVehicle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 2:
                        message.instance = $root.metamoto.types.VehicleInstance.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.worldPoint = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.roadPoint = $root.metamoto.types.RoadPoint.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ParkedVehicle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.ParkedVehicle} ParkedVehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParkedVehicle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ParkedVehicle message.
             * @function verify
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParkedVehicle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.instance != null && message.hasOwnProperty("instance")) {
                    var error = $root.metamoto.types.VehicleInstance.verify(message.instance);
                    if (error)
                        return "instance." + error;
                }
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint")) {
                    properties.pointOneof = 1;
                    {
                        var error = $root.metamoto.types.Pose.verify(message.worldPoint);
                        if (error)
                            return "worldPoint." + error;
                    }
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    if (properties.pointOneof === 1)
                        return "pointOneof: multiple values";
                    properties.pointOneof = 1;
                    {
                        var error = $root.metamoto.types.RoadPoint.verify(message.roadPoint);
                        if (error)
                            return "roadPoint." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ParkedVehicle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.ParkedVehicle} ParkedVehicle
             */
            ParkedVehicle.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.ParkedVehicle)
                    return object;
                var message = new $root.metamoto.types.ParkedVehicle();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.instance != null) {
                    if (typeof object.instance !== "object")
                        throw TypeError(".metamoto.types.ParkedVehicle.instance: object expected");
                    message.instance = $root.metamoto.types.VehicleInstance.fromObject(object.instance);
                }
                if (object.worldPoint != null) {
                    if (typeof object.worldPoint !== "object")
                        throw TypeError(".metamoto.types.ParkedVehicle.worldPoint: object expected");
                    message.worldPoint = $root.metamoto.types.Pose.fromObject(object.worldPoint);
                }
                if (object.roadPoint != null) {
                    if (typeof object.roadPoint !== "object")
                        throw TypeError(".metamoto.types.ParkedVehicle.roadPoint: object expected");
                    message.roadPoint = $root.metamoto.types.RoadPoint.fromObject(object.roadPoint);
                }
                return message;
            };

            /**
             * Creates a plain object from a ParkedVehicle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.ParkedVehicle
             * @static
             * @param {metamoto.types.ParkedVehicle} message ParkedVehicle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParkedVehicle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayName = "";
                    object.instance = null;
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.instance != null && message.hasOwnProperty("instance"))
                    object.instance = $root.metamoto.types.VehicleInstance.toObject(message.instance, options);
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint")) {
                    object.worldPoint = $root.metamoto.types.Pose.toObject(message.worldPoint, options);
                    if (options.oneofs)
                        object.pointOneof = "worldPoint";
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    object.roadPoint = $root.metamoto.types.RoadPoint.toObject(message.roadPoint, options);
                    if (options.oneofs)
                        object.pointOneof = "roadPoint";
                }
                return object;
            };

            /**
             * Converts this ParkedVehicle to JSON.
             * @function toJSON
             * @memberof metamoto.types.ParkedVehicle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParkedVehicle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ParkedVehicle;
        })();

        types.PedestrianConfiguration = (function() {

            /**
             * Properties of a PedestrianConfiguration.
             * @memberof metamoto.types
             * @interface IPedestrianConfiguration
             * @property {string|null} [displayName] PedestrianConfiguration displayName
             * @property {string|null} [name] PedestrianConfiguration name
             * @property {metamoto.types.Pedestrian.Type|null} [type] PedestrianConfiguration type
             * @property {Array.<metamoto.types.PedestrianConfiguration.IPathPoint>|null} [path] PedestrianConfiguration path
             * @property {boolean|null} [randomPath] PedestrianConfiguration randomPath
             */

            /**
             * Constructs a new PedestrianConfiguration.
             * @memberof metamoto.types
             * @classdesc Represents a PedestrianConfiguration.
             * @implements IPedestrianConfiguration
             * @constructor
             * @param {metamoto.types.IPedestrianConfiguration=} [properties] Properties to set
             */
            function PedestrianConfiguration(properties) {
                this.path = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PedestrianConfiguration displayName.
             * @member {string} displayName
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            PedestrianConfiguration.prototype.displayName = "";

            /**
             * PedestrianConfiguration name.
             * @member {string} name
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            PedestrianConfiguration.prototype.name = "";

            /**
             * PedestrianConfiguration type.
             * @member {metamoto.types.Pedestrian.Type} type
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            PedestrianConfiguration.prototype.type = 0;

            /**
             * PedestrianConfiguration path.
             * @member {Array.<metamoto.types.PedestrianConfiguration.IPathPoint>} path
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            PedestrianConfiguration.prototype.path = $util.emptyArray;

            /**
             * PedestrianConfiguration randomPath.
             * @member {boolean} randomPath
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            PedestrianConfiguration.prototype.randomPath = false;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PedestrianConfiguration instanceOneof.
             * @member {"name"|"type"|undefined} instanceOneof
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             */
            Object.defineProperty(PedestrianConfiguration.prototype, "instanceOneof", {
                get: $util.oneOfGetter($oneOfFields = ["name", "type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PedestrianConfiguration instance using the specified properties.
             * @function create
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {metamoto.types.IPedestrianConfiguration=} [properties] Properties to set
             * @returns {metamoto.types.PedestrianConfiguration} PedestrianConfiguration instance
             */
            PedestrianConfiguration.create = function create(properties) {
                return new PedestrianConfiguration(properties);
            };

            /**
             * Encodes the specified PedestrianConfiguration message. Does not implicitly {@link metamoto.types.PedestrianConfiguration.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {metamoto.types.IPedestrianConfiguration} message PedestrianConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.path != null && message.path.length)
                    for (var i = 0; i < message.path.length; ++i)
                        $root.metamoto.types.PedestrianConfiguration.PathPoint.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.randomPath);
                return writer;
            };

            /**
             * Encodes the specified PedestrianConfiguration message, length delimited. Does not implicitly {@link metamoto.types.PedestrianConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {metamoto.types.IPedestrianConfiguration} message PedestrianConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PedestrianConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.PedestrianConfiguration} PedestrianConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PedestrianConfiguration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push($root.metamoto.types.PedestrianConfiguration.PathPoint.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.randomPath = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PedestrianConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.PedestrianConfiguration} PedestrianConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PedestrianConfiguration message.
             * @function verify
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PedestrianConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties.instanceOneof = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    if (properties.instanceOneof === 1)
                        return "instanceOneof: multiple values";
                    properties.instanceOneof = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                }
                if (message.path != null && message.hasOwnProperty("path")) {
                    if (!Array.isArray(message.path))
                        return "path: array expected";
                    for (var i = 0; i < message.path.length; ++i) {
                        var error = $root.metamoto.types.PedestrianConfiguration.PathPoint.verify(message.path[i]);
                        if (error)
                            return "path." + error;
                    }
                }
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    if (typeof message.randomPath !== "boolean")
                        return "randomPath: boolean expected";
                return null;
            };

            /**
             * Creates a PedestrianConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.PedestrianConfiguration} PedestrianConfiguration
             */
            PedestrianConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.PedestrianConfiguration)
                    return object;
                var message = new $root.metamoto.types.PedestrianConfiguration();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "ADULT":
                case 2:
                    message.type = 2;
                    break;
                case "CHILD":
                case 3:
                    message.type = 3;
                    break;
                case "ANIMAL":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.path) {
                    if (!Array.isArray(object.path))
                        throw TypeError(".metamoto.types.PedestrianConfiguration.path: array expected");
                    message.path = [];
                    for (var i = 0; i < object.path.length; ++i) {
                        if (typeof object.path[i] !== "object")
                            throw TypeError(".metamoto.types.PedestrianConfiguration.path: object expected");
                        message.path[i] = $root.metamoto.types.PedestrianConfiguration.PathPoint.fromObject(object.path[i]);
                    }
                }
                if (object.randomPath != null)
                    message.randomPath = Boolean(object.randomPath);
                return message;
            };

            /**
             * Creates a plain object from a PedestrianConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.PedestrianConfiguration
             * @static
             * @param {metamoto.types.PedestrianConfiguration} message PedestrianConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PedestrianConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.path = [];
                if (options.defaults) {
                    object.displayName = "";
                    object.randomPath = false;
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object.instanceOneof = "name";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.metamoto.types.Pedestrian.Type[message.type] : message.type;
                    if (options.oneofs)
                        object.instanceOneof = "type";
                }
                if (message.path && message.path.length) {
                    object.path = [];
                    for (var j = 0; j < message.path.length; ++j)
                        object.path[j] = $root.metamoto.types.PedestrianConfiguration.PathPoint.toObject(message.path[j], options);
                }
                if (message.randomPath != null && message.hasOwnProperty("randomPath"))
                    object.randomPath = message.randomPath;
                return object;
            };

            /**
             * Converts this PedestrianConfiguration to JSON.
             * @function toJSON
             * @memberof metamoto.types.PedestrianConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PedestrianConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * State enum.
             * @name metamoto.types.PedestrianConfiguration.State
             * @enum {string}
             * @property {number} STATE_UNKNOWN=0 STATE_UNKNOWN value
             * @property {number} STATE_OTHER=1 STATE_OTHER value
             * @property {number} IDLE=2 IDLE value
             * @property {number} WALK=3 WALK value
             * @property {number} RUN=4 RUN value
             * @property {number} RUN_IN_PLACE=5 RUN_IN_PLACE value
             */
            PedestrianConfiguration.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "STATE_OTHER"] = 1;
                values[valuesById[2] = "IDLE"] = 2;
                values[valuesById[3] = "WALK"] = 3;
                values[valuesById[4] = "RUN"] = 4;
                values[valuesById[5] = "RUN_IN_PLACE"] = 5;
                return values;
            })();

            /**
             * PathingBehaviour enum.
             * @name metamoto.types.PedestrianConfiguration.PathingBehaviour
             * @enum {string}
             * @property {number} STANDARD=0 STANDARD value
             * @property {number} UNCONSTRAINED=1 UNCONSTRAINED value
             */
            PedestrianConfiguration.PathingBehaviour = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STANDARD"] = 0;
                values[valuesById[1] = "UNCONSTRAINED"] = 1;
                return values;
            })();

            PedestrianConfiguration.PathPoint = (function() {

                /**
                 * Properties of a PathPoint.
                 * @memberof metamoto.types.PedestrianConfiguration
                 * @interface IPathPoint
                 * @property {metamoto.types.PedestrianConfiguration.State|null} [state] PathPoint state
                 * @property {number|null} [stateVariant] PathPoint stateVariant
                 * @property {metamoto.types.IVector3|null} [targetPoint] PathPoint targetPoint
                 * @property {number|null} [waitTime] PathPoint waitTime
                 * @property {metamoto.types.PedestrianConfiguration.PathingBehaviour|null} [pathingBehaviour] PathPoint pathingBehaviour
                 */

                /**
                 * Constructs a new PathPoint.
                 * @memberof metamoto.types.PedestrianConfiguration
                 * @classdesc Represents a PathPoint.
                 * @implements IPathPoint
                 * @constructor
                 * @param {metamoto.types.PedestrianConfiguration.IPathPoint=} [properties] Properties to set
                 */
                function PathPoint(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PathPoint state.
                 * @member {metamoto.types.PedestrianConfiguration.State} state
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 */
                PathPoint.prototype.state = 0;

                /**
                 * PathPoint stateVariant.
                 * @member {number} stateVariant
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 */
                PathPoint.prototype.stateVariant = 0;

                /**
                 * PathPoint targetPoint.
                 * @member {metamoto.types.IVector3|null|undefined} targetPoint
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 */
                PathPoint.prototype.targetPoint = null;

                /**
                 * PathPoint waitTime.
                 * @member {number} waitTime
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 */
                PathPoint.prototype.waitTime = 0;

                /**
                 * PathPoint pathingBehaviour.
                 * @member {metamoto.types.PedestrianConfiguration.PathingBehaviour} pathingBehaviour
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 */
                PathPoint.prototype.pathingBehaviour = 0;

                /**
                 * Creates a new PathPoint instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {metamoto.types.PedestrianConfiguration.IPathPoint=} [properties] Properties to set
                 * @returns {metamoto.types.PedestrianConfiguration.PathPoint} PathPoint instance
                 */
                PathPoint.create = function create(properties) {
                    return new PathPoint(properties);
                };

                /**
                 * Encodes the specified PathPoint message. Does not implicitly {@link metamoto.types.PedestrianConfiguration.PathPoint.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {metamoto.types.PedestrianConfiguration.IPathPoint} message PathPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PathPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.stateVariant != null && message.hasOwnProperty("stateVariant"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stateVariant);
                    if (message.targetPoint != null && message.hasOwnProperty("targetPoint"))
                        $root.metamoto.types.Vector3.encode(message.targetPoint, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.waitTime);
                    if (message.pathingBehaviour != null && message.hasOwnProperty("pathingBehaviour"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pathingBehaviour);
                    return writer;
                };

                /**
                 * Encodes the specified PathPoint message, length delimited. Does not implicitly {@link metamoto.types.PedestrianConfiguration.PathPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {metamoto.types.PedestrianConfiguration.IPathPoint} message PathPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PathPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PathPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.PedestrianConfiguration.PathPoint} PathPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PathPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.PedestrianConfiguration.PathPoint();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.int32();
                            break;
                        case 2:
                            message.stateVariant = reader.uint32();
                            break;
                        case 3:
                            message.targetPoint = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.waitTime = reader.float();
                            break;
                        case 5:
                            message.pathingBehaviour = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PathPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.PedestrianConfiguration.PathPoint} PathPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PathPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PathPoint message.
                 * @function verify
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PathPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.stateVariant != null && message.hasOwnProperty("stateVariant"))
                        if (!$util.isInteger(message.stateVariant))
                            return "stateVariant: integer expected";
                    if (message.targetPoint != null && message.hasOwnProperty("targetPoint")) {
                        var error = $root.metamoto.types.Vector3.verify(message.targetPoint);
                        if (error)
                            return "targetPoint." + error;
                    }
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (typeof message.waitTime !== "number")
                            return "waitTime: number expected";
                    if (message.pathingBehaviour != null && message.hasOwnProperty("pathingBehaviour"))
                        switch (message.pathingBehaviour) {
                        default:
                            return "pathingBehaviour: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a PathPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.PedestrianConfiguration.PathPoint} PathPoint
                 */
                PathPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.PedestrianConfiguration.PathPoint)
                        return object;
                    var message = new $root.metamoto.types.PedestrianConfiguration.PathPoint();
                    switch (object.state) {
                    case "STATE_UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "STATE_OTHER":
                    case 1:
                        message.state = 1;
                        break;
                    case "IDLE":
                    case 2:
                        message.state = 2;
                        break;
                    case "WALK":
                    case 3:
                        message.state = 3;
                        break;
                    case "RUN":
                    case 4:
                        message.state = 4;
                        break;
                    case "RUN_IN_PLACE":
                    case 5:
                        message.state = 5;
                        break;
                    }
                    if (object.stateVariant != null)
                        message.stateVariant = object.stateVariant >>> 0;
                    if (object.targetPoint != null) {
                        if (typeof object.targetPoint !== "object")
                            throw TypeError(".metamoto.types.PedestrianConfiguration.PathPoint.targetPoint: object expected");
                        message.targetPoint = $root.metamoto.types.Vector3.fromObject(object.targetPoint);
                    }
                    if (object.waitTime != null)
                        message.waitTime = Number(object.waitTime);
                    switch (object.pathingBehaviour) {
                    case "STANDARD":
                    case 0:
                        message.pathingBehaviour = 0;
                        break;
                    case "UNCONSTRAINED":
                    case 1:
                        message.pathingBehaviour = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PathPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @static
                 * @param {metamoto.types.PedestrianConfiguration.PathPoint} message PathPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PathPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.state = options.enums === String ? "STATE_UNKNOWN" : 0;
                        object.stateVariant = 0;
                        object.targetPoint = null;
                        object.waitTime = 0;
                        object.pathingBehaviour = options.enums === String ? "STANDARD" : 0;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.metamoto.types.PedestrianConfiguration.State[message.state] : message.state;
                    if (message.stateVariant != null && message.hasOwnProperty("stateVariant"))
                        object.stateVariant = message.stateVariant;
                    if (message.targetPoint != null && message.hasOwnProperty("targetPoint"))
                        object.targetPoint = $root.metamoto.types.Vector3.toObject(message.targetPoint, options);
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        object.waitTime = options.json && !isFinite(message.waitTime) ? String(message.waitTime) : message.waitTime;
                    if (message.pathingBehaviour != null && message.hasOwnProperty("pathingBehaviour"))
                        object.pathingBehaviour = options.enums === String ? $root.metamoto.types.PedestrianConfiguration.PathingBehaviour[message.pathingBehaviour] : message.pathingBehaviour;
                    return object;
                };

                /**
                 * Converts this PathPoint to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.PedestrianConfiguration.PathPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PathPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PathPoint;
            })();

            return PedestrianConfiguration;
        })();

        types.Event = (function() {

            /**
             * Properties of an Event.
             * @memberof metamoto.types
             * @interface IEvent
             * @property {metamoto.types.Event.ObjectType|null} [objectType] Event objectType
             * @property {metamoto.types.Event.Action|null} [action] Event action
             * @property {number|null} [time] Event time
             * @property {metamoto.types.Event.IProximityTrigger|null} [trigger] Event trigger
             * @property {string|null} [id] Event id
             * @property {string|null} [secondaryId] Event secondaryId
             * @property {Array.<string>|null} [payloadString] Event payloadString
             * @property {Array.<number>|null} [payloadFloat] Event payloadFloat
             * @property {Array.<metamoto.types.IWaypoint>|null} [waypoints] Event waypoints
             */

            /**
             * Constructs a new Event.
             * @memberof metamoto.types
             * @classdesc Represents an Event.
             * @implements IEvent
             * @constructor
             * @param {metamoto.types.IEvent=} [properties] Properties to set
             */
            function Event(properties) {
                this.payloadString = [];
                this.payloadFloat = [];
                this.waypoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Event objectType.
             * @member {metamoto.types.Event.ObjectType} objectType
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.objectType = 0;

            /**
             * Event action.
             * @member {metamoto.types.Event.Action} action
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.action = 0;

            /**
             * Event time.
             * @member {number} time
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.time = 0;

            /**
             * Event trigger.
             * @member {metamoto.types.Event.IProximityTrigger|null|undefined} trigger
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.trigger = null;

            /**
             * Event id.
             * @member {string} id
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.id = "";

            /**
             * Event secondaryId.
             * @member {string} secondaryId
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.secondaryId = "";

            /**
             * Event payloadString.
             * @member {Array.<string>} payloadString
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.payloadString = $util.emptyArray;

            /**
             * Event payloadFloat.
             * @member {Array.<number>} payloadFloat
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.payloadFloat = $util.emptyArray;

            /**
             * Event waypoints.
             * @member {Array.<metamoto.types.IWaypoint>} waypoints
             * @memberof metamoto.types.Event
             * @instance
             */
            Event.prototype.waypoints = $util.emptyArray;

            /**
             * Creates a new Event instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Event
             * @static
             * @param {metamoto.types.IEvent=} [properties] Properties to set
             * @returns {metamoto.types.Event} Event instance
             */
            Event.create = function create(properties) {
                return new Event(properties);
            };

            /**
             * Encodes the specified Event message. Does not implicitly {@link metamoto.types.Event.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Event
             * @static
             * @param {metamoto.types.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.objectType);
                if (message.action != null && message.hasOwnProperty("action"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
                if (message.time != null && message.hasOwnProperty("time"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.time);
                if (message.trigger != null && message.hasOwnProperty("trigger"))
                    $root.metamoto.types.Event.ProximityTrigger.encode(message.trigger, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.secondaryId);
                if (message.payloadString != null && message.payloadString.length)
                    for (var i = 0; i < message.payloadString.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.payloadString[i]);
                if (message.payloadFloat != null && message.payloadFloat.length) {
                    writer.uint32(/* id 8, wireType 2 =*/66).fork();
                    for (var i = 0; i < message.payloadFloat.length; ++i)
                        writer.float(message.payloadFloat[i]);
                    writer.ldelim();
                }
                if (message.waypoints != null && message.waypoints.length)
                    for (var i = 0; i < message.waypoints.length; ++i)
                        $root.metamoto.types.Waypoint.encode(message.waypoints[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Event message, length delimited. Does not implicitly {@link metamoto.types.Event.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Event
             * @static
             * @param {metamoto.types.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Event message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Event();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.objectType = reader.int32();
                        break;
                    case 2:
                        message.action = reader.int32();
                        break;
                    case 3:
                        message.time = reader.double();
                        break;
                    case 4:
                        message.trigger = $root.metamoto.types.Event.ProximityTrigger.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.id = reader.string();
                        break;
                    case 6:
                        message.secondaryId = reader.string();
                        break;
                    case 7:
                        if (!(message.payloadString && message.payloadString.length))
                            message.payloadString = [];
                        message.payloadString.push(reader.string());
                        break;
                    case 8:
                        if (!(message.payloadFloat && message.payloadFloat.length))
                            message.payloadFloat = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.payloadFloat.push(reader.float());
                        } else
                            message.payloadFloat.push(reader.float());
                        break;
                    case 9:
                        if (!(message.waypoints && message.waypoints.length))
                            message.waypoints = [];
                        message.waypoints.push($root.metamoto.types.Waypoint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Event message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Event message.
             * @function verify
             * @memberof metamoto.types.Event
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    switch (message.objectType) {
                    default:
                        return "objectType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                if (message.trigger != null && message.hasOwnProperty("trigger")) {
                    var error = $root.metamoto.types.Event.ProximityTrigger.verify(message.trigger);
                    if (error)
                        return "trigger." + error;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    if (!$util.isString(message.secondaryId))
                        return "secondaryId: string expected";
                if (message.payloadString != null && message.hasOwnProperty("payloadString")) {
                    if (!Array.isArray(message.payloadString))
                        return "payloadString: array expected";
                    for (var i = 0; i < message.payloadString.length; ++i)
                        if (!$util.isString(message.payloadString[i]))
                            return "payloadString: string[] expected";
                }
                if (message.payloadFloat != null && message.hasOwnProperty("payloadFloat")) {
                    if (!Array.isArray(message.payloadFloat))
                        return "payloadFloat: array expected";
                    for (var i = 0; i < message.payloadFloat.length; ++i)
                        if (typeof message.payloadFloat[i] !== "number")
                            return "payloadFloat: number[] expected";
                }
                if (message.waypoints != null && message.hasOwnProperty("waypoints")) {
                    if (!Array.isArray(message.waypoints))
                        return "waypoints: array expected";
                    for (var i = 0; i < message.waypoints.length; ++i) {
                        var error = $root.metamoto.types.Waypoint.verify(message.waypoints[i]);
                        if (error)
                            return "waypoints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Event message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Event
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Event} Event
             */
            Event.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Event)
                    return object;
                var message = new $root.metamoto.types.Event();
                switch (object.objectType) {
                case "OBJECT_OTHER":
                case 0:
                    message.objectType = 0;
                    break;
                case "SENSOR":
                case 1:
                    message.objectType = 1;
                    break;
                case "CONTROLLER":
                case 2:
                    message.objectType = 2;
                    break;
                case "EGO_VEHICLE":
                case 3:
                    message.objectType = 3;
                    break;
                case "TRAFFIC_VEHICLE":
                case 4:
                    message.objectType = 4;
                    break;
                case "TRAFFIC_FLOW":
                case 5:
                    message.objectType = 5;
                    break;
                case "PEDESTRIAN":
                case 6:
                    message.objectType = 6;
                    break;
                case "TRAFFIC_LIGHT":
                case 7:
                    message.objectType = 7;
                    break;
                case "ENVIRONMENT":
                case 8:
                    message.objectType = 8;
                    break;
                }
                switch (object.action) {
                case "ACTION_OTHER":
                case 0:
                    message.action = 0;
                    break;
                case "ACTIVATE":
                case 1:
                    message.action = 1;
                    break;
                case "DEACTIVATE":
                case 2:
                    message.action = 2;
                    break;
                case "CREATE":
                case 3:
                    message.action = 3;
                    break;
                case "REMOVE":
                case 4:
                    message.action = 4;
                    break;
                case "MODIFY":
                case 5:
                    message.action = 5;
                    break;
                case "SEND":
                case 6:
                    message.action = 6;
                    break;
                }
                if (object.time != null)
                    message.time = Number(object.time);
                if (object.trigger != null) {
                    if (typeof object.trigger !== "object")
                        throw TypeError(".metamoto.types.Event.trigger: object expected");
                    message.trigger = $root.metamoto.types.Event.ProximityTrigger.fromObject(object.trigger);
                }
                if (object.id != null)
                    message.id = String(object.id);
                if (object.secondaryId != null)
                    message.secondaryId = String(object.secondaryId);
                if (object.payloadString) {
                    if (!Array.isArray(object.payloadString))
                        throw TypeError(".metamoto.types.Event.payloadString: array expected");
                    message.payloadString = [];
                    for (var i = 0; i < object.payloadString.length; ++i)
                        message.payloadString[i] = String(object.payloadString[i]);
                }
                if (object.payloadFloat) {
                    if (!Array.isArray(object.payloadFloat))
                        throw TypeError(".metamoto.types.Event.payloadFloat: array expected");
                    message.payloadFloat = [];
                    for (var i = 0; i < object.payloadFloat.length; ++i)
                        message.payloadFloat[i] = Number(object.payloadFloat[i]);
                }
                if (object.waypoints) {
                    if (!Array.isArray(object.waypoints))
                        throw TypeError(".metamoto.types.Event.waypoints: array expected");
                    message.waypoints = [];
                    for (var i = 0; i < object.waypoints.length; ++i) {
                        if (typeof object.waypoints[i] !== "object")
                            throw TypeError(".metamoto.types.Event.waypoints: object expected");
                        message.waypoints[i] = $root.metamoto.types.Waypoint.fromObject(object.waypoints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Event message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Event
             * @static
             * @param {metamoto.types.Event} message Event
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Event.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.payloadString = [];
                    object.payloadFloat = [];
                    object.waypoints = [];
                }
                if (options.defaults) {
                    object.objectType = options.enums === String ? "OBJECT_OTHER" : 0;
                    object.action = options.enums === String ? "ACTION_OTHER" : 0;
                    object.time = 0;
                    object.trigger = null;
                    object.id = "";
                    object.secondaryId = "";
                }
                if (message.objectType != null && message.hasOwnProperty("objectType"))
                    object.objectType = options.enums === String ? $root.metamoto.types.Event.ObjectType[message.objectType] : message.objectType;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.metamoto.types.Event.Action[message.action] : message.action;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                if (message.trigger != null && message.hasOwnProperty("trigger"))
                    object.trigger = $root.metamoto.types.Event.ProximityTrigger.toObject(message.trigger, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    object.secondaryId = message.secondaryId;
                if (message.payloadString && message.payloadString.length) {
                    object.payloadString = [];
                    for (var j = 0; j < message.payloadString.length; ++j)
                        object.payloadString[j] = message.payloadString[j];
                }
                if (message.payloadFloat && message.payloadFloat.length) {
                    object.payloadFloat = [];
                    for (var j = 0; j < message.payloadFloat.length; ++j)
                        object.payloadFloat[j] = options.json && !isFinite(message.payloadFloat[j]) ? String(message.payloadFloat[j]) : message.payloadFloat[j];
                }
                if (message.waypoints && message.waypoints.length) {
                    object.waypoints = [];
                    for (var j = 0; j < message.waypoints.length; ++j)
                        object.waypoints[j] = $root.metamoto.types.Waypoint.toObject(message.waypoints[j], options);
                }
                return object;
            };

            /**
             * Converts this Event to JSON.
             * @function toJSON
             * @memberof metamoto.types.Event
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ObjectType enum.
             * @name metamoto.types.Event.ObjectType
             * @enum {string}
             * @property {number} OBJECT_OTHER=0 OBJECT_OTHER value
             * @property {number} SENSOR=1 SENSOR value
             * @property {number} CONTROLLER=2 CONTROLLER value
             * @property {number} EGO_VEHICLE=3 EGO_VEHICLE value
             * @property {number} TRAFFIC_VEHICLE=4 TRAFFIC_VEHICLE value
             * @property {number} TRAFFIC_FLOW=5 TRAFFIC_FLOW value
             * @property {number} PEDESTRIAN=6 PEDESTRIAN value
             * @property {number} TRAFFIC_LIGHT=7 TRAFFIC_LIGHT value
             * @property {number} ENVIRONMENT=8 ENVIRONMENT value
             */
            Event.ObjectType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OBJECT_OTHER"] = 0;
                values[valuesById[1] = "SENSOR"] = 1;
                values[valuesById[2] = "CONTROLLER"] = 2;
                values[valuesById[3] = "EGO_VEHICLE"] = 3;
                values[valuesById[4] = "TRAFFIC_VEHICLE"] = 4;
                values[valuesById[5] = "TRAFFIC_FLOW"] = 5;
                values[valuesById[6] = "PEDESTRIAN"] = 6;
                values[valuesById[7] = "TRAFFIC_LIGHT"] = 7;
                values[valuesById[8] = "ENVIRONMENT"] = 8;
                return values;
            })();

            /**
             * Action enum.
             * @name metamoto.types.Event.Action
             * @enum {string}
             * @property {number} ACTION_OTHER=0 ACTION_OTHER value
             * @property {number} ACTIVATE=1 ACTIVATE value
             * @property {number} DEACTIVATE=2 DEACTIVATE value
             * @property {number} CREATE=3 CREATE value
             * @property {number} REMOVE=4 REMOVE value
             * @property {number} MODIFY=5 MODIFY value
             * @property {number} SEND=6 SEND value
             */
            Event.Action = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ACTION_OTHER"] = 0;
                values[valuesById[1] = "ACTIVATE"] = 1;
                values[valuesById[2] = "DEACTIVATE"] = 2;
                values[valuesById[3] = "CREATE"] = 3;
                values[valuesById[4] = "REMOVE"] = 4;
                values[valuesById[5] = "MODIFY"] = 5;
                values[valuesById[6] = "SEND"] = 6;
                return values;
            })();

            Event.ProximityTrigger = (function() {

                /**
                 * Properties of a ProximityTrigger.
                 * @memberof metamoto.types.Event
                 * @interface IProximityTrigger
                 * @property {metamoto.types.IVector3|null} [location] ProximityTrigger location
                 * @property {number|null} [radius] ProximityTrigger radius
                 * @property {number|null} [egoVehicleIndex] ProximityTrigger egoVehicleIndex
                 */

                /**
                 * Constructs a new ProximityTrigger.
                 * @memberof metamoto.types.Event
                 * @classdesc Represents a ProximityTrigger.
                 * @implements IProximityTrigger
                 * @constructor
                 * @param {metamoto.types.Event.IProximityTrigger=} [properties] Properties to set
                 */
                function ProximityTrigger(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProximityTrigger location.
                 * @member {metamoto.types.IVector3|null|undefined} location
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @instance
                 */
                ProximityTrigger.prototype.location = null;

                /**
                 * ProximityTrigger radius.
                 * @member {number} radius
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @instance
                 */
                ProximityTrigger.prototype.radius = 0;

                /**
                 * ProximityTrigger egoVehicleIndex.
                 * @member {number} egoVehicleIndex
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @instance
                 */
                ProximityTrigger.prototype.egoVehicleIndex = 0;

                /**
                 * Creates a new ProximityTrigger instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {metamoto.types.Event.IProximityTrigger=} [properties] Properties to set
                 * @returns {metamoto.types.Event.ProximityTrigger} ProximityTrigger instance
                 */
                ProximityTrigger.create = function create(properties) {
                    return new ProximityTrigger(properties);
                };

                /**
                 * Encodes the specified ProximityTrigger message. Does not implicitly {@link metamoto.types.Event.ProximityTrigger.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {metamoto.types.Event.IProximityTrigger} message ProximityTrigger message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProximityTrigger.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.hasOwnProperty("location"))
                        $root.metamoto.types.Vector3.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.radius);
                    if (message.egoVehicleIndex != null && message.hasOwnProperty("egoVehicleIndex"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.egoVehicleIndex);
                    return writer;
                };

                /**
                 * Encodes the specified ProximityTrigger message, length delimited. Does not implicitly {@link metamoto.types.Event.ProximityTrigger.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {metamoto.types.Event.IProximityTrigger} message ProximityTrigger message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProximityTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProximityTrigger message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.Event.ProximityTrigger} ProximityTrigger
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProximityTrigger.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Event.ProximityTrigger();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.location = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.radius = reader.float();
                            break;
                        case 3:
                            message.egoVehicleIndex = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProximityTrigger message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.Event.ProximityTrigger} ProximityTrigger
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProximityTrigger.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProximityTrigger message.
                 * @function verify
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProximityTrigger.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        var error = $root.metamoto.types.Vector3.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        if (typeof message.radius !== "number")
                            return "radius: number expected";
                    if (message.egoVehicleIndex != null && message.hasOwnProperty("egoVehicleIndex"))
                        if (!$util.isInteger(message.egoVehicleIndex))
                            return "egoVehicleIndex: integer expected";
                    return null;
                };

                /**
                 * Creates a ProximityTrigger message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.Event.ProximityTrigger} ProximityTrigger
                 */
                ProximityTrigger.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.Event.ProximityTrigger)
                        return object;
                    var message = new $root.metamoto.types.Event.ProximityTrigger();
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".metamoto.types.Event.ProximityTrigger.location: object expected");
                        message.location = $root.metamoto.types.Vector3.fromObject(object.location);
                    }
                    if (object.radius != null)
                        message.radius = Number(object.radius);
                    if (object.egoVehicleIndex != null)
                        message.egoVehicleIndex = object.egoVehicleIndex | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ProximityTrigger message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @static
                 * @param {metamoto.types.Event.ProximityTrigger} message ProximityTrigger
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProximityTrigger.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.location = null;
                        object.radius = 0;
                        object.egoVehicleIndex = 0;
                    }
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.metamoto.types.Vector3.toObject(message.location, options);
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
                    if (message.egoVehicleIndex != null && message.hasOwnProperty("egoVehicleIndex"))
                        object.egoVehicleIndex = message.egoVehicleIndex;
                    return object;
                };

                /**
                 * Converts this ProximityTrigger to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.Event.ProximityTrigger
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProximityTrigger.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProximityTrigger;
            })();

            return Event;
        })();

        types.SceneImport = (function() {

            /**
             * Properties of a SceneImport.
             * @memberof metamoto.types
             * @interface ISceneImport
             * @property {number|null} [id] SceneImport id
             * @property {metamoto.types.SceneImport.Status|null} [status] SceneImport status
             * @property {string|null} [statusMessage] SceneImport statusMessage
             * @property {string|null} [startTime] SceneImport startTime
             * @property {string|null} [endTime] SceneImport endTime
             * @property {string|null} [startedBy] SceneImport startedBy
             * @property {number|null} [progress] SceneImport progress
             */

            /**
             * Constructs a new SceneImport.
             * @memberof metamoto.types
             * @classdesc Represents a SceneImport.
             * @implements ISceneImport
             * @constructor
             * @param {metamoto.types.ISceneImport=} [properties] Properties to set
             */
            function SceneImport(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SceneImport id.
             * @member {number} id
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.id = 0;

            /**
             * SceneImport status.
             * @member {metamoto.types.SceneImport.Status} status
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.status = 0;

            /**
             * SceneImport statusMessage.
             * @member {string} statusMessage
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.statusMessage = "";

            /**
             * SceneImport startTime.
             * @member {string} startTime
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.startTime = "";

            /**
             * SceneImport endTime.
             * @member {string} endTime
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.endTime = "";

            /**
             * SceneImport startedBy.
             * @member {string} startedBy
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.startedBy = "";

            /**
             * SceneImport progress.
             * @member {number} progress
             * @memberof metamoto.types.SceneImport
             * @instance
             */
            SceneImport.prototype.progress = 0;

            /**
             * Creates a new SceneImport instance using the specified properties.
             * @function create
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {metamoto.types.ISceneImport=} [properties] Properties to set
             * @returns {metamoto.types.SceneImport} SceneImport instance
             */
            SceneImport.create = function create(properties) {
                return new SceneImport(properties);
            };

            /**
             * Encodes the specified SceneImport message. Does not implicitly {@link metamoto.types.SceneImport.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {metamoto.types.ISceneImport} message SceneImport message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SceneImport.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.statusMessage);
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.startTime);
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.startedBy);
                if (message.progress != null && message.hasOwnProperty("progress"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.progress);
                return writer;
            };

            /**
             * Encodes the specified SceneImport message, length delimited. Does not implicitly {@link metamoto.types.SceneImport.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {metamoto.types.ISceneImport} message SceneImport message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SceneImport.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SceneImport message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.SceneImport} SceneImport
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SceneImport.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SceneImport();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    case 3:
                        message.statusMessage = reader.string();
                        break;
                    case 4:
                        message.startTime = reader.string();
                        break;
                    case 5:
                        message.endTime = reader.string();
                        break;
                    case 6:
                        message.startedBy = reader.string();
                        break;
                    case 7:
                        message.progress = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SceneImport message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.SceneImport} SceneImport
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SceneImport.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SceneImport message.
             * @function verify
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SceneImport.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
                    if (!$util.isString(message.statusMessage))
                        return "statusMessage: string expected";
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isString(message.startTime))
                        return "startTime: string expected";
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (!$util.isString(message.endTime))
                        return "endTime: string expected";
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    if (!$util.isString(message.startedBy))
                        return "startedBy: string expected";
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (typeof message.progress !== "number")
                        return "progress: number expected";
                return null;
            };

            /**
             * Creates a SceneImport message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.SceneImport} SceneImport
             */
            SceneImport.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.SceneImport)
                    return object;
                var message = new $root.metamoto.types.SceneImport();
                if (object.id != null)
                    message.id = object.id | 0;
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "QUEUED":
                case 1:
                    message.status = 1;
                    break;
                case "BUILDING":
                case 2:
                    message.status = 2;
                    break;
                case "SUCCEEDED":
                case 3:
                    message.status = 3;
                    break;
                case "FAILED":
                case 4:
                    message.status = 4;
                    break;
                case "CANCELLED":
                case 5:
                    message.status = 5;
                    break;
                }
                if (object.statusMessage != null)
                    message.statusMessage = String(object.statusMessage);
                if (object.startTime != null)
                    message.startTime = String(object.startTime);
                if (object.endTime != null)
                    message.endTime = String(object.endTime);
                if (object.startedBy != null)
                    message.startedBy = String(object.startedBy);
                if (object.progress != null)
                    message.progress = Number(object.progress);
                return message;
            };

            /**
             * Creates a plain object from a SceneImport message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.SceneImport
             * @static
             * @param {metamoto.types.SceneImport} message SceneImport
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SceneImport.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.statusMessage = "";
                    object.startTime = "";
                    object.endTime = "";
                    object.startedBy = "";
                    object.progress = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.metamoto.types.SceneImport.Status[message.status] : message.status;
                if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
                    object.statusMessage = message.statusMessage;
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    object.startTime = message.startTime;
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    object.endTime = message.endTime;
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    object.startedBy = message.startedBy;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
                return object;
            };

            /**
             * Converts this SceneImport to JSON.
             * @function toJSON
             * @memberof metamoto.types.SceneImport
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SceneImport.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Status enum.
             * @name metamoto.types.SceneImport.Status
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} QUEUED=1 QUEUED value
             * @property {number} BUILDING=2 BUILDING value
             * @property {number} SUCCEEDED=3 SUCCEEDED value
             * @property {number} FAILED=4 FAILED value
             * @property {number} CANCELLED=5 CANCELLED value
             */
            SceneImport.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "QUEUED"] = 1;
                values[valuesById[2] = "BUILDING"] = 2;
                values[valuesById[3] = "SUCCEEDED"] = 3;
                values[valuesById[4] = "FAILED"] = 4;
                values[valuesById[5] = "CANCELLED"] = 5;
                return values;
            })();

            return SceneImport;
        })();

        types.Scene = (function() {

            /**
             * Properties of a Scene.
             * @memberof metamoto.types
             * @interface IScene
             * @property {string|null} [id] Scene id
             * @property {string|null} [name] Scene name
             * @property {string|null} [displayName] Scene displayName
             * @property {string|null} [description] Scene description
             * @property {boolean|null} [ready] Scene ready
             * @property {Array.<metamoto.types.ISceneImport>|null} [imports] Scene imports
             */

            /**
             * Constructs a new Scene.
             * @memberof metamoto.types
             * @classdesc Represents a Scene.
             * @implements IScene
             * @constructor
             * @param {metamoto.types.IScene=} [properties] Properties to set
             */
            function Scene(properties) {
                this.imports = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Scene id.
             * @member {string} id
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.id = "";

            /**
             * Scene name.
             * @member {string} name
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.name = "";

            /**
             * Scene displayName.
             * @member {string} displayName
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.displayName = "";

            /**
             * Scene description.
             * @member {string} description
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.description = "";

            /**
             * Scene ready.
             * @member {boolean} ready
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.ready = false;

            /**
             * Scene imports.
             * @member {Array.<metamoto.types.ISceneImport>} imports
             * @memberof metamoto.types.Scene
             * @instance
             */
            Scene.prototype.imports = $util.emptyArray;

            /**
             * Creates a new Scene instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Scene
             * @static
             * @param {metamoto.types.IScene=} [properties] Properties to set
             * @returns {metamoto.types.Scene} Scene instance
             */
            Scene.create = function create(properties) {
                return new Scene(properties);
            };

            /**
             * Encodes the specified Scene message. Does not implicitly {@link metamoto.types.Scene.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Scene
             * @static
             * @param {metamoto.types.IScene} message Scene message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scene.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.displayName);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.ready != null && message.hasOwnProperty("ready"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.ready);
                if (message.imports != null && message.imports.length)
                    for (var i = 0; i < message.imports.length; ++i)
                        $root.metamoto.types.SceneImport.encode(message.imports[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Scene message, length delimited. Does not implicitly {@link metamoto.types.Scene.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Scene
             * @static
             * @param {metamoto.types.IScene} message Scene message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scene.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Scene message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Scene
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Scene} Scene
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scene.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Scene();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.displayName = reader.string();
                        break;
                    case 4:
                        message.description = reader.string();
                        break;
                    case 5:
                        message.ready = reader.bool();
                        break;
                    case 6:
                        if (!(message.imports && message.imports.length))
                            message.imports = [];
                        message.imports.push($root.metamoto.types.SceneImport.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Scene message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Scene
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Scene} Scene
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scene.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Scene message.
             * @function verify
             * @memberof metamoto.types.Scene
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Scene.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.ready != null && message.hasOwnProperty("ready"))
                    if (typeof message.ready !== "boolean")
                        return "ready: boolean expected";
                if (message.imports != null && message.hasOwnProperty("imports")) {
                    if (!Array.isArray(message.imports))
                        return "imports: array expected";
                    for (var i = 0; i < message.imports.length; ++i) {
                        var error = $root.metamoto.types.SceneImport.verify(message.imports[i]);
                        if (error)
                            return "imports." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Scene message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Scene
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Scene} Scene
             */
            Scene.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Scene)
                    return object;
                var message = new $root.metamoto.types.Scene();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.ready != null)
                    message.ready = Boolean(object.ready);
                if (object.imports) {
                    if (!Array.isArray(object.imports))
                        throw TypeError(".metamoto.types.Scene.imports: array expected");
                    message.imports = [];
                    for (var i = 0; i < object.imports.length; ++i) {
                        if (typeof object.imports[i] !== "object")
                            throw TypeError(".metamoto.types.Scene.imports: object expected");
                        message.imports[i] = $root.metamoto.types.SceneImport.fromObject(object.imports[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Scene message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Scene
             * @static
             * @param {metamoto.types.Scene} message Scene
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Scene.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.imports = [];
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.displayName = "";
                    object.description = "";
                    object.ready = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.ready != null && message.hasOwnProperty("ready"))
                    object.ready = message.ready;
                if (message.imports && message.imports.length) {
                    object.imports = [];
                    for (var j = 0; j < message.imports.length; ++j)
                        object.imports[j] = $root.metamoto.types.SceneImport.toObject(message.imports[j], options);
                }
                return object;
            };

            /**
             * Converts this Scene to JSON.
             * @function toJSON
             * @memberof metamoto.types.Scene
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Scene.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Scene;
        })();

        types.ServiceDescription = (function() {

            /**
             * Properties of a ServiceDescription.
             * @memberof metamoto.types
             * @interface IServiceDescription
             * @property {string|null} [name] ServiceDescription name
             * @property {string|null} [uri] ServiceDescription uri
             */

            /**
             * Constructs a new ServiceDescription.
             * @memberof metamoto.types
             * @classdesc Represents a ServiceDescription.
             * @implements IServiceDescription
             * @constructor
             * @param {metamoto.types.IServiceDescription=} [properties] Properties to set
             */
            function ServiceDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescription name.
             * @member {string} name
             * @memberof metamoto.types.ServiceDescription
             * @instance
             */
            ServiceDescription.prototype.name = "";

            /**
             * ServiceDescription uri.
             * @member {string} uri
             * @memberof metamoto.types.ServiceDescription
             * @instance
             */
            ServiceDescription.prototype.uri = "";

            /**
             * Creates a new ServiceDescription instance using the specified properties.
             * @function create
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {metamoto.types.IServiceDescription=} [properties] Properties to set
             * @returns {metamoto.types.ServiceDescription} ServiceDescription instance
             */
            ServiceDescription.create = function create(properties) {
                return new ServiceDescription(properties);
            };

            /**
             * Encodes the specified ServiceDescription message. Does not implicitly {@link metamoto.types.ServiceDescription.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {metamoto.types.IServiceDescription} message ServiceDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                return writer;
            };

            /**
             * Encodes the specified ServiceDescription message, length delimited. Does not implicitly {@link metamoto.types.ServiceDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {metamoto.types.IServiceDescription} message ServiceDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescription message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.ServiceDescription} ServiceDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.ServiceDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.uri = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.ServiceDescription} ServiceDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescription message.
             * @function verify
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.uri != null && message.hasOwnProperty("uri"))
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                return null;
            };

            /**
             * Creates a ServiceDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.ServiceDescription} ServiceDescription
             */
            ServiceDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.ServiceDescription)
                    return object;
                var message = new $root.metamoto.types.ServiceDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.uri != null)
                    message.uri = String(object.uri);
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.ServiceDescription
             * @static
             * @param {metamoto.types.ServiceDescription} message ServiceDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.uri = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.uri != null && message.hasOwnProperty("uri"))
                    object.uri = message.uri;
                return object;
            };

            /**
             * Converts this ServiceDescription to JSON.
             * @function toJSON
             * @memberof metamoto.types.ServiceDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescription;
        })();

        types.Shape = (function() {

            /**
             * Properties of a Shape.
             * @memberof metamoto.types
             * @interface IShape
             * @property {metamoto.types.Shape.Type|null} [type] Shape type
             * @property {Array.<number>|null} [dimensions] Shape dimensions
             */

            /**
             * Constructs a new Shape.
             * @memberof metamoto.types
             * @classdesc Represents a Shape.
             * @implements IShape
             * @constructor
             * @param {metamoto.types.IShape=} [properties] Properties to set
             */
            function Shape(properties) {
                this.dimensions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Shape type.
             * @member {metamoto.types.Shape.Type} type
             * @memberof metamoto.types.Shape
             * @instance
             */
            Shape.prototype.type = 0;

            /**
             * Shape dimensions.
             * @member {Array.<number>} dimensions
             * @memberof metamoto.types.Shape
             * @instance
             */
            Shape.prototype.dimensions = $util.emptyArray;

            /**
             * Creates a new Shape instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Shape
             * @static
             * @param {metamoto.types.IShape=} [properties] Properties to set
             * @returns {metamoto.types.Shape} Shape instance
             */
            Shape.create = function create(properties) {
                return new Shape(properties);
            };

            /**
             * Encodes the specified Shape message. Does not implicitly {@link metamoto.types.Shape.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Shape
             * @static
             * @param {metamoto.types.IShape} message Shape message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Shape.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.dimensions != null && message.dimensions.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.dimensions.length; ++i)
                        writer.float(message.dimensions[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified Shape message, length delimited. Does not implicitly {@link metamoto.types.Shape.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Shape
             * @static
             * @param {metamoto.types.IShape} message Shape message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Shape.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Shape message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Shape
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Shape} Shape
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Shape.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Shape();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        if (!(message.dimensions && message.dimensions.length))
                            message.dimensions = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dimensions.push(reader.float());
                        } else
                            message.dimensions.push(reader.float());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Shape message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Shape
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Shape} Shape
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Shape.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Shape message.
             * @function verify
             * @memberof metamoto.types.Shape
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Shape.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                    if (!Array.isArray(message.dimensions))
                        return "dimensions: array expected";
                    for (var i = 0; i < message.dimensions.length; ++i)
                        if (typeof message.dimensions[i] !== "number")
                            return "dimensions: number[] expected";
                }
                return null;
            };

            /**
             * Creates a Shape message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Shape
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Shape} Shape
             */
            Shape.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Shape)
                    return object;
                var message = new $root.metamoto.types.Shape();
                switch (object.type) {
                case "BOX":
                case 0:
                    message.type = 0;
                    break;
                case "SPHERE":
                case 1:
                    message.type = 1;
                    break;
                case "CYLINDER":
                case 2:
                    message.type = 2;
                    break;
                case "CONE":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.dimensions) {
                    if (!Array.isArray(object.dimensions))
                        throw TypeError(".metamoto.types.Shape.dimensions: array expected");
                    message.dimensions = [];
                    for (var i = 0; i < object.dimensions.length; ++i)
                        message.dimensions[i] = Number(object.dimensions[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Shape message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Shape
             * @static
             * @param {metamoto.types.Shape} message Shape
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Shape.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.dimensions = [];
                if (options.defaults)
                    object.type = options.enums === String ? "BOX" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Shape.Type[message.type] : message.type;
                if (message.dimensions && message.dimensions.length) {
                    object.dimensions = [];
                    for (var j = 0; j < message.dimensions.length; ++j)
                        object.dimensions[j] = options.json && !isFinite(message.dimensions[j]) ? String(message.dimensions[j]) : message.dimensions[j];
                }
                return object;
            };

            /**
             * Converts this Shape to JSON.
             * @function toJSON
             * @memberof metamoto.types.Shape
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Shape.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Shape.Type
             * @enum {string}
             * @property {number} BOX=0 BOX value
             * @property {number} SPHERE=1 SPHERE value
             * @property {number} CYLINDER=2 CYLINDER value
             * @property {number} CONE=3 CONE value
             */
            Shape.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BOX"] = 0;
                values[valuesById[1] = "SPHERE"] = 1;
                values[valuesById[2] = "CYLINDER"] = 2;
                values[valuesById[3] = "CONE"] = 3;
                return values;
            })();

            return Shape;
        })();

        types.SignalConfiguration = (function() {

            /**
             * Properties of a SignalConfiguration.
             * @memberof metamoto.types
             * @interface ISignalConfiguration
             * @property {Object.<string,metamoto.types.SignalConfiguration.ISignal>|null} [signals] SignalConfiguration signals
             */

            /**
             * Constructs a new SignalConfiguration.
             * @memberof metamoto.types
             * @classdesc Represents a SignalConfiguration.
             * @implements ISignalConfiguration
             * @constructor
             * @param {metamoto.types.ISignalConfiguration=} [properties] Properties to set
             */
            function SignalConfiguration(properties) {
                this.signals = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignalConfiguration signals.
             * @member {Object.<string,metamoto.types.SignalConfiguration.ISignal>} signals
             * @memberof metamoto.types.SignalConfiguration
             * @instance
             */
            SignalConfiguration.prototype.signals = $util.emptyObject;

            /**
             * Creates a new SignalConfiguration instance using the specified properties.
             * @function create
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {metamoto.types.ISignalConfiguration=} [properties] Properties to set
             * @returns {metamoto.types.SignalConfiguration} SignalConfiguration instance
             */
            SignalConfiguration.create = function create(properties) {
                return new SignalConfiguration(properties);
            };

            /**
             * Encodes the specified SignalConfiguration message. Does not implicitly {@link metamoto.types.SignalConfiguration.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {metamoto.types.ISignalConfiguration} message SignalConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignalConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signals != null && message.hasOwnProperty("signals"))
                    for (var keys = Object.keys(message.signals), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.SignalConfiguration.Signal.encode(message.signals[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified SignalConfiguration message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {metamoto.types.ISignalConfiguration} message SignalConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignalConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignalConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.SignalConfiguration} SignalConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignalConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.signals === $util.emptyObject)
                            message.signals = {};
                        key = reader.string();
                        reader.pos++;
                        message.signals[key] = $root.metamoto.types.SignalConfiguration.Signal.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignalConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.SignalConfiguration} SignalConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignalConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignalConfiguration message.
             * @function verify
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignalConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signals != null && message.hasOwnProperty("signals")) {
                    if (!$util.isObject(message.signals))
                        return "signals: object expected";
                    var key = Object.keys(message.signals);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.SignalConfiguration.Signal.verify(message.signals[key[i]]);
                        if (error)
                            return "signals." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SignalConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.SignalConfiguration} SignalConfiguration
             */
            SignalConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.SignalConfiguration)
                    return object;
                var message = new $root.metamoto.types.SignalConfiguration();
                if (object.signals) {
                    if (typeof object.signals !== "object")
                        throw TypeError(".metamoto.types.SignalConfiguration.signals: object expected");
                    message.signals = {};
                    for (var keys = Object.keys(object.signals), i = 0; i < keys.length; ++i) {
                        if (typeof object.signals[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.SignalConfiguration.signals: object expected");
                        message.signals[keys[i]] = $root.metamoto.types.SignalConfiguration.Signal.fromObject(object.signals[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SignalConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.SignalConfiguration
             * @static
             * @param {metamoto.types.SignalConfiguration} message SignalConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignalConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.signals = {};
                var keys2;
                if (message.signals && (keys2 = Object.keys(message.signals)).length) {
                    object.signals = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.signals[keys2[j]] = $root.metamoto.types.SignalConfiguration.Signal.toObject(message.signals[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this SignalConfiguration to JSON.
             * @function toJSON
             * @memberof metamoto.types.SignalConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignalConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SignalConfiguration.Signal = (function() {

                /**
                 * Properties of a Signal.
                 * @memberof metamoto.types.SignalConfiguration
                 * @interface ISignal
                 * @property {Object.<string,metamoto.types.SignalConfiguration.Signal.ISignalState>|null} [signalStates] Signal signalStates
                 * @property {string|null} [description] Signal description
                 * @property {Array.<metamoto.types.SignalConfiguration.Signal.IBulbType>|null} [bulbTypes] Signal bulbTypes
                 */

                /**
                 * Constructs a new Signal.
                 * @memberof metamoto.types.SignalConfiguration
                 * @classdesc Represents a Signal.
                 * @implements ISignal
                 * @constructor
                 * @param {metamoto.types.SignalConfiguration.ISignal=} [properties] Properties to set
                 */
                function Signal(properties) {
                    this.signalStates = {};
                    this.bulbTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Signal signalStates.
                 * @member {Object.<string,metamoto.types.SignalConfiguration.Signal.ISignalState>} signalStates
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @instance
                 */
                Signal.prototype.signalStates = $util.emptyObject;

                /**
                 * Signal description.
                 * @member {string} description
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @instance
                 */
                Signal.prototype.description = "";

                /**
                 * Signal bulbTypes.
                 * @member {Array.<metamoto.types.SignalConfiguration.Signal.IBulbType>} bulbTypes
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @instance
                 */
                Signal.prototype.bulbTypes = $util.emptyArray;

                /**
                 * Creates a new Signal instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {metamoto.types.SignalConfiguration.ISignal=} [properties] Properties to set
                 * @returns {metamoto.types.SignalConfiguration.Signal} Signal instance
                 */
                Signal.create = function create(properties) {
                    return new Signal(properties);
                };

                /**
                 * Encodes the specified Signal message. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {metamoto.types.SignalConfiguration.ISignal} message Signal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Signal.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signalStates != null && message.hasOwnProperty("signalStates"))
                        for (var keys = Object.keys(message.signalStates), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.metamoto.types.SignalConfiguration.Signal.SignalState.encode(message.signalStates[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.bulbTypes != null && message.bulbTypes.length)
                        for (var i = 0; i < message.bulbTypes.length; ++i)
                            $root.metamoto.types.SignalConfiguration.Signal.BulbType.encode(message.bulbTypes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Signal message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {metamoto.types.SignalConfiguration.ISignal} message Signal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Signal.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Signal message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.SignalConfiguration.Signal} Signal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Signal.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration.Signal(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.signalStates === $util.emptyObject)
                                message.signalStates = {};
                            key = reader.string();
                            reader.pos++;
                            message.signalStates[key] = $root.metamoto.types.SignalConfiguration.Signal.SignalState.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            if (!(message.bulbTypes && message.bulbTypes.length))
                                message.bulbTypes = [];
                            message.bulbTypes.push($root.metamoto.types.SignalConfiguration.Signal.BulbType.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Signal message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.SignalConfiguration.Signal} Signal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Signal.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Signal message.
                 * @function verify
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Signal.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signalStates != null && message.hasOwnProperty("signalStates")) {
                        if (!$util.isObject(message.signalStates))
                            return "signalStates: object expected";
                        var key = Object.keys(message.signalStates);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.metamoto.types.SignalConfiguration.Signal.SignalState.verify(message.signalStates[key[i]]);
                            if (error)
                                return "signalStates." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.bulbTypes != null && message.hasOwnProperty("bulbTypes")) {
                        if (!Array.isArray(message.bulbTypes))
                            return "bulbTypes: array expected";
                        for (var i = 0; i < message.bulbTypes.length; ++i) {
                            var error = $root.metamoto.types.SignalConfiguration.Signal.BulbType.verify(message.bulbTypes[i]);
                            if (error)
                                return "bulbTypes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Signal message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.SignalConfiguration.Signal} Signal
                 */
                Signal.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.SignalConfiguration.Signal)
                        return object;
                    var message = new $root.metamoto.types.SignalConfiguration.Signal();
                    if (object.signalStates) {
                        if (typeof object.signalStates !== "object")
                            throw TypeError(".metamoto.types.SignalConfiguration.Signal.signalStates: object expected");
                        message.signalStates = {};
                        for (var keys = Object.keys(object.signalStates), i = 0; i < keys.length; ++i) {
                            if (typeof object.signalStates[keys[i]] !== "object")
                                throw TypeError(".metamoto.types.SignalConfiguration.Signal.signalStates: object expected");
                            message.signalStates[keys[i]] = $root.metamoto.types.SignalConfiguration.Signal.SignalState.fromObject(object.signalStates[keys[i]]);
                        }
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.bulbTypes) {
                        if (!Array.isArray(object.bulbTypes))
                            throw TypeError(".metamoto.types.SignalConfiguration.Signal.bulbTypes: array expected");
                        message.bulbTypes = [];
                        for (var i = 0; i < object.bulbTypes.length; ++i) {
                            if (typeof object.bulbTypes[i] !== "object")
                                throw TypeError(".metamoto.types.SignalConfiguration.Signal.bulbTypes: object expected");
                            message.bulbTypes[i] = $root.metamoto.types.SignalConfiguration.Signal.BulbType.fromObject(object.bulbTypes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Signal message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @static
                 * @param {metamoto.types.SignalConfiguration.Signal} message Signal
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Signal.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.bulbTypes = [];
                    if (options.objects || options.defaults)
                        object.signalStates = {};
                    if (options.defaults)
                        object.description = "";
                    var keys2;
                    if (message.signalStates && (keys2 = Object.keys(message.signalStates)).length) {
                        object.signalStates = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.signalStates[keys2[j]] = $root.metamoto.types.SignalConfiguration.Signal.SignalState.toObject(message.signalStates[keys2[j]], options);
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.bulbTypes && message.bulbTypes.length) {
                        object.bulbTypes = [];
                        for (var j = 0; j < message.bulbTypes.length; ++j)
                            object.bulbTypes[j] = $root.metamoto.types.SignalConfiguration.Signal.BulbType.toObject(message.bulbTypes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Signal to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.SignalConfiguration.Signal
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Signal.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * ConnectionState enum.
                 * @name metamoto.types.SignalConfiguration.Signal.ConnectionState
                 * @enum {string}
                 * @property {number} CONNECTION_STATE_UNKNOWN=0 CONNECTION_STATE_UNKNOWN value
                 * @property {number} CONNECTION_STATE_OTHER=1 CONNECTION_STATE_OTHER value
                 * @property {number} GREEN=2 GREEN value
                 * @property {number} YELLOW=3 YELLOW value
                 * @property {number} RED=4 RED value
                 */
                Signal.ConnectionState = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CONNECTION_STATE_UNKNOWN"] = 0;
                    values[valuesById[1] = "CONNECTION_STATE_OTHER"] = 1;
                    values[valuesById[2] = "GREEN"] = 2;
                    values[valuesById[3] = "YELLOW"] = 3;
                    values[valuesById[4] = "RED"] = 4;
                    return values;
                })();

                /**
                 * ConnectionType enum.
                 * @name metamoto.types.SignalConfiguration.Signal.ConnectionType
                 * @enum {string}
                 * @property {number} CONNECTION_TYPE_UNKNOWN=0 CONNECTION_TYPE_UNKNOWN value
                 * @property {number} CONNECTION_TYPE_OTHER=1 CONNECTION_TYPE_OTHER value
                 * @property {number} PROTECTED=2 PROTECTED value
                 * @property {number} PERMISSIVE=3 PERMISSIVE value
                 */
                Signal.ConnectionType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CONNECTION_TYPE_UNKNOWN"] = 0;
                    values[valuesById[1] = "CONNECTION_TYPE_OTHER"] = 1;
                    values[valuesById[2] = "PROTECTED"] = 2;
                    values[valuesById[3] = "PERMISSIVE"] = 3;
                    return values;
                })();

                Signal.Connection = (function() {

                    /**
                     * Properties of a Connection.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @interface IConnection
                     * @property {metamoto.types.ConnectingRoad.Direction|null} [direction] Connection direction
                     * @property {metamoto.types.SignalConfiguration.Signal.ConnectionState|null} [state] Connection state
                     * @property {metamoto.types.SignalConfiguration.Signal.ConnectionType|null} [type] Connection type
                     */

                    /**
                     * Constructs a new Connection.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @classdesc Represents a Connection.
                     * @implements IConnection
                     * @constructor
                     * @param {metamoto.types.SignalConfiguration.Signal.IConnection=} [properties] Properties to set
                     */
                    function Connection(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Connection direction.
                     * @member {metamoto.types.ConnectingRoad.Direction} direction
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @instance
                     */
                    Connection.prototype.direction = 0;

                    /**
                     * Connection state.
                     * @member {metamoto.types.SignalConfiguration.Signal.ConnectionState} state
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @instance
                     */
                    Connection.prototype.state = 0;

                    /**
                     * Connection type.
                     * @member {metamoto.types.SignalConfiguration.Signal.ConnectionType} type
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @instance
                     */
                    Connection.prototype.type = 0;

                    /**
                     * Creates a new Connection instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IConnection=} [properties] Properties to set
                     * @returns {metamoto.types.SignalConfiguration.Signal.Connection} Connection instance
                     */
                    Connection.create = function create(properties) {
                        return new Connection(properties);
                    };

                    /**
                     * Encodes the specified Connection message. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.Connection.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IConnection} message Connection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Connection.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.direction);
                        if (message.state != null && message.hasOwnProperty("state"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Connection message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.Connection.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IConnection} message Connection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Connection.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Connection message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.SignalConfiguration.Signal.Connection} Connection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Connection.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration.Signal.Connection();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.direction = reader.int32();
                                break;
                            case 2:
                                message.state = reader.int32();
                                break;
                            case 3:
                                message.type = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Connection message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.SignalConfiguration.Signal.Connection} Connection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Connection.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Connection message.
                     * @function verify
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Connection.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            switch (message.direction) {
                            default:
                                return "direction: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                break;
                            }
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Connection message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.SignalConfiguration.Signal.Connection} Connection
                     */
                    Connection.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.SignalConfiguration.Signal.Connection)
                            return object;
                        var message = new $root.metamoto.types.SignalConfiguration.Signal.Connection();
                        switch (object.direction) {
                        case "UNKNOWN":
                        case 0:
                            message.direction = 0;
                            break;
                        case "OTHER":
                        case 1:
                            message.direction = 1;
                            break;
                        case "STRAIGHT":
                        case 2:
                            message.direction = 2;
                            break;
                        case "RIGHT":
                        case 3:
                            message.direction = 3;
                            break;
                        case "LEFT":
                        case 4:
                            message.direction = 4;
                            break;
                        case "UTURN":
                        case 5:
                            message.direction = 5;
                            break;
                        case "SOFT_RIGHT":
                        case 6:
                            message.direction = 6;
                            break;
                        case "SOFT_LEFT":
                        case 7:
                            message.direction = 7;
                            break;
                        }
                        switch (object.state) {
                        case "CONNECTION_STATE_UNKNOWN":
                        case 0:
                            message.state = 0;
                            break;
                        case "CONNECTION_STATE_OTHER":
                        case 1:
                            message.state = 1;
                            break;
                        case "GREEN":
                        case 2:
                            message.state = 2;
                            break;
                        case "YELLOW":
                        case 3:
                            message.state = 3;
                            break;
                        case "RED":
                        case 4:
                            message.state = 4;
                            break;
                        }
                        switch (object.type) {
                        case "CONNECTION_TYPE_UNKNOWN":
                        case 0:
                            message.type = 0;
                            break;
                        case "CONNECTION_TYPE_OTHER":
                        case 1:
                            message.type = 1;
                            break;
                        case "PROTECTED":
                        case 2:
                            message.type = 2;
                            break;
                        case "PERMISSIVE":
                        case 3:
                            message.type = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Connection message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.Connection} message Connection
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Connection.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.direction = options.enums === String ? "UNKNOWN" : 0;
                            object.state = options.enums === String ? "CONNECTION_STATE_UNKNOWN" : 0;
                            object.type = options.enums === String ? "CONNECTION_TYPE_UNKNOWN" : 0;
                        }
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            object.direction = options.enums === String ? $root.metamoto.types.ConnectingRoad.Direction[message.direction] : message.direction;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.metamoto.types.SignalConfiguration.Signal.ConnectionState[message.state] : message.state;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.metamoto.types.SignalConfiguration.Signal.ConnectionType[message.type] : message.type;
                        return object;
                    };

                    /**
                     * Converts this Connection to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.SignalConfiguration.Signal.Connection
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Connection.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Connection;
                })();

                Signal.BulbState = (function() {

                    /**
                     * Properties of a BulbState.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @interface IBulbState
                     * @property {metamoto.types.SignalConfiguration.Signal.BulbState.State|null} [state] BulbState state
                     */

                    /**
                     * Constructs a new BulbState.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @classdesc Represents a BulbState.
                     * @implements IBulbState
                     * @constructor
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbState=} [properties] Properties to set
                     */
                    function BulbState(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * BulbState state.
                     * @member {metamoto.types.SignalConfiguration.Signal.BulbState.State} state
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @instance
                     */
                    BulbState.prototype.state = 0;

                    /**
                     * Creates a new BulbState instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbState=} [properties] Properties to set
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbState} BulbState instance
                     */
                    BulbState.create = function create(properties) {
                        return new BulbState(properties);
                    };

                    /**
                     * Encodes the specified BulbState message. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.BulbState.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbState} message BulbState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BulbState.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.state != null && message.hasOwnProperty("state"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                        return writer;
                    };

                    /**
                     * Encodes the specified BulbState message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.BulbState.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbState} message BulbState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BulbState.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BulbState message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbState} BulbState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BulbState.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration.Signal.BulbState();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.state = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BulbState message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbState} BulbState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BulbState.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BulbState message.
                     * @function verify
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BulbState.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 7:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a BulbState message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbState} BulbState
                     */
                    BulbState.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.SignalConfiguration.Signal.BulbState)
                            return object;
                        var message = new $root.metamoto.types.SignalConfiguration.Signal.BulbState();
                        switch (object.state) {
                        case "OFF":
                        case 0:
                            message.state = 0;
                            break;
                        case "ON":
                        case 1:
                            message.state = 1;
                            break;
                        case "BLINKING":
                        case 2:
                            message.state = 2;
                            break;
                        case "STATE_UNKNOWN":
                        case 7:
                            message.state = 7;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a BulbState message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.BulbState} message BulbState
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BulbState.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.state = options.enums === String ? "OFF" : 0;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.metamoto.types.SignalConfiguration.Signal.BulbState.State[message.state] : message.state;
                        return object;
                    };

                    /**
                     * Converts this BulbState to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbState
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BulbState.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * State enum.
                     * @name metamoto.types.SignalConfiguration.Signal.BulbState.State
                     * @enum {string}
                     * @property {number} OFF=0 OFF value
                     * @property {number} ON=1 ON value
                     * @property {number} BLINKING=2 BLINKING value
                     * @property {number} STATE_UNKNOWN=7 STATE_UNKNOWN value
                     */
                    BulbState.State = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "OFF"] = 0;
                        values[valuesById[1] = "ON"] = 1;
                        values[valuesById[2] = "BLINKING"] = 2;
                        values[valuesById[7] = "STATE_UNKNOWN"] = 7;
                        return values;
                    })();

                    return BulbState;
                })();

                Signal.SignalState = (function() {

                    /**
                     * Properties of a SignalState.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @interface ISignalState
                     * @property {Array.<metamoto.types.SignalConfiguration.Signal.IConnection>|null} [connections] SignalState connections
                     * @property {Array.<metamoto.types.SignalConfiguration.Signal.IBulbState>|null} [bulbStates] SignalState bulbStates
                     */

                    /**
                     * Constructs a new SignalState.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @classdesc Represents a SignalState.
                     * @implements ISignalState
                     * @constructor
                     * @param {metamoto.types.SignalConfiguration.Signal.ISignalState=} [properties] Properties to set
                     */
                    function SignalState(properties) {
                        this.connections = [];
                        this.bulbStates = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SignalState connections.
                     * @member {Array.<metamoto.types.SignalConfiguration.Signal.IConnection>} connections
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @instance
                     */
                    SignalState.prototype.connections = $util.emptyArray;

                    /**
                     * SignalState bulbStates.
                     * @member {Array.<metamoto.types.SignalConfiguration.Signal.IBulbState>} bulbStates
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @instance
                     */
                    SignalState.prototype.bulbStates = $util.emptyArray;

                    /**
                     * Creates a new SignalState instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.ISignalState=} [properties] Properties to set
                     * @returns {metamoto.types.SignalConfiguration.Signal.SignalState} SignalState instance
                     */
                    SignalState.create = function create(properties) {
                        return new SignalState(properties);
                    };

                    /**
                     * Encodes the specified SignalState message. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.SignalState.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.ISignalState} message SignalState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalState.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.connections != null && message.connections.length)
                            for (var i = 0; i < message.connections.length; ++i)
                                $root.metamoto.types.SignalConfiguration.Signal.Connection.encode(message.connections[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.bulbStates != null && message.bulbStates.length)
                            for (var i = 0; i < message.bulbStates.length; ++i)
                                $root.metamoto.types.SignalConfiguration.Signal.BulbState.encode(message.bulbStates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified SignalState message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.SignalState.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.ISignalState} message SignalState message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalState.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SignalState message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.SignalConfiguration.Signal.SignalState} SignalState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalState.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration.Signal.SignalState();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.connections && message.connections.length))
                                    message.connections = [];
                                message.connections.push($root.metamoto.types.SignalConfiguration.Signal.Connection.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.bulbStates && message.bulbStates.length))
                                    message.bulbStates = [];
                                message.bulbStates.push($root.metamoto.types.SignalConfiguration.Signal.BulbState.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SignalState message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.SignalConfiguration.Signal.SignalState} SignalState
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalState.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SignalState message.
                     * @function verify
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SignalState.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.connections != null && message.hasOwnProperty("connections")) {
                            if (!Array.isArray(message.connections))
                                return "connections: array expected";
                            for (var i = 0; i < message.connections.length; ++i) {
                                var error = $root.metamoto.types.SignalConfiguration.Signal.Connection.verify(message.connections[i]);
                                if (error)
                                    return "connections." + error;
                            }
                        }
                        if (message.bulbStates != null && message.hasOwnProperty("bulbStates")) {
                            if (!Array.isArray(message.bulbStates))
                                return "bulbStates: array expected";
                            for (var i = 0; i < message.bulbStates.length; ++i) {
                                var error = $root.metamoto.types.SignalConfiguration.Signal.BulbState.verify(message.bulbStates[i]);
                                if (error)
                                    return "bulbStates." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a SignalState message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.SignalConfiguration.Signal.SignalState} SignalState
                     */
                    SignalState.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.SignalConfiguration.Signal.SignalState)
                            return object;
                        var message = new $root.metamoto.types.SignalConfiguration.Signal.SignalState();
                        if (object.connections) {
                            if (!Array.isArray(object.connections))
                                throw TypeError(".metamoto.types.SignalConfiguration.Signal.SignalState.connections: array expected");
                            message.connections = [];
                            for (var i = 0; i < object.connections.length; ++i) {
                                if (typeof object.connections[i] !== "object")
                                    throw TypeError(".metamoto.types.SignalConfiguration.Signal.SignalState.connections: object expected");
                                message.connections[i] = $root.metamoto.types.SignalConfiguration.Signal.Connection.fromObject(object.connections[i]);
                            }
                        }
                        if (object.bulbStates) {
                            if (!Array.isArray(object.bulbStates))
                                throw TypeError(".metamoto.types.SignalConfiguration.Signal.SignalState.bulbStates: array expected");
                            message.bulbStates = [];
                            for (var i = 0; i < object.bulbStates.length; ++i) {
                                if (typeof object.bulbStates[i] !== "object")
                                    throw TypeError(".metamoto.types.SignalConfiguration.Signal.SignalState.bulbStates: object expected");
                                message.bulbStates[i] = $root.metamoto.types.SignalConfiguration.Signal.BulbState.fromObject(object.bulbStates[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a SignalState message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.SignalState} message SignalState
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SignalState.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.connections = [];
                            object.bulbStates = [];
                        }
                        if (message.connections && message.connections.length) {
                            object.connections = [];
                            for (var j = 0; j < message.connections.length; ++j)
                                object.connections[j] = $root.metamoto.types.SignalConfiguration.Signal.Connection.toObject(message.connections[j], options);
                        }
                        if (message.bulbStates && message.bulbStates.length) {
                            object.bulbStates = [];
                            for (var j = 0; j < message.bulbStates.length; ++j)
                                object.bulbStates[j] = $root.metamoto.types.SignalConfiguration.Signal.BulbState.toObject(message.bulbStates[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this SignalState to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.SignalConfiguration.Signal.SignalState
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SignalState.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SignalState;
                })();

                Signal.BulbType = (function() {

                    /**
                     * Properties of a BulbType.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @interface IBulbType
                     * @property {metamoto.types.SignalConfiguration.Signal.BulbType.Type|null} [type] BulbType type
                     * @property {metamoto.types.SignalConfiguration.Signal.BulbType.Color|null} [color] BulbType color
                     */

                    /**
                     * Constructs a new BulbType.
                     * @memberof metamoto.types.SignalConfiguration.Signal
                     * @classdesc Represents a BulbType.
                     * @implements IBulbType
                     * @constructor
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbType=} [properties] Properties to set
                     */
                    function BulbType(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * BulbType type.
                     * @member {metamoto.types.SignalConfiguration.Signal.BulbType.Type} type
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @instance
                     */
                    BulbType.prototype.type = 0;

                    /**
                     * BulbType color.
                     * @member {metamoto.types.SignalConfiguration.Signal.BulbType.Color} color
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @instance
                     */
                    BulbType.prototype.color = 0;

                    /**
                     * Creates a new BulbType instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbType=} [properties] Properties to set
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbType} BulbType instance
                     */
                    BulbType.create = function create(properties) {
                        return new BulbType(properties);
                    };

                    /**
                     * Encodes the specified BulbType message. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.BulbType.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbType} message BulbType message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BulbType.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.color != null && message.hasOwnProperty("color"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                        return writer;
                    };

                    /**
                     * Encodes the specified BulbType message, length delimited. Does not implicitly {@link metamoto.types.SignalConfiguration.Signal.BulbType.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.IBulbType} message BulbType message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BulbType.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BulbType message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbType} BulbType
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BulbType.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.SignalConfiguration.Signal.BulbType();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.color = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BulbType message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbType} BulbType
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BulbType.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BulbType message.
                     * @function verify
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BulbType.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.color != null && message.hasOwnProperty("color"))
                            switch (message.color) {
                            default:
                                return "color: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a BulbType message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.SignalConfiguration.Signal.BulbType} BulbType
                     */
                    BulbType.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.SignalConfiguration.Signal.BulbType)
                            return object;
                        var message = new $root.metamoto.types.SignalConfiguration.Signal.BulbType();
                        switch (object.type) {
                        case "TYPE_UNKNOWN":
                        case 0:
                            message.type = 0;
                            break;
                        case "TYPE_OTHER":
                        case 1:
                            message.type = 1;
                            break;
                        case "NORMAL":
                        case 2:
                            message.type = 2;
                            break;
                        case "LEFT":
                        case 3:
                            message.type = 3;
                            break;
                        case "RIGHT":
                        case 4:
                            message.type = 4;
                            break;
                        case "SOFT_LEFT":
                        case 5:
                            message.type = 5;
                            break;
                        case "SOFT_RIGHT":
                        case 6:
                            message.type = 6;
                            break;
                        }
                        switch (object.color) {
                        case "COLOR_UNKNOWN":
                        case 0:
                            message.color = 0;
                            break;
                        case "COLOR_OTHER":
                        case 1:
                            message.color = 1;
                            break;
                        case "GREEN":
                        case 2:
                            message.color = 2;
                            break;
                        case "YELLOW":
                        case 3:
                            message.color = 3;
                            break;
                        case "RED":
                        case 4:
                            message.color = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a BulbType message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @static
                     * @param {metamoto.types.SignalConfiguration.Signal.BulbType} message BulbType
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BulbType.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                            object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.metamoto.types.SignalConfiguration.Signal.BulbType.Type[message.type] : message.type;
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = options.enums === String ? $root.metamoto.types.SignalConfiguration.Signal.BulbType.Color[message.color] : message.color;
                        return object;
                    };

                    /**
                     * Converts this BulbType to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.SignalConfiguration.Signal.BulbType
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BulbType.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Type enum.
                     * @name metamoto.types.SignalConfiguration.Signal.BulbType.Type
                     * @enum {string}
                     * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
                     * @property {number} TYPE_OTHER=1 TYPE_OTHER value
                     * @property {number} NORMAL=2 NORMAL value
                     * @property {number} LEFT=3 LEFT value
                     * @property {number} RIGHT=4 RIGHT value
                     * @property {number} SOFT_LEFT=5 SOFT_LEFT value
                     * @property {number} SOFT_RIGHT=6 SOFT_RIGHT value
                     */
                    BulbType.Type = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                        values[valuesById[1] = "TYPE_OTHER"] = 1;
                        values[valuesById[2] = "NORMAL"] = 2;
                        values[valuesById[3] = "LEFT"] = 3;
                        values[valuesById[4] = "RIGHT"] = 4;
                        values[valuesById[5] = "SOFT_LEFT"] = 5;
                        values[valuesById[6] = "SOFT_RIGHT"] = 6;
                        return values;
                    })();

                    /**
                     * Color enum.
                     * @name metamoto.types.SignalConfiguration.Signal.BulbType.Color
                     * @enum {string}
                     * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
                     * @property {number} COLOR_OTHER=1 COLOR_OTHER value
                     * @property {number} GREEN=2 GREEN value
                     * @property {number} YELLOW=3 YELLOW value
                     * @property {number} RED=4 RED value
                     */
                    BulbType.Color = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                        values[valuesById[1] = "COLOR_OTHER"] = 1;
                        values[valuesById[2] = "GREEN"] = 2;
                        values[valuesById[3] = "YELLOW"] = 3;
                        values[valuesById[4] = "RED"] = 4;
                        return values;
                    })();

                    return BulbType;
                })();

                return Signal;
            })();

            return SignalConfiguration;
        })();

        types.IntersectionConfiguration = (function() {

            /**
             * Properties of an IntersectionConfiguration.
             * @memberof metamoto.types
             * @interface IIntersectionConfiguration
             * @property {Object.<string,metamoto.types.Scenario.IIntersection>|null} [intersections] IntersectionConfiguration intersections
             */

            /**
             * Constructs a new IntersectionConfiguration.
             * @memberof metamoto.types
             * @classdesc Represents an IntersectionConfiguration.
             * @implements IIntersectionConfiguration
             * @constructor
             * @param {metamoto.types.IIntersectionConfiguration=} [properties] Properties to set
             */
            function IntersectionConfiguration(properties) {
                this.intersections = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IntersectionConfiguration intersections.
             * @member {Object.<string,metamoto.types.Scenario.IIntersection>} intersections
             * @memberof metamoto.types.IntersectionConfiguration
             * @instance
             */
            IntersectionConfiguration.prototype.intersections = $util.emptyObject;

            /**
             * Creates a new IntersectionConfiguration instance using the specified properties.
             * @function create
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {metamoto.types.IIntersectionConfiguration=} [properties] Properties to set
             * @returns {metamoto.types.IntersectionConfiguration} IntersectionConfiguration instance
             */
            IntersectionConfiguration.create = function create(properties) {
                return new IntersectionConfiguration(properties);
            };

            /**
             * Encodes the specified IntersectionConfiguration message. Does not implicitly {@link metamoto.types.IntersectionConfiguration.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {metamoto.types.IIntersectionConfiguration} message IntersectionConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IntersectionConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.intersections != null && message.hasOwnProperty("intersections"))
                    for (var keys = Object.keys(message.intersections), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Scenario.Intersection.encode(message.intersections[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified IntersectionConfiguration message, length delimited. Does not implicitly {@link metamoto.types.IntersectionConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {metamoto.types.IIntersectionConfiguration} message IntersectionConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IntersectionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IntersectionConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.IntersectionConfiguration} IntersectionConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IntersectionConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.IntersectionConfiguration(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.intersections === $util.emptyObject)
                            message.intersections = {};
                        key = reader.string();
                        reader.pos++;
                        message.intersections[key] = $root.metamoto.types.Scenario.Intersection.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IntersectionConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.IntersectionConfiguration} IntersectionConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IntersectionConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IntersectionConfiguration message.
             * @function verify
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IntersectionConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.intersections != null && message.hasOwnProperty("intersections")) {
                    if (!$util.isObject(message.intersections))
                        return "intersections: object expected";
                    var key = Object.keys(message.intersections);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Scenario.Intersection.verify(message.intersections[key[i]]);
                        if (error)
                            return "intersections." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an IntersectionConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.IntersectionConfiguration} IntersectionConfiguration
             */
            IntersectionConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.IntersectionConfiguration)
                    return object;
                var message = new $root.metamoto.types.IntersectionConfiguration();
                if (object.intersections) {
                    if (typeof object.intersections !== "object")
                        throw TypeError(".metamoto.types.IntersectionConfiguration.intersections: object expected");
                    message.intersections = {};
                    for (var keys = Object.keys(object.intersections), i = 0; i < keys.length; ++i) {
                        if (typeof object.intersections[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.IntersectionConfiguration.intersections: object expected");
                        message.intersections[keys[i]] = $root.metamoto.types.Scenario.Intersection.fromObject(object.intersections[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an IntersectionConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.IntersectionConfiguration
             * @static
             * @param {metamoto.types.IntersectionConfiguration} message IntersectionConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IntersectionConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.intersections = {};
                var keys2;
                if (message.intersections && (keys2 = Object.keys(message.intersections)).length) {
                    object.intersections = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.intersections[keys2[j]] = $root.metamoto.types.Scenario.Intersection.toObject(message.intersections[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this IntersectionConfiguration to JSON.
             * @function toJSON
             * @memberof metamoto.types.IntersectionConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IntersectionConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IntersectionConfiguration;
        })();

        types.TestCase = (function() {

            /**
             * Properties of a TestCase.
             * @memberof metamoto.types
             * @interface ITestCase
             * @property {string|null} [id] TestCase id
             * @property {string|null} [name] TestCase name
             * @property {metamoto.types.IScenario|null} [scenario] TestCase scenario
             * @property {metamoto.types.IEgoVehicle|null} [egoVehicle] TestCase egoVehicle
             * @property {Array.<metamoto.types.ITestJob>|null} [history] TestCase history
             * @property {string|null} [testManagerUrl] TestCase testManagerUrl
             */

            /**
             * Constructs a new TestCase.
             * @memberof metamoto.types
             * @classdesc Represents a TestCase.
             * @implements ITestCase
             * @constructor
             * @param {metamoto.types.ITestCase=} [properties] Properties to set
             */
            function TestCase(properties) {
                this.history = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestCase id.
             * @member {string} id
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.id = "";

            /**
             * TestCase name.
             * @member {string} name
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.name = "";

            /**
             * TestCase scenario.
             * @member {metamoto.types.IScenario|null|undefined} scenario
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.scenario = null;

            /**
             * TestCase egoVehicle.
             * @member {metamoto.types.IEgoVehicle|null|undefined} egoVehicle
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.egoVehicle = null;

            /**
             * TestCase history.
             * @member {Array.<metamoto.types.ITestJob>} history
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.history = $util.emptyArray;

            /**
             * TestCase testManagerUrl.
             * @member {string} testManagerUrl
             * @memberof metamoto.types.TestCase
             * @instance
             */
            TestCase.prototype.testManagerUrl = "";

            /**
             * Creates a new TestCase instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestCase
             * @static
             * @param {metamoto.types.ITestCase=} [properties] Properties to set
             * @returns {metamoto.types.TestCase} TestCase instance
             */
            TestCase.create = function create(properties) {
                return new TestCase(properties);
            };

            /**
             * Encodes the specified TestCase message. Does not implicitly {@link metamoto.types.TestCase.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestCase
             * @static
             * @param {metamoto.types.ITestCase} message TestCase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestCase.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    $root.metamoto.types.Scenario.encode(message.scenario, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    $root.metamoto.types.EgoVehicle.encode(message.egoVehicle, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.history != null && message.history.length)
                    for (var i = 0; i < message.history.length; ++i)
                        $root.metamoto.types.TestJob.encode(message.history[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.testManagerUrl != null && message.hasOwnProperty("testManagerUrl"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.testManagerUrl);
                return writer;
            };

            /**
             * Encodes the specified TestCase message, length delimited. Does not implicitly {@link metamoto.types.TestCase.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestCase
             * @static
             * @param {metamoto.types.ITestCase} message TestCase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestCase.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestCase message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestCase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestCase} TestCase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestCase.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestCase();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.scenario = $root.metamoto.types.Scenario.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.egoVehicle = $root.metamoto.types.EgoVehicle.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.history && message.history.length))
                            message.history = [];
                        message.history.push($root.metamoto.types.TestJob.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.testManagerUrl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestCase message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestCase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestCase} TestCase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestCase.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestCase message.
             * @function verify
             * @memberof metamoto.types.TestCase
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestCase.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                    var error = $root.metamoto.types.Scenario.verify(message.scenario);
                    if (error)
                        return "scenario." + error;
                }
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle")) {
                    var error = $root.metamoto.types.EgoVehicle.verify(message.egoVehicle);
                    if (error)
                        return "egoVehicle." + error;
                }
                if (message.history != null && message.hasOwnProperty("history")) {
                    if (!Array.isArray(message.history))
                        return "history: array expected";
                    for (var i = 0; i < message.history.length; ++i) {
                        var error = $root.metamoto.types.TestJob.verify(message.history[i]);
                        if (error)
                            return "history." + error;
                    }
                }
                if (message.testManagerUrl != null && message.hasOwnProperty("testManagerUrl"))
                    if (!$util.isString(message.testManagerUrl))
                        return "testManagerUrl: string expected";
                return null;
            };

            /**
             * Creates a TestCase message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestCase
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestCase} TestCase
             */
            TestCase.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestCase)
                    return object;
                var message = new $root.metamoto.types.TestCase();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.scenario != null) {
                    if (typeof object.scenario !== "object")
                        throw TypeError(".metamoto.types.TestCase.scenario: object expected");
                    message.scenario = $root.metamoto.types.Scenario.fromObject(object.scenario);
                }
                if (object.egoVehicle != null) {
                    if (typeof object.egoVehicle !== "object")
                        throw TypeError(".metamoto.types.TestCase.egoVehicle: object expected");
                    message.egoVehicle = $root.metamoto.types.EgoVehicle.fromObject(object.egoVehicle);
                }
                if (object.history) {
                    if (!Array.isArray(object.history))
                        throw TypeError(".metamoto.types.TestCase.history: array expected");
                    message.history = [];
                    for (var i = 0; i < object.history.length; ++i) {
                        if (typeof object.history[i] !== "object")
                            throw TypeError(".metamoto.types.TestCase.history: object expected");
                        message.history[i] = $root.metamoto.types.TestJob.fromObject(object.history[i]);
                    }
                }
                if (object.testManagerUrl != null)
                    message.testManagerUrl = String(object.testManagerUrl);
                return message;
            };

            /**
             * Creates a plain object from a TestCase message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestCase
             * @static
             * @param {metamoto.types.TestCase} message TestCase
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestCase.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.history = [];
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.scenario = null;
                    object.egoVehicle = null;
                    object.testManagerUrl = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    object.scenario = $root.metamoto.types.Scenario.toObject(message.scenario, options);
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    object.egoVehicle = $root.metamoto.types.EgoVehicle.toObject(message.egoVehicle, options);
                if (message.history && message.history.length) {
                    object.history = [];
                    for (var j = 0; j < message.history.length; ++j)
                        object.history[j] = $root.metamoto.types.TestJob.toObject(message.history[j], options);
                }
                if (message.testManagerUrl != null && message.hasOwnProperty("testManagerUrl"))
                    object.testManagerUrl = message.testManagerUrl;
                return object;
            };

            /**
             * Converts this TestCase to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestCase
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestCase.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TestCase;
        })();

        types.TestJob = (function() {

            /**
             * Properties of a TestJob.
             * @memberof metamoto.types
             * @interface ITestJob
             * @property {string|null} [jobId] TestJob jobId
             * @property {Array.<string>|null} [sutJobIds] TestJob sutJobIds
             * @property {string|null} [testRunId] TestJob testRunId
             * @property {string|null} [testCaseId] TestJob testCaseId
             * @property {string|null} [testCaseName] TestJob testCaseName
             * @property {string|null} [testVectorId] TestJob testVectorId
             * @property {string|null} [testVectorName] TestJob testVectorName
             * @property {metamoto.types.TestVector.Strategy|null} [testVectorStrategy] TestJob testVectorStrategy
             * @property {string|null} [startTime] TestJob startTime
             * @property {string|null} [endTime] TestJob endTime
             * @property {number|null} [computeTime] TestJob computeTime
             * @property {metamoto.types.TestResult.Status|null} [status] TestJob status
             * @property {string|null} [resultText] TestJob resultText
             * @property {number|null} [progress] TestJob progress
             * @property {number|null} [durationObjective] TestJob durationObjective
             * @property {number|null} [lastJobDuration] TestJob lastJobDuration
             * @property {string|null} [logFile] TestJob logFile
             * @property {string|null} [resultsFile] TestJob resultsFile
             * @property {number|null} [diskUsage] TestJob diskUsage
             * @property {string|null} [lastUpdateTime] TestJob lastUpdateTime
             * @property {string|null} [sutLogFile] TestJob sutLogFile
             * @property {Object.<string,metamoto.types.IParameter>|null} [parameters] TestJob parameters
             */

            /**
             * Constructs a new TestJob.
             * @memberof metamoto.types
             * @classdesc Represents a TestJob.
             * @implements ITestJob
             * @constructor
             * @param {metamoto.types.ITestJob=} [properties] Properties to set
             */
            function TestJob(properties) {
                this.sutJobIds = [];
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestJob jobId.
             * @member {string} jobId
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.jobId = "";

            /**
             * TestJob sutJobIds.
             * @member {Array.<string>} sutJobIds
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.sutJobIds = $util.emptyArray;

            /**
             * TestJob testRunId.
             * @member {string} testRunId
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testRunId = "";

            /**
             * TestJob testCaseId.
             * @member {string} testCaseId
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testCaseId = "";

            /**
             * TestJob testCaseName.
             * @member {string} testCaseName
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testCaseName = "";

            /**
             * TestJob testVectorId.
             * @member {string} testVectorId
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testVectorId = "";

            /**
             * TestJob testVectorName.
             * @member {string} testVectorName
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testVectorName = "";

            /**
             * TestJob testVectorStrategy.
             * @member {metamoto.types.TestVector.Strategy} testVectorStrategy
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.testVectorStrategy = 0;

            /**
             * TestJob startTime.
             * @member {string} startTime
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.startTime = "";

            /**
             * TestJob endTime.
             * @member {string} endTime
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.endTime = "";

            /**
             * TestJob computeTime.
             * @member {number} computeTime
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.computeTime = 0;

            /**
             * TestJob status.
             * @member {metamoto.types.TestResult.Status} status
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.status = 0;

            /**
             * TestJob resultText.
             * @member {string} resultText
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.resultText = "";

            /**
             * TestJob progress.
             * @member {number} progress
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.progress = 0;

            /**
             * TestJob durationObjective.
             * @member {number} durationObjective
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.durationObjective = 0;

            /**
             * TestJob lastJobDuration.
             * @member {number} lastJobDuration
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.lastJobDuration = 0;

            /**
             * TestJob logFile.
             * @member {string} logFile
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.logFile = "";

            /**
             * TestJob resultsFile.
             * @member {string} resultsFile
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.resultsFile = "";

            /**
             * TestJob diskUsage.
             * @member {number} diskUsage
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.diskUsage = 0;

            /**
             * TestJob lastUpdateTime.
             * @member {string} lastUpdateTime
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.lastUpdateTime = "";

            /**
             * TestJob sutLogFile.
             * @member {string} sutLogFile
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.sutLogFile = "";

            /**
             * TestJob parameters.
             * @member {Object.<string,metamoto.types.IParameter>} parameters
             * @memberof metamoto.types.TestJob
             * @instance
             */
            TestJob.prototype.parameters = $util.emptyObject;

            /**
             * Creates a new TestJob instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestJob
             * @static
             * @param {metamoto.types.ITestJob=} [properties] Properties to set
             * @returns {metamoto.types.TestJob} TestJob instance
             */
            TestJob.create = function create(properties) {
                return new TestJob(properties);
            };

            /**
             * Encodes the specified TestJob message. Does not implicitly {@link metamoto.types.TestJob.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestJob
             * @static
             * @param {metamoto.types.ITestJob} message TestJob message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestJob.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                if (message.sutJobIds != null && message.sutJobIds.length)
                    for (var i = 0; i < message.sutJobIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sutJobIds[i]);
                if (message.testRunId != null && message.hasOwnProperty("testRunId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.testRunId);
                if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.testCaseId);
                if (message.testCaseName != null && message.hasOwnProperty("testCaseName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.testCaseName);
                if (message.testVectorId != null && message.hasOwnProperty("testVectorId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.testVectorId);
                if (message.testVectorName != null && message.hasOwnProperty("testVectorName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.testVectorName);
                if (message.testVectorStrategy != null && message.hasOwnProperty("testVectorStrategy"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.testVectorStrategy);
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.startTime);
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.endTime);
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.computeTime);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.resultText);
                if (message.progress != null && message.hasOwnProperty("progress"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.progress);
                if (message.durationObjective != null && message.hasOwnProperty("durationObjective"))
                    writer.uint32(/* id 15, wireType 5 =*/125).float(message.durationObjective);
                if (message.lastJobDuration != null && message.hasOwnProperty("lastJobDuration"))
                    writer.uint32(/* id 16, wireType 5 =*/133).float(message.lastJobDuration);
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.logFile);
                if (message.resultsFile != null && message.hasOwnProperty("resultsFile"))
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.resultsFile);
                if (message.diskUsage != null && message.hasOwnProperty("diskUsage"))
                    writer.uint32(/* id 19, wireType 5 =*/157).float(message.diskUsage);
                if (message.lastUpdateTime != null && message.hasOwnProperty("lastUpdateTime"))
                    writer.uint32(/* id 20, wireType 2 =*/162).string(message.lastUpdateTime);
                if (message.sutLogFile != null && message.hasOwnProperty("sutLogFile"))
                    writer.uint32(/* id 21, wireType 2 =*/170).string(message.sutLogFile);
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Parameter.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified TestJob message, length delimited. Does not implicitly {@link metamoto.types.TestJob.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestJob
             * @static
             * @param {metamoto.types.ITestJob} message TestJob message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestJob.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestJob message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestJob
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestJob} TestJob
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestJob.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestJob(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.jobId = reader.string();
                        break;
                    case 2:
                        if (!(message.sutJobIds && message.sutJobIds.length))
                            message.sutJobIds = [];
                        message.sutJobIds.push(reader.string());
                        break;
                    case 3:
                        message.testRunId = reader.string();
                        break;
                    case 4:
                        message.testCaseId = reader.string();
                        break;
                    case 5:
                        message.testCaseName = reader.string();
                        break;
                    case 6:
                        message.testVectorId = reader.string();
                        break;
                    case 7:
                        message.testVectorName = reader.string();
                        break;
                    case 8:
                        message.testVectorStrategy = reader.int32();
                        break;
                    case 9:
                        message.startTime = reader.string();
                        break;
                    case 10:
                        message.endTime = reader.string();
                        break;
                    case 11:
                        message.computeTime = reader.float();
                        break;
                    case 12:
                        message.status = reader.int32();
                        break;
                    case 13:
                        message.resultText = reader.string();
                        break;
                    case 14:
                        message.progress = reader.float();
                        break;
                    case 15:
                        message.durationObjective = reader.float();
                        break;
                    case 16:
                        message.lastJobDuration = reader.float();
                        break;
                    case 17:
                        message.logFile = reader.string();
                        break;
                    case 18:
                        message.resultsFile = reader.string();
                        break;
                    case 19:
                        message.diskUsage = reader.float();
                        break;
                    case 20:
                        message.lastUpdateTime = reader.string();
                        break;
                    case 21:
                        message.sutLogFile = reader.string();
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.metamoto.types.Parameter.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestJob message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestJob
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestJob} TestJob
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestJob.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestJob message.
             * @function verify
             * @memberof metamoto.types.TestJob
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestJob.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    if (!$util.isString(message.jobId))
                        return "jobId: string expected";
                if (message.sutJobIds != null && message.hasOwnProperty("sutJobIds")) {
                    if (!Array.isArray(message.sutJobIds))
                        return "sutJobIds: array expected";
                    for (var i = 0; i < message.sutJobIds.length; ++i)
                        if (!$util.isString(message.sutJobIds[i]))
                            return "sutJobIds: string[] expected";
                }
                if (message.testRunId != null && message.hasOwnProperty("testRunId"))
                    if (!$util.isString(message.testRunId))
                        return "testRunId: string expected";
                if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                    if (!$util.isString(message.testCaseId))
                        return "testCaseId: string expected";
                if (message.testCaseName != null && message.hasOwnProperty("testCaseName"))
                    if (!$util.isString(message.testCaseName))
                        return "testCaseName: string expected";
                if (message.testVectorId != null && message.hasOwnProperty("testVectorId"))
                    if (!$util.isString(message.testVectorId))
                        return "testVectorId: string expected";
                if (message.testVectorName != null && message.hasOwnProperty("testVectorName"))
                    if (!$util.isString(message.testVectorName))
                        return "testVectorName: string expected";
                if (message.testVectorStrategy != null && message.hasOwnProperty("testVectorStrategy"))
                    switch (message.testVectorStrategy) {
                    default:
                        return "testVectorStrategy: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isString(message.startTime))
                        return "startTime: string expected";
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (!$util.isString(message.endTime))
                        return "endTime: string expected";
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    if (typeof message.computeTime !== "number")
                        return "computeTime: number expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    if (!$util.isString(message.resultText))
                        return "resultText: string expected";
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (typeof message.progress !== "number")
                        return "progress: number expected";
                if (message.durationObjective != null && message.hasOwnProperty("durationObjective"))
                    if (typeof message.durationObjective !== "number")
                        return "durationObjective: number expected";
                if (message.lastJobDuration != null && message.hasOwnProperty("lastJobDuration"))
                    if (typeof message.lastJobDuration !== "number")
                        return "lastJobDuration: number expected";
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    if (!$util.isString(message.logFile))
                        return "logFile: string expected";
                if (message.resultsFile != null && message.hasOwnProperty("resultsFile"))
                    if (!$util.isString(message.resultsFile))
                        return "resultsFile: string expected";
                if (message.diskUsage != null && message.hasOwnProperty("diskUsage"))
                    if (typeof message.diskUsage !== "number")
                        return "diskUsage: number expected";
                if (message.lastUpdateTime != null && message.hasOwnProperty("lastUpdateTime"))
                    if (!$util.isString(message.lastUpdateTime))
                        return "lastUpdateTime: string expected";
                if (message.sutLogFile != null && message.hasOwnProperty("sutLogFile"))
                    if (!$util.isString(message.sutLogFile))
                        return "sutLogFile: string expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Parameter.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TestJob message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestJob
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestJob} TestJob
             */
            TestJob.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestJob)
                    return object;
                var message = new $root.metamoto.types.TestJob();
                if (object.jobId != null)
                    message.jobId = String(object.jobId);
                if (object.sutJobIds) {
                    if (!Array.isArray(object.sutJobIds))
                        throw TypeError(".metamoto.types.TestJob.sutJobIds: array expected");
                    message.sutJobIds = [];
                    for (var i = 0; i < object.sutJobIds.length; ++i)
                        message.sutJobIds[i] = String(object.sutJobIds[i]);
                }
                if (object.testRunId != null)
                    message.testRunId = String(object.testRunId);
                if (object.testCaseId != null)
                    message.testCaseId = String(object.testCaseId);
                if (object.testCaseName != null)
                    message.testCaseName = String(object.testCaseName);
                if (object.testVectorId != null)
                    message.testVectorId = String(object.testVectorId);
                if (object.testVectorName != null)
                    message.testVectorName = String(object.testVectorName);
                switch (object.testVectorStrategy) {
                case "UNKNOWN":
                case 0:
                    message.testVectorStrategy = 0;
                    break;
                case "OTHER":
                case 1:
                    message.testVectorStrategy = 1;
                    break;
                case "SINGLE":
                case 2:
                    message.testVectorStrategy = 2;
                    break;
                case "EXHAUSTIVE":
                case 3:
                    message.testVectorStrategy = 3;
                    break;
                case "RANDOM":
                case 4:
                    message.testVectorStrategy = 4;
                    break;
                case "EDGES":
                case 5:
                    message.testVectorStrategy = 5;
                    break;
                }
                if (object.startTime != null)
                    message.startTime = String(object.startTime);
                if (object.endTime != null)
                    message.endTime = String(object.endTime);
                if (object.computeTime != null)
                    message.computeTime = Number(object.computeTime);
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "OTHER":
                case 1:
                    message.status = 1;
                    break;
                case "PASS":
                case 2:
                    message.status = 2;
                    break;
                case "FAIL":
                case 3:
                    message.status = 3;
                    break;
                case "STOP":
                case 4:
                    message.status = 4;
                    break;
                case "ERROR":
                case 5:
                    message.status = 5;
                    break;
                case "PENDING":
                case 6:
                    message.status = 6;
                    break;
                case "RUNNING":
                case 7:
                    message.status = 7;
                    break;
                case "STOPPING":
                case 8:
                    message.status = 8;
                    break;
                case "POST_PROCESSING":
                case 9:
                    message.status = 9;
                    break;
                }
                if (object.resultText != null)
                    message.resultText = String(object.resultText);
                if (object.progress != null)
                    message.progress = Number(object.progress);
                if (object.durationObjective != null)
                    message.durationObjective = Number(object.durationObjective);
                if (object.lastJobDuration != null)
                    message.lastJobDuration = Number(object.lastJobDuration);
                if (object.logFile != null)
                    message.logFile = String(object.logFile);
                if (object.resultsFile != null)
                    message.resultsFile = String(object.resultsFile);
                if (object.diskUsage != null)
                    message.diskUsage = Number(object.diskUsage);
                if (object.lastUpdateTime != null)
                    message.lastUpdateTime = String(object.lastUpdateTime);
                if (object.sutLogFile != null)
                    message.sutLogFile = String(object.sutLogFile);
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".metamoto.types.TestJob.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.TestJob.parameters: object expected");
                        message.parameters[keys[i]] = $root.metamoto.types.Parameter.fromObject(object.parameters[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TestJob message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestJob
             * @static
             * @param {metamoto.types.TestJob} message TestJob
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestJob.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sutJobIds = [];
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.jobId = "";
                    object.testRunId = "";
                    object.testCaseId = "";
                    object.testCaseName = "";
                    object.testVectorId = "";
                    object.testVectorName = "";
                    object.testVectorStrategy = options.enums === String ? "UNKNOWN" : 0;
                    object.startTime = "";
                    object.endTime = "";
                    object.computeTime = 0;
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.resultText = "";
                    object.progress = 0;
                    object.durationObjective = 0;
                    object.lastJobDuration = 0;
                    object.logFile = "";
                    object.resultsFile = "";
                    object.diskUsage = 0;
                    object.lastUpdateTime = "";
                    object.sutLogFile = "";
                }
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    object.jobId = message.jobId;
                if (message.sutJobIds && message.sutJobIds.length) {
                    object.sutJobIds = [];
                    for (var j = 0; j < message.sutJobIds.length; ++j)
                        object.sutJobIds[j] = message.sutJobIds[j];
                }
                if (message.testRunId != null && message.hasOwnProperty("testRunId"))
                    object.testRunId = message.testRunId;
                if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                    object.testCaseId = message.testCaseId;
                if (message.testCaseName != null && message.hasOwnProperty("testCaseName"))
                    object.testCaseName = message.testCaseName;
                if (message.testVectorId != null && message.hasOwnProperty("testVectorId"))
                    object.testVectorId = message.testVectorId;
                if (message.testVectorName != null && message.hasOwnProperty("testVectorName"))
                    object.testVectorName = message.testVectorName;
                if (message.testVectorStrategy != null && message.hasOwnProperty("testVectorStrategy"))
                    object.testVectorStrategy = options.enums === String ? $root.metamoto.types.TestVector.Strategy[message.testVectorStrategy] : message.testVectorStrategy;
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    object.startTime = message.startTime;
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    object.endTime = message.endTime;
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    object.computeTime = options.json && !isFinite(message.computeTime) ? String(message.computeTime) : message.computeTime;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.metamoto.types.TestResult.Status[message.status] : message.status;
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    object.resultText = message.resultText;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
                if (message.durationObjective != null && message.hasOwnProperty("durationObjective"))
                    object.durationObjective = options.json && !isFinite(message.durationObjective) ? String(message.durationObjective) : message.durationObjective;
                if (message.lastJobDuration != null && message.hasOwnProperty("lastJobDuration"))
                    object.lastJobDuration = options.json && !isFinite(message.lastJobDuration) ? String(message.lastJobDuration) : message.lastJobDuration;
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    object.logFile = message.logFile;
                if (message.resultsFile != null && message.hasOwnProperty("resultsFile"))
                    object.resultsFile = message.resultsFile;
                if (message.diskUsage != null && message.hasOwnProperty("diskUsage"))
                    object.diskUsage = options.json && !isFinite(message.diskUsage) ? String(message.diskUsage) : message.diskUsage;
                if (message.lastUpdateTime != null && message.hasOwnProperty("lastUpdateTime"))
                    object.lastUpdateTime = message.lastUpdateTime;
                if (message.sutLogFile != null && message.hasOwnProperty("sutLogFile"))
                    object.sutLogFile = message.sutLogFile;
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.metamoto.types.Parameter.toObject(message.parameters[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this TestJob to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestJob
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestJob.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TestJob;
        })();

        types.TestResult = (function() {

            /**
             * Properties of a TestResult.
             * @memberof metamoto.types
             * @interface ITestResult
             * @property {string|null} [name] TestResult name
             * @property {string|null} [timestamp] TestResult timestamp
             * @property {string|null} [testEngineVersion] TestResult testEngineVersion
             * @property {metamoto.types.TestResult.IResult|null} [result] TestResult result
             * @property {metamoto.types.TestResult.IStatistics|null} [statistics] TestResult statistics
             * @property {Array.<metamoto.types.TestResult.IDataBusTopic>|null} [topics] TestResult topics
             * @property {string|null} [testCaseFile] TestResult testCaseFile
             * @property {string|null} [logFile] TestResult logFile
             * @property {string|null} [intersectionSeriesLogFile] TestResult intersectionSeriesLogFile
             * @property {string|null} [transformsDirectory] TestResult transformsDirectory
             * @property {string|null} [dataStreamsDirectory] TestResult dataStreamsDirectory
             * @property {string|null} [finalViewsDirectory] TestResult finalViewsDirectory
             * @property {string|null} [dataBusDirectory] TestResult dataBusDirectory
             * @property {metamoto.types.TestResult.IVehicle|null} [egoVehicle] TestResult egoVehicle
             * @property {Array.<metamoto.types.TestResult.IVehicle>|null} [vehicles] TestResult vehicles
             * @property {Array.<metamoto.types.TestResult.IPedestrian>|null} [pedestrians] TestResult pedestrians
             * @property {Array.<string>|null} [finalViewFiles] TestResult finalViewFiles
             * @property {Array.<metamoto.types.TestResult.IDataStream>|null} [dataStreams] TestResult dataStreams
             * @property {Array.<metamoto.types.IAsset>|null} [assets] TestResult assets
             * @property {Array.<metamoto.types.TestResult.IVehicle>|null} [egoVehicles] TestResult egoVehicles
             */

            /**
             * Constructs a new TestResult.
             * @memberof metamoto.types
             * @classdesc Represents a TestResult.
             * @implements ITestResult
             * @constructor
             * @param {metamoto.types.ITestResult=} [properties] Properties to set
             */
            function TestResult(properties) {
                this.topics = [];
                this.vehicles = [];
                this.pedestrians = [];
                this.finalViewFiles = [];
                this.dataStreams = [];
                this.assets = [];
                this.egoVehicles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestResult name.
             * @member {string} name
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.name = "";

            /**
             * TestResult timestamp.
             * @member {string} timestamp
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.timestamp = "";

            /**
             * TestResult testEngineVersion.
             * @member {string} testEngineVersion
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.testEngineVersion = "";

            /**
             * TestResult result.
             * @member {metamoto.types.TestResult.IResult|null|undefined} result
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.result = null;

            /**
             * TestResult statistics.
             * @member {metamoto.types.TestResult.IStatistics|null|undefined} statistics
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.statistics = null;

            /**
             * TestResult topics.
             * @member {Array.<metamoto.types.TestResult.IDataBusTopic>} topics
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.topics = $util.emptyArray;

            /**
             * TestResult testCaseFile.
             * @member {string} testCaseFile
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.testCaseFile = "";

            /**
             * TestResult logFile.
             * @member {string} logFile
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.logFile = "";

            /**
             * TestResult intersectionSeriesLogFile.
             * @member {string} intersectionSeriesLogFile
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.intersectionSeriesLogFile = "";

            /**
             * TestResult transformsDirectory.
             * @member {string} transformsDirectory
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.transformsDirectory = "";

            /**
             * TestResult dataStreamsDirectory.
             * @member {string} dataStreamsDirectory
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.dataStreamsDirectory = "";

            /**
             * TestResult finalViewsDirectory.
             * @member {string} finalViewsDirectory
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.finalViewsDirectory = "";

            /**
             * TestResult dataBusDirectory.
             * @member {string} dataBusDirectory
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.dataBusDirectory = "";

            /**
             * TestResult egoVehicle.
             * @member {metamoto.types.TestResult.IVehicle|null|undefined} egoVehicle
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.egoVehicle = null;

            /**
             * TestResult vehicles.
             * @member {Array.<metamoto.types.TestResult.IVehicle>} vehicles
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.vehicles = $util.emptyArray;

            /**
             * TestResult pedestrians.
             * @member {Array.<metamoto.types.TestResult.IPedestrian>} pedestrians
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.pedestrians = $util.emptyArray;

            /**
             * TestResult finalViewFiles.
             * @member {Array.<string>} finalViewFiles
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.finalViewFiles = $util.emptyArray;

            /**
             * TestResult dataStreams.
             * @member {Array.<metamoto.types.TestResult.IDataStream>} dataStreams
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.dataStreams = $util.emptyArray;

            /**
             * TestResult assets.
             * @member {Array.<metamoto.types.IAsset>} assets
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.assets = $util.emptyArray;

            /**
             * TestResult egoVehicles.
             * @member {Array.<metamoto.types.TestResult.IVehicle>} egoVehicles
             * @memberof metamoto.types.TestResult
             * @instance
             */
            TestResult.prototype.egoVehicles = $util.emptyArray;

            /**
             * Creates a new TestResult instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestResult
             * @static
             * @param {metamoto.types.ITestResult=} [properties] Properties to set
             * @returns {metamoto.types.TestResult} TestResult instance
             */
            TestResult.create = function create(properties) {
                return new TestResult(properties);
            };

            /**
             * Encodes the specified TestResult message. Does not implicitly {@link metamoto.types.TestResult.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestResult
             * @static
             * @param {metamoto.types.ITestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.timestamp);
                if (message.testEngineVersion != null && message.hasOwnProperty("testEngineVersion"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.testEngineVersion);
                if (message.result != null && message.hasOwnProperty("result"))
                    $root.metamoto.types.TestResult.Result.encode(message.result, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.statistics != null && message.hasOwnProperty("statistics"))
                    $root.metamoto.types.TestResult.Statistics.encode(message.statistics, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        $root.metamoto.types.TestResult.DataBusTopic.encode(message.topics[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.testCaseFile != null && message.hasOwnProperty("testCaseFile"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.testCaseFile);
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.logFile);
                if (message.intersectionSeriesLogFile != null && message.hasOwnProperty("intersectionSeriesLogFile"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.intersectionSeriesLogFile);
                if (message.transformsDirectory != null && message.hasOwnProperty("transformsDirectory"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.transformsDirectory);
                if (message.dataStreamsDirectory != null && message.hasOwnProperty("dataStreamsDirectory"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dataStreamsDirectory);
                if (message.finalViewsDirectory != null && message.hasOwnProperty("finalViewsDirectory"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.finalViewsDirectory);
                if (message.dataBusDirectory != null && message.hasOwnProperty("dataBusDirectory"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.dataBusDirectory);
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    $root.metamoto.types.TestResult.Vehicle.encode(message.egoVehicle, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.vehicles != null && message.vehicles.length)
                    for (var i = 0; i < message.vehicles.length; ++i)
                        $root.metamoto.types.TestResult.Vehicle.encode(message.vehicles[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.pedestrians != null && message.pedestrians.length)
                    for (var i = 0; i < message.pedestrians.length; ++i)
                        $root.metamoto.types.TestResult.Pedestrian.encode(message.pedestrians[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.finalViewFiles != null && message.finalViewFiles.length)
                    for (var i = 0; i < message.finalViewFiles.length; ++i)
                        writer.uint32(/* id 17, wireType 2 =*/138).string(message.finalViewFiles[i]);
                if (message.dataStreams != null && message.dataStreams.length)
                    for (var i = 0; i < message.dataStreams.length; ++i)
                        $root.metamoto.types.TestResult.DataStream.encode(message.dataStreams[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.assets != null && message.assets.length)
                    for (var i = 0; i < message.assets.length; ++i)
                        $root.metamoto.types.Asset.encode(message.assets[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.egoVehicles != null && message.egoVehicles.length)
                    for (var i = 0; i < message.egoVehicles.length; ++i)
                        $root.metamoto.types.TestResult.Vehicle.encode(message.egoVehicles[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TestResult message, length delimited. Does not implicitly {@link metamoto.types.TestResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestResult
             * @static
             * @param {metamoto.types.ITestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestResult message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.string();
                        break;
                    case 3:
                        message.testEngineVersion = reader.string();
                        break;
                    case 4:
                        message.result = $root.metamoto.types.TestResult.Result.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.statistics = $root.metamoto.types.TestResult.Statistics.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push($root.metamoto.types.TestResult.DataBusTopic.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.testCaseFile = reader.string();
                        break;
                    case 8:
                        message.logFile = reader.string();
                        break;
                    case 9:
                        message.intersectionSeriesLogFile = reader.string();
                        break;
                    case 10:
                        message.transformsDirectory = reader.string();
                        break;
                    case 11:
                        message.dataStreamsDirectory = reader.string();
                        break;
                    case 12:
                        message.finalViewsDirectory = reader.string();
                        break;
                    case 13:
                        message.dataBusDirectory = reader.string();
                        break;
                    case 14:
                        message.egoVehicle = $root.metamoto.types.TestResult.Vehicle.decode(reader, reader.uint32());
                        break;
                    case 15:
                        if (!(message.vehicles && message.vehicles.length))
                            message.vehicles = [];
                        message.vehicles.push($root.metamoto.types.TestResult.Vehicle.decode(reader, reader.uint32()));
                        break;
                    case 16:
                        if (!(message.pedestrians && message.pedestrians.length))
                            message.pedestrians = [];
                        message.pedestrians.push($root.metamoto.types.TestResult.Pedestrian.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        if (!(message.finalViewFiles && message.finalViewFiles.length))
                            message.finalViewFiles = [];
                        message.finalViewFiles.push(reader.string());
                        break;
                    case 18:
                        if (!(message.dataStreams && message.dataStreams.length))
                            message.dataStreams = [];
                        message.dataStreams.push($root.metamoto.types.TestResult.DataStream.decode(reader, reader.uint32()));
                        break;
                    case 19:
                        if (!(message.assets && message.assets.length))
                            message.assets = [];
                        message.assets.push($root.metamoto.types.Asset.decode(reader, reader.uint32()));
                        break;
                    case 20:
                        if (!(message.egoVehicles && message.egoVehicles.length))
                            message.egoVehicles = [];
                        message.egoVehicles.push($root.metamoto.types.TestResult.Vehicle.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestResult message.
             * @function verify
             * @memberof metamoto.types.TestResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                if (message.testEngineVersion != null && message.hasOwnProperty("testEngineVersion"))
                    if (!$util.isString(message.testEngineVersion))
                        return "testEngineVersion: string expected";
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.metamoto.types.TestResult.Result.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                if (message.statistics != null && message.hasOwnProperty("statistics")) {
                    var error = $root.metamoto.types.TestResult.Statistics.verify(message.statistics);
                    if (error)
                        return "statistics." + error;
                }
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i) {
                        var error = $root.metamoto.types.TestResult.DataBusTopic.verify(message.topics[i]);
                        if (error)
                            return "topics." + error;
                    }
                }
                if (message.testCaseFile != null && message.hasOwnProperty("testCaseFile"))
                    if (!$util.isString(message.testCaseFile))
                        return "testCaseFile: string expected";
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    if (!$util.isString(message.logFile))
                        return "logFile: string expected";
                if (message.intersectionSeriesLogFile != null && message.hasOwnProperty("intersectionSeriesLogFile"))
                    if (!$util.isString(message.intersectionSeriesLogFile))
                        return "intersectionSeriesLogFile: string expected";
                if (message.transformsDirectory != null && message.hasOwnProperty("transformsDirectory"))
                    if (!$util.isString(message.transformsDirectory))
                        return "transformsDirectory: string expected";
                if (message.dataStreamsDirectory != null && message.hasOwnProperty("dataStreamsDirectory"))
                    if (!$util.isString(message.dataStreamsDirectory))
                        return "dataStreamsDirectory: string expected";
                if (message.finalViewsDirectory != null && message.hasOwnProperty("finalViewsDirectory"))
                    if (!$util.isString(message.finalViewsDirectory))
                        return "finalViewsDirectory: string expected";
                if (message.dataBusDirectory != null && message.hasOwnProperty("dataBusDirectory"))
                    if (!$util.isString(message.dataBusDirectory))
                        return "dataBusDirectory: string expected";
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle")) {
                    var error = $root.metamoto.types.TestResult.Vehicle.verify(message.egoVehicle);
                    if (error)
                        return "egoVehicle." + error;
                }
                if (message.vehicles != null && message.hasOwnProperty("vehicles")) {
                    if (!Array.isArray(message.vehicles))
                        return "vehicles: array expected";
                    for (var i = 0; i < message.vehicles.length; ++i) {
                        var error = $root.metamoto.types.TestResult.Vehicle.verify(message.vehicles[i]);
                        if (error)
                            return "vehicles." + error;
                    }
                }
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians")) {
                    if (!Array.isArray(message.pedestrians))
                        return "pedestrians: array expected";
                    for (var i = 0; i < message.pedestrians.length; ++i) {
                        var error = $root.metamoto.types.TestResult.Pedestrian.verify(message.pedestrians[i]);
                        if (error)
                            return "pedestrians." + error;
                    }
                }
                if (message.finalViewFiles != null && message.hasOwnProperty("finalViewFiles")) {
                    if (!Array.isArray(message.finalViewFiles))
                        return "finalViewFiles: array expected";
                    for (var i = 0; i < message.finalViewFiles.length; ++i)
                        if (!$util.isString(message.finalViewFiles[i]))
                            return "finalViewFiles: string[] expected";
                }
                if (message.dataStreams != null && message.hasOwnProperty("dataStreams")) {
                    if (!Array.isArray(message.dataStreams))
                        return "dataStreams: array expected";
                    for (var i = 0; i < message.dataStreams.length; ++i) {
                        var error = $root.metamoto.types.TestResult.DataStream.verify(message.dataStreams[i]);
                        if (error)
                            return "dataStreams." + error;
                    }
                }
                if (message.assets != null && message.hasOwnProperty("assets")) {
                    if (!Array.isArray(message.assets))
                        return "assets: array expected";
                    for (var i = 0; i < message.assets.length; ++i) {
                        var error = $root.metamoto.types.Asset.verify(message.assets[i]);
                        if (error)
                            return "assets." + error;
                    }
                }
                if (message.egoVehicles != null && message.hasOwnProperty("egoVehicles")) {
                    if (!Array.isArray(message.egoVehicles))
                        return "egoVehicles: array expected";
                    for (var i = 0; i < message.egoVehicles.length; ++i) {
                        var error = $root.metamoto.types.TestResult.Vehicle.verify(message.egoVehicles[i]);
                        if (error)
                            return "egoVehicles." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestResult} TestResult
             */
            TestResult.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestResult)
                    return object;
                var message = new $root.metamoto.types.TestResult();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                if (object.testEngineVersion != null)
                    message.testEngineVersion = String(object.testEngineVersion);
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".metamoto.types.TestResult.result: object expected");
                    message.result = $root.metamoto.types.TestResult.Result.fromObject(object.result);
                }
                if (object.statistics != null) {
                    if (typeof object.statistics !== "object")
                        throw TypeError(".metamoto.types.TestResult.statistics: object expected");
                    message.statistics = $root.metamoto.types.TestResult.Statistics.fromObject(object.statistics);
                }
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".metamoto.types.TestResult.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i) {
                        if (typeof object.topics[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.topics: object expected");
                        message.topics[i] = $root.metamoto.types.TestResult.DataBusTopic.fromObject(object.topics[i]);
                    }
                }
                if (object.testCaseFile != null)
                    message.testCaseFile = String(object.testCaseFile);
                if (object.logFile != null)
                    message.logFile = String(object.logFile);
                if (object.intersectionSeriesLogFile != null)
                    message.intersectionSeriesLogFile = String(object.intersectionSeriesLogFile);
                if (object.transformsDirectory != null)
                    message.transformsDirectory = String(object.transformsDirectory);
                if (object.dataStreamsDirectory != null)
                    message.dataStreamsDirectory = String(object.dataStreamsDirectory);
                if (object.finalViewsDirectory != null)
                    message.finalViewsDirectory = String(object.finalViewsDirectory);
                if (object.dataBusDirectory != null)
                    message.dataBusDirectory = String(object.dataBusDirectory);
                if (object.egoVehicle != null) {
                    if (typeof object.egoVehicle !== "object")
                        throw TypeError(".metamoto.types.TestResult.egoVehicle: object expected");
                    message.egoVehicle = $root.metamoto.types.TestResult.Vehicle.fromObject(object.egoVehicle);
                }
                if (object.vehicles) {
                    if (!Array.isArray(object.vehicles))
                        throw TypeError(".metamoto.types.TestResult.vehicles: array expected");
                    message.vehicles = [];
                    for (var i = 0; i < object.vehicles.length; ++i) {
                        if (typeof object.vehicles[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.vehicles: object expected");
                        message.vehicles[i] = $root.metamoto.types.TestResult.Vehicle.fromObject(object.vehicles[i]);
                    }
                }
                if (object.pedestrians) {
                    if (!Array.isArray(object.pedestrians))
                        throw TypeError(".metamoto.types.TestResult.pedestrians: array expected");
                    message.pedestrians = [];
                    for (var i = 0; i < object.pedestrians.length; ++i) {
                        if (typeof object.pedestrians[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.pedestrians: object expected");
                        message.pedestrians[i] = $root.metamoto.types.TestResult.Pedestrian.fromObject(object.pedestrians[i]);
                    }
                }
                if (object.finalViewFiles) {
                    if (!Array.isArray(object.finalViewFiles))
                        throw TypeError(".metamoto.types.TestResult.finalViewFiles: array expected");
                    message.finalViewFiles = [];
                    for (var i = 0; i < object.finalViewFiles.length; ++i)
                        message.finalViewFiles[i] = String(object.finalViewFiles[i]);
                }
                if (object.dataStreams) {
                    if (!Array.isArray(object.dataStreams))
                        throw TypeError(".metamoto.types.TestResult.dataStreams: array expected");
                    message.dataStreams = [];
                    for (var i = 0; i < object.dataStreams.length; ++i) {
                        if (typeof object.dataStreams[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.dataStreams: object expected");
                        message.dataStreams[i] = $root.metamoto.types.TestResult.DataStream.fromObject(object.dataStreams[i]);
                    }
                }
                if (object.assets) {
                    if (!Array.isArray(object.assets))
                        throw TypeError(".metamoto.types.TestResult.assets: array expected");
                    message.assets = [];
                    for (var i = 0; i < object.assets.length; ++i) {
                        if (typeof object.assets[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.assets: object expected");
                        message.assets[i] = $root.metamoto.types.Asset.fromObject(object.assets[i]);
                    }
                }
                if (object.egoVehicles) {
                    if (!Array.isArray(object.egoVehicles))
                        throw TypeError(".metamoto.types.TestResult.egoVehicles: array expected");
                    message.egoVehicles = [];
                    for (var i = 0; i < object.egoVehicles.length; ++i) {
                        if (typeof object.egoVehicles[i] !== "object")
                            throw TypeError(".metamoto.types.TestResult.egoVehicles: object expected");
                        message.egoVehicles[i] = $root.metamoto.types.TestResult.Vehicle.fromObject(object.egoVehicles[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TestResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestResult
             * @static
             * @param {metamoto.types.TestResult} message TestResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.topics = [];
                    object.vehicles = [];
                    object.pedestrians = [];
                    object.finalViewFiles = [];
                    object.dataStreams = [];
                    object.assets = [];
                    object.egoVehicles = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.timestamp = "";
                    object.testEngineVersion = "";
                    object.result = null;
                    object.statistics = null;
                    object.testCaseFile = "";
                    object.logFile = "";
                    object.intersectionSeriesLogFile = "";
                    object.transformsDirectory = "";
                    object.dataStreamsDirectory = "";
                    object.finalViewsDirectory = "";
                    object.dataBusDirectory = "";
                    object.egoVehicle = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                if (message.testEngineVersion != null && message.hasOwnProperty("testEngineVersion"))
                    object.testEngineVersion = message.testEngineVersion;
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.metamoto.types.TestResult.Result.toObject(message.result, options);
                if (message.statistics != null && message.hasOwnProperty("statistics"))
                    object.statistics = $root.metamoto.types.TestResult.Statistics.toObject(message.statistics, options);
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = $root.metamoto.types.TestResult.DataBusTopic.toObject(message.topics[j], options);
                }
                if (message.testCaseFile != null && message.hasOwnProperty("testCaseFile"))
                    object.testCaseFile = message.testCaseFile;
                if (message.logFile != null && message.hasOwnProperty("logFile"))
                    object.logFile = message.logFile;
                if (message.intersectionSeriesLogFile != null && message.hasOwnProperty("intersectionSeriesLogFile"))
                    object.intersectionSeriesLogFile = message.intersectionSeriesLogFile;
                if (message.transformsDirectory != null && message.hasOwnProperty("transformsDirectory"))
                    object.transformsDirectory = message.transformsDirectory;
                if (message.dataStreamsDirectory != null && message.hasOwnProperty("dataStreamsDirectory"))
                    object.dataStreamsDirectory = message.dataStreamsDirectory;
                if (message.finalViewsDirectory != null && message.hasOwnProperty("finalViewsDirectory"))
                    object.finalViewsDirectory = message.finalViewsDirectory;
                if (message.dataBusDirectory != null && message.hasOwnProperty("dataBusDirectory"))
                    object.dataBusDirectory = message.dataBusDirectory;
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    object.egoVehicle = $root.metamoto.types.TestResult.Vehicle.toObject(message.egoVehicle, options);
                if (message.vehicles && message.vehicles.length) {
                    object.vehicles = [];
                    for (var j = 0; j < message.vehicles.length; ++j)
                        object.vehicles[j] = $root.metamoto.types.TestResult.Vehicle.toObject(message.vehicles[j], options);
                }
                if (message.pedestrians && message.pedestrians.length) {
                    object.pedestrians = [];
                    for (var j = 0; j < message.pedestrians.length; ++j)
                        object.pedestrians[j] = $root.metamoto.types.TestResult.Pedestrian.toObject(message.pedestrians[j], options);
                }
                if (message.finalViewFiles && message.finalViewFiles.length) {
                    object.finalViewFiles = [];
                    for (var j = 0; j < message.finalViewFiles.length; ++j)
                        object.finalViewFiles[j] = message.finalViewFiles[j];
                }
                if (message.dataStreams && message.dataStreams.length) {
                    object.dataStreams = [];
                    for (var j = 0; j < message.dataStreams.length; ++j)
                        object.dataStreams[j] = $root.metamoto.types.TestResult.DataStream.toObject(message.dataStreams[j], options);
                }
                if (message.assets && message.assets.length) {
                    object.assets = [];
                    for (var j = 0; j < message.assets.length; ++j)
                        object.assets[j] = $root.metamoto.types.Asset.toObject(message.assets[j], options);
                }
                if (message.egoVehicles && message.egoVehicles.length) {
                    object.egoVehicles = [];
                    for (var j = 0; j < message.egoVehicles.length; ++j)
                        object.egoVehicles[j] = $root.metamoto.types.TestResult.Vehicle.toObject(message.egoVehicles[j], options);
                }
                return object;
            };

            /**
             * Converts this TestResult to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Status enum.
             * @name metamoto.types.TestResult.Status
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} PASS=2 PASS value
             * @property {number} FAIL=3 FAIL value
             * @property {number} STOP=4 STOP value
             * @property {number} ERROR=5 ERROR value
             * @property {number} PENDING=6 PENDING value
             * @property {number} RUNNING=7 RUNNING value
             * @property {number} STOPPING=8 STOPPING value
             * @property {number} POST_PROCESSING=9 POST_PROCESSING value
             */
            TestResult.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "PASS"] = 2;
                values[valuesById[3] = "FAIL"] = 3;
                values[valuesById[4] = "STOP"] = 4;
                values[valuesById[5] = "ERROR"] = 5;
                values[valuesById[6] = "PENDING"] = 6;
                values[valuesById[7] = "RUNNING"] = 7;
                values[valuesById[8] = "STOPPING"] = 8;
                values[valuesById[9] = "POST_PROCESSING"] = 9;
                return values;
            })();

            TestResult.Result = (function() {

                /**
                 * Properties of a Result.
                 * @memberof metamoto.types.TestResult
                 * @interface IResult
                 * @property {metamoto.types.TestResult.Status|null} [status] Result status
                 * @property {string|null} [reason] Result reason
                 */

                /**
                 * Constructs a new Result.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a Result.
                 * @implements IResult
                 * @constructor
                 * @param {metamoto.types.TestResult.IResult=} [properties] Properties to set
                 */
                function Result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Result status.
                 * @member {metamoto.types.TestResult.Status} status
                 * @memberof metamoto.types.TestResult.Result
                 * @instance
                 */
                Result.prototype.status = 0;

                /**
                 * Result reason.
                 * @member {string} reason
                 * @memberof metamoto.types.TestResult.Result
                 * @instance
                 */
                Result.prototype.reason = "";

                /**
                 * Creates a new Result instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {metamoto.types.TestResult.IResult=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.Result} Result instance
                 */
                Result.create = function create(properties) {
                    return new Result(properties);
                };

                /**
                 * Encodes the specified Result message. Does not implicitly {@link metamoto.types.TestResult.Result.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {metamoto.types.TestResult.IResult} message Result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                    return writer;
                };

                /**
                 * Encodes the specified Result message, length delimited. Does not implicitly {@link metamoto.types.TestResult.Result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {metamoto.types.TestResult.IResult} message Result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Result message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.Result} Result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.Result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.reason = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.Result} Result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Result message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    return null;
                };

                /**
                 * Creates a Result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.Result} Result
                 */
                Result.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.Result)
                        return object;
                    var message = new $root.metamoto.types.TestResult.Result();
                    switch (object.status) {
                    case "UNKNOWN":
                    case 0:
                        message.status = 0;
                        break;
                    case "OTHER":
                    case 1:
                        message.status = 1;
                        break;
                    case "PASS":
                    case 2:
                        message.status = 2;
                        break;
                    case "FAIL":
                    case 3:
                        message.status = 3;
                        break;
                    case "STOP":
                    case 4:
                        message.status = 4;
                        break;
                    case "ERROR":
                    case 5:
                        message.status = 5;
                        break;
                    case "PENDING":
                    case 6:
                        message.status = 6;
                        break;
                    case "RUNNING":
                    case 7:
                        message.status = 7;
                        break;
                    case "STOPPING":
                    case 8:
                        message.status = 8;
                        break;
                    case "POST_PROCESSING":
                    case 9:
                        message.status = 9;
                        break;
                    }
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    return message;
                };

                /**
                 * Creates a plain object from a Result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.Result
                 * @static
                 * @param {metamoto.types.TestResult.Result} message Result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.status = options.enums === String ? "UNKNOWN" : 0;
                        object.reason = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.metamoto.types.TestResult.Status[message.status] : message.status;
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    return object;
                };

                /**
                 * Converts this Result to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.Result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Result;
            })();

            TestResult.Statistics = (function() {

                /**
                 * Properties of a Statistics.
                 * @memberof metamoto.types.TestResult
                 * @interface IStatistics
                 * @property {number|null} [simulationTime] Statistics simulationTime
                 * @property {number|null} [realTime] Statistics realTime
                 * @property {number|null} [renderFrameRate] Statistics renderFrameRate
                 * @property {number|null} [physicsFrameRate] Statistics physicsFrameRate
                 */

                /**
                 * Constructs a new Statistics.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a Statistics.
                 * @implements IStatistics
                 * @constructor
                 * @param {metamoto.types.TestResult.IStatistics=} [properties] Properties to set
                 */
                function Statistics(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Statistics simulationTime.
                 * @member {number} simulationTime
                 * @memberof metamoto.types.TestResult.Statistics
                 * @instance
                 */
                Statistics.prototype.simulationTime = 0;

                /**
                 * Statistics realTime.
                 * @member {number} realTime
                 * @memberof metamoto.types.TestResult.Statistics
                 * @instance
                 */
                Statistics.prototype.realTime = 0;

                /**
                 * Statistics renderFrameRate.
                 * @member {number} renderFrameRate
                 * @memberof metamoto.types.TestResult.Statistics
                 * @instance
                 */
                Statistics.prototype.renderFrameRate = 0;

                /**
                 * Statistics physicsFrameRate.
                 * @member {number} physicsFrameRate
                 * @memberof metamoto.types.TestResult.Statistics
                 * @instance
                 */
                Statistics.prototype.physicsFrameRate = 0;

                /**
                 * Creates a new Statistics instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {metamoto.types.TestResult.IStatistics=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.Statistics} Statistics instance
                 */
                Statistics.create = function create(properties) {
                    return new Statistics(properties);
                };

                /**
                 * Encodes the specified Statistics message. Does not implicitly {@link metamoto.types.TestResult.Statistics.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {metamoto.types.TestResult.IStatistics} message Statistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Statistics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.simulationTime != null && message.hasOwnProperty("simulationTime"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.simulationTime);
                    if (message.realTime != null && message.hasOwnProperty("realTime"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.realTime);
                    if (message.renderFrameRate != null && message.hasOwnProperty("renderFrameRate"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.renderFrameRate);
                    if (message.physicsFrameRate != null && message.hasOwnProperty("physicsFrameRate"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.physicsFrameRate);
                    return writer;
                };

                /**
                 * Encodes the specified Statistics message, length delimited. Does not implicitly {@link metamoto.types.TestResult.Statistics.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {metamoto.types.TestResult.IStatistics} message Statistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Statistics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Statistics message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.Statistics} Statistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Statistics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.Statistics();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.simulationTime = reader.float();
                            break;
                        case 2:
                            message.realTime = reader.float();
                            break;
                        case 3:
                            message.renderFrameRate = reader.float();
                            break;
                        case 4:
                            message.physicsFrameRate = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Statistics message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.Statistics} Statistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Statistics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Statistics message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Statistics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.simulationTime != null && message.hasOwnProperty("simulationTime"))
                        if (typeof message.simulationTime !== "number")
                            return "simulationTime: number expected";
                    if (message.realTime != null && message.hasOwnProperty("realTime"))
                        if (typeof message.realTime !== "number")
                            return "realTime: number expected";
                    if (message.renderFrameRate != null && message.hasOwnProperty("renderFrameRate"))
                        if (typeof message.renderFrameRate !== "number")
                            return "renderFrameRate: number expected";
                    if (message.physicsFrameRate != null && message.hasOwnProperty("physicsFrameRate"))
                        if (typeof message.physicsFrameRate !== "number")
                            return "physicsFrameRate: number expected";
                    return null;
                };

                /**
                 * Creates a Statistics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.Statistics} Statistics
                 */
                Statistics.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.Statistics)
                        return object;
                    var message = new $root.metamoto.types.TestResult.Statistics();
                    if (object.simulationTime != null)
                        message.simulationTime = Number(object.simulationTime);
                    if (object.realTime != null)
                        message.realTime = Number(object.realTime);
                    if (object.renderFrameRate != null)
                        message.renderFrameRate = Number(object.renderFrameRate);
                    if (object.physicsFrameRate != null)
                        message.physicsFrameRate = Number(object.physicsFrameRate);
                    return message;
                };

                /**
                 * Creates a plain object from a Statistics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.Statistics
                 * @static
                 * @param {metamoto.types.TestResult.Statistics} message Statistics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Statistics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.simulationTime = 0;
                        object.realTime = 0;
                        object.renderFrameRate = 0;
                        object.physicsFrameRate = 0;
                    }
                    if (message.simulationTime != null && message.hasOwnProperty("simulationTime"))
                        object.simulationTime = options.json && !isFinite(message.simulationTime) ? String(message.simulationTime) : message.simulationTime;
                    if (message.realTime != null && message.hasOwnProperty("realTime"))
                        object.realTime = options.json && !isFinite(message.realTime) ? String(message.realTime) : message.realTime;
                    if (message.renderFrameRate != null && message.hasOwnProperty("renderFrameRate"))
                        object.renderFrameRate = options.json && !isFinite(message.renderFrameRate) ? String(message.renderFrameRate) : message.renderFrameRate;
                    if (message.physicsFrameRate != null && message.hasOwnProperty("physicsFrameRate"))
                        object.physicsFrameRate = options.json && !isFinite(message.physicsFrameRate) ? String(message.physicsFrameRate) : message.physicsFrameRate;
                    return object;
                };

                /**
                 * Converts this Statistics to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.Statistics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Statistics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Statistics;
            })();

            TestResult.DataBusTopic = (function() {

                /**
                 * Properties of a DataBusTopic.
                 * @memberof metamoto.types.TestResult
                 * @interface IDataBusTopic
                 * @property {string|null} [name] DataBusTopic name
                 * @property {string|null} [messageFile] DataBusTopic messageFile
                 */

                /**
                 * Constructs a new DataBusTopic.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a DataBusTopic.
                 * @implements IDataBusTopic
                 * @constructor
                 * @param {metamoto.types.TestResult.IDataBusTopic=} [properties] Properties to set
                 */
                function DataBusTopic(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DataBusTopic name.
                 * @member {string} name
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @instance
                 */
                DataBusTopic.prototype.name = "";

                /**
                 * DataBusTopic messageFile.
                 * @member {string} messageFile
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @instance
                 */
                DataBusTopic.prototype.messageFile = "";

                /**
                 * Creates a new DataBusTopic instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {metamoto.types.TestResult.IDataBusTopic=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.DataBusTopic} DataBusTopic instance
                 */
                DataBusTopic.create = function create(properties) {
                    return new DataBusTopic(properties);
                };

                /**
                 * Encodes the specified DataBusTopic message. Does not implicitly {@link metamoto.types.TestResult.DataBusTopic.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {metamoto.types.TestResult.IDataBusTopic} message DataBusTopic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBusTopic.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.messageFile != null && message.hasOwnProperty("messageFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageFile);
                    return writer;
                };

                /**
                 * Encodes the specified DataBusTopic message, length delimited. Does not implicitly {@link metamoto.types.TestResult.DataBusTopic.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {metamoto.types.TestResult.IDataBusTopic} message DataBusTopic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBusTopic.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DataBusTopic message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.DataBusTopic} DataBusTopic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBusTopic.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.DataBusTopic();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.messageFile = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DataBusTopic message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.DataBusTopic} DataBusTopic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBusTopic.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DataBusTopic message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DataBusTopic.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.messageFile != null && message.hasOwnProperty("messageFile"))
                        if (!$util.isString(message.messageFile))
                            return "messageFile: string expected";
                    return null;
                };

                /**
                 * Creates a DataBusTopic message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.DataBusTopic} DataBusTopic
                 */
                DataBusTopic.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.DataBusTopic)
                        return object;
                    var message = new $root.metamoto.types.TestResult.DataBusTopic();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.messageFile != null)
                        message.messageFile = String(object.messageFile);
                    return message;
                };

                /**
                 * Creates a plain object from a DataBusTopic message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @static
                 * @param {metamoto.types.TestResult.DataBusTopic} message DataBusTopic
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataBusTopic.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.messageFile = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.messageFile != null && message.hasOwnProperty("messageFile"))
                        object.messageFile = message.messageFile;
                    return object;
                };

                /**
                 * Converts this DataBusTopic to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.DataBusTopic
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DataBusTopic.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DataBusTopic;
            })();

            TestResult.Vehicle = (function() {

                /**
                 * Properties of a Vehicle.
                 * @memberof metamoto.types.TestResult
                 * @interface IVehicle
                 * @property {metamoto.types.IVehicleInstance|null} [instance] Vehicle instance
                 * @property {string|null} [transformsFile] Vehicle transformsFile
                 * @property {metamoto.types.IPose|null} [pose] Vehicle pose
                 * @property {Array.<metamoto.types.TestResult.Vehicle.IBinary>|null} [binaries] Vehicle binaries
                 * @property {Array.<metamoto.types.ISensorMount>|null} [sensorMounts] Vehicle sensorMounts
                 * @property {string|null} [id] Vehicle id
                 * @property {string|null} [resultsDirectory] Vehicle resultsDirectory
                 * @property {Array.<metamoto.types.TestResult.IDataBusTopic>|null} [topics] Vehicle topics
                 * @property {Array.<metamoto.types.TestResult.IDataStream>|null} [dataStreams] Vehicle dataStreams
                 * @property {string|null} [visualizationsFile] Vehicle visualizationsFile
                 */

                /**
                 * Constructs a new Vehicle.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a Vehicle.
                 * @implements IVehicle
                 * @constructor
                 * @param {metamoto.types.TestResult.IVehicle=} [properties] Properties to set
                 */
                function Vehicle(properties) {
                    this.binaries = [];
                    this.sensorMounts = [];
                    this.topics = [];
                    this.dataStreams = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Vehicle instance.
                 * @member {metamoto.types.IVehicleInstance|null|undefined} instance
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.instance = null;

                /**
                 * Vehicle transformsFile.
                 * @member {string} transformsFile
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.transformsFile = "";

                /**
                 * Vehicle pose.
                 * @member {metamoto.types.IPose|null|undefined} pose
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.pose = null;

                /**
                 * Vehicle binaries.
                 * @member {Array.<metamoto.types.TestResult.Vehicle.IBinary>} binaries
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.binaries = $util.emptyArray;

                /**
                 * Vehicle sensorMounts.
                 * @member {Array.<metamoto.types.ISensorMount>} sensorMounts
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.sensorMounts = $util.emptyArray;

                /**
                 * Vehicle id.
                 * @member {string} id
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.id = "";

                /**
                 * Vehicle resultsDirectory.
                 * @member {string} resultsDirectory
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.resultsDirectory = "";

                /**
                 * Vehicle topics.
                 * @member {Array.<metamoto.types.TestResult.IDataBusTopic>} topics
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.topics = $util.emptyArray;

                /**
                 * Vehicle dataStreams.
                 * @member {Array.<metamoto.types.TestResult.IDataStream>} dataStreams
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.dataStreams = $util.emptyArray;

                /**
                 * Vehicle visualizationsFile.
                 * @member {string} visualizationsFile
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 */
                Vehicle.prototype.visualizationsFile = "";

                /**
                 * Creates a new Vehicle instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {metamoto.types.TestResult.IVehicle=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.Vehicle} Vehicle instance
                 */
                Vehicle.create = function create(properties) {
                    return new Vehicle(properties);
                };

                /**
                 * Encodes the specified Vehicle message. Does not implicitly {@link metamoto.types.TestResult.Vehicle.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {metamoto.types.TestResult.IVehicle} message Vehicle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Vehicle.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.instance != null && message.hasOwnProperty("instance"))
                        $root.metamoto.types.VehicleInstance.encode(message.instance, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.transformsFile);
                    if (message.pose != null && message.hasOwnProperty("pose"))
                        $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.binaries != null && message.binaries.length)
                        for (var i = 0; i < message.binaries.length; ++i)
                            $root.metamoto.types.TestResult.Vehicle.Binary.encode(message.binaries[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.sensorMounts != null && message.sensorMounts.length)
                        for (var i = 0; i < message.sensorMounts.length; ++i)
                            $root.metamoto.types.SensorMount.encode(message.sensorMounts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.id);
                    if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.resultsDirectory);
                    if (message.topics != null && message.topics.length)
                        for (var i = 0; i < message.topics.length; ++i)
                            $root.metamoto.types.TestResult.DataBusTopic.encode(message.topics[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.dataStreams != null && message.dataStreams.length)
                        for (var i = 0; i < message.dataStreams.length; ++i)
                            $root.metamoto.types.TestResult.DataStream.encode(message.dataStreams[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.visualizationsFile != null && message.hasOwnProperty("visualizationsFile"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.visualizationsFile);
                    return writer;
                };

                /**
                 * Encodes the specified Vehicle message, length delimited. Does not implicitly {@link metamoto.types.TestResult.Vehicle.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {metamoto.types.TestResult.IVehicle} message Vehicle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Vehicle.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Vehicle message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.Vehicle} Vehicle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Vehicle.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.Vehicle();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.instance = $root.metamoto.types.VehicleInstance.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.transformsFile = reader.string();
                            break;
                        case 3:
                            message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.binaries && message.binaries.length))
                                message.binaries = [];
                            message.binaries.push($root.metamoto.types.TestResult.Vehicle.Binary.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.sensorMounts && message.sensorMounts.length))
                                message.sensorMounts = [];
                            message.sensorMounts.push($root.metamoto.types.SensorMount.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.id = reader.string();
                            break;
                        case 7:
                            message.resultsDirectory = reader.string();
                            break;
                        case 8:
                            if (!(message.topics && message.topics.length))
                                message.topics = [];
                            message.topics.push($root.metamoto.types.TestResult.DataBusTopic.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            if (!(message.dataStreams && message.dataStreams.length))
                                message.dataStreams = [];
                            message.dataStreams.push($root.metamoto.types.TestResult.DataStream.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            message.visualizationsFile = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Vehicle message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.Vehicle} Vehicle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Vehicle.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Vehicle message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Vehicle.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.instance != null && message.hasOwnProperty("instance")) {
                        var error = $root.metamoto.types.VehicleInstance.verify(message.instance);
                        if (error)
                            return "instance." + error;
                    }
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        if (!$util.isString(message.transformsFile))
                            return "transformsFile: string expected";
                    if (message.pose != null && message.hasOwnProperty("pose")) {
                        var error = $root.metamoto.types.Pose.verify(message.pose);
                        if (error)
                            return "pose." + error;
                    }
                    if (message.binaries != null && message.hasOwnProperty("binaries")) {
                        if (!Array.isArray(message.binaries))
                            return "binaries: array expected";
                        for (var i = 0; i < message.binaries.length; ++i) {
                            var error = $root.metamoto.types.TestResult.Vehicle.Binary.verify(message.binaries[i]);
                            if (error)
                                return "binaries." + error;
                        }
                    }
                    if (message.sensorMounts != null && message.hasOwnProperty("sensorMounts")) {
                        if (!Array.isArray(message.sensorMounts))
                            return "sensorMounts: array expected";
                        for (var i = 0; i < message.sensorMounts.length; ++i) {
                            var error = $root.metamoto.types.SensorMount.verify(message.sensorMounts[i]);
                            if (error)
                                return "sensorMounts." + error;
                        }
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                        if (!$util.isString(message.resultsDirectory))
                            return "resultsDirectory: string expected";
                    if (message.topics != null && message.hasOwnProperty("topics")) {
                        if (!Array.isArray(message.topics))
                            return "topics: array expected";
                        for (var i = 0; i < message.topics.length; ++i) {
                            var error = $root.metamoto.types.TestResult.DataBusTopic.verify(message.topics[i]);
                            if (error)
                                return "topics." + error;
                        }
                    }
                    if (message.dataStreams != null && message.hasOwnProperty("dataStreams")) {
                        if (!Array.isArray(message.dataStreams))
                            return "dataStreams: array expected";
                        for (var i = 0; i < message.dataStreams.length; ++i) {
                            var error = $root.metamoto.types.TestResult.DataStream.verify(message.dataStreams[i]);
                            if (error)
                                return "dataStreams." + error;
                        }
                    }
                    if (message.visualizationsFile != null && message.hasOwnProperty("visualizationsFile"))
                        if (!$util.isString(message.visualizationsFile))
                            return "visualizationsFile: string expected";
                    return null;
                };

                /**
                 * Creates a Vehicle message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.Vehicle} Vehicle
                 */
                Vehicle.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.Vehicle)
                        return object;
                    var message = new $root.metamoto.types.TestResult.Vehicle();
                    if (object.instance != null) {
                        if (typeof object.instance !== "object")
                            throw TypeError(".metamoto.types.TestResult.Vehicle.instance: object expected");
                        message.instance = $root.metamoto.types.VehicleInstance.fromObject(object.instance);
                    }
                    if (object.transformsFile != null)
                        message.transformsFile = String(object.transformsFile);
                    if (object.pose != null) {
                        if (typeof object.pose !== "object")
                            throw TypeError(".metamoto.types.TestResult.Vehicle.pose: object expected");
                        message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                    }
                    if (object.binaries) {
                        if (!Array.isArray(object.binaries))
                            throw TypeError(".metamoto.types.TestResult.Vehicle.binaries: array expected");
                        message.binaries = [];
                        for (var i = 0; i < object.binaries.length; ++i) {
                            if (typeof object.binaries[i] !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.binaries: object expected");
                            message.binaries[i] = $root.metamoto.types.TestResult.Vehicle.Binary.fromObject(object.binaries[i]);
                        }
                    }
                    if (object.sensorMounts) {
                        if (!Array.isArray(object.sensorMounts))
                            throw TypeError(".metamoto.types.TestResult.Vehicle.sensorMounts: array expected");
                        message.sensorMounts = [];
                        for (var i = 0; i < object.sensorMounts.length; ++i) {
                            if (typeof object.sensorMounts[i] !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.sensorMounts: object expected");
                            message.sensorMounts[i] = $root.metamoto.types.SensorMount.fromObject(object.sensorMounts[i]);
                        }
                    }
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.resultsDirectory != null)
                        message.resultsDirectory = String(object.resultsDirectory);
                    if (object.topics) {
                        if (!Array.isArray(object.topics))
                            throw TypeError(".metamoto.types.TestResult.Vehicle.topics: array expected");
                        message.topics = [];
                        for (var i = 0; i < object.topics.length; ++i) {
                            if (typeof object.topics[i] !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.topics: object expected");
                            message.topics[i] = $root.metamoto.types.TestResult.DataBusTopic.fromObject(object.topics[i]);
                        }
                    }
                    if (object.dataStreams) {
                        if (!Array.isArray(object.dataStreams))
                            throw TypeError(".metamoto.types.TestResult.Vehicle.dataStreams: array expected");
                        message.dataStreams = [];
                        for (var i = 0; i < object.dataStreams.length; ++i) {
                            if (typeof object.dataStreams[i] !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.dataStreams: object expected");
                            message.dataStreams[i] = $root.metamoto.types.TestResult.DataStream.fromObject(object.dataStreams[i]);
                        }
                    }
                    if (object.visualizationsFile != null)
                        message.visualizationsFile = String(object.visualizationsFile);
                    return message;
                };

                /**
                 * Creates a plain object from a Vehicle message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @static
                 * @param {metamoto.types.TestResult.Vehicle} message Vehicle
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Vehicle.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.binaries = [];
                        object.sensorMounts = [];
                        object.topics = [];
                        object.dataStreams = [];
                    }
                    if (options.defaults) {
                        object.instance = null;
                        object.transformsFile = "";
                        object.pose = null;
                        object.id = "";
                        object.resultsDirectory = "";
                        object.visualizationsFile = "";
                    }
                    if (message.instance != null && message.hasOwnProperty("instance"))
                        object.instance = $root.metamoto.types.VehicleInstance.toObject(message.instance, options);
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        object.transformsFile = message.transformsFile;
                    if (message.pose != null && message.hasOwnProperty("pose"))
                        object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                    if (message.binaries && message.binaries.length) {
                        object.binaries = [];
                        for (var j = 0; j < message.binaries.length; ++j)
                            object.binaries[j] = $root.metamoto.types.TestResult.Vehicle.Binary.toObject(message.binaries[j], options);
                    }
                    if (message.sensorMounts && message.sensorMounts.length) {
                        object.sensorMounts = [];
                        for (var j = 0; j < message.sensorMounts.length; ++j)
                            object.sensorMounts[j] = $root.metamoto.types.SensorMount.toObject(message.sensorMounts[j], options);
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                        object.resultsDirectory = message.resultsDirectory;
                    if (message.topics && message.topics.length) {
                        object.topics = [];
                        for (var j = 0; j < message.topics.length; ++j)
                            object.topics[j] = $root.metamoto.types.TestResult.DataBusTopic.toObject(message.topics[j], options);
                    }
                    if (message.dataStreams && message.dataStreams.length) {
                        object.dataStreams = [];
                        for (var j = 0; j < message.dataStreams.length; ++j)
                            object.dataStreams[j] = $root.metamoto.types.TestResult.DataStream.toObject(message.dataStreams[j], options);
                    }
                    if (message.visualizationsFile != null && message.hasOwnProperty("visualizationsFile"))
                        object.visualizationsFile = message.visualizationsFile;
                    return object;
                };

                /**
                 * Converts this Vehicle to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.Vehicle
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Vehicle.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Vehicle.Binary = (function() {

                    /**
                     * Properties of a Binary.
                     * @memberof metamoto.types.TestResult.Vehicle
                     * @interface IBinary
                     * @property {metamoto.types.IController|null} [controller] Binary controller
                     * @property {metamoto.types.ISensor|null} [sensor] Binary sensor
                     * @property {string|null} [resultsDirectory] Binary resultsDirectory
                     * @property {Array.<metamoto.types.IResultMetadata>|null} [resultsData] Binary resultsData
                     */

                    /**
                     * Constructs a new Binary.
                     * @memberof metamoto.types.TestResult.Vehicle
                     * @classdesc Represents a Binary.
                     * @implements IBinary
                     * @constructor
                     * @param {metamoto.types.TestResult.Vehicle.IBinary=} [properties] Properties to set
                     */
                    function Binary(properties) {
                        this.resultsData = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Binary controller.
                     * @member {metamoto.types.IController|null|undefined} controller
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     */
                    Binary.prototype.controller = null;

                    /**
                     * Binary sensor.
                     * @member {metamoto.types.ISensor|null|undefined} sensor
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     */
                    Binary.prototype.sensor = null;

                    /**
                     * Binary resultsDirectory.
                     * @member {string} resultsDirectory
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     */
                    Binary.prototype.resultsDirectory = "";

                    /**
                     * Binary resultsData.
                     * @member {Array.<metamoto.types.IResultMetadata>} resultsData
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     */
                    Binary.prototype.resultsData = $util.emptyArray;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * Binary typeOneof.
                     * @member {"controller"|"sensor"|undefined} typeOneof
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     */
                    Object.defineProperty(Binary.prototype, "typeOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["controller", "sensor"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Binary instance using the specified properties.
                     * @function create
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {metamoto.types.TestResult.Vehicle.IBinary=} [properties] Properties to set
                     * @returns {metamoto.types.TestResult.Vehicle.Binary} Binary instance
                     */
                    Binary.create = function create(properties) {
                        return new Binary(properties);
                    };

                    /**
                     * Encodes the specified Binary message. Does not implicitly {@link metamoto.types.TestResult.Vehicle.Binary.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {metamoto.types.TestResult.Vehicle.IBinary} message Binary message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Binary.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.controller != null && message.hasOwnProperty("controller"))
                            $root.metamoto.types.Controller.encode(message.controller, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.sensor != null && message.hasOwnProperty("sensor"))
                            $root.metamoto.types.Sensor.encode(message.sensor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.resultsDirectory);
                        if (message.resultsData != null && message.resultsData.length)
                            for (var i = 0; i < message.resultsData.length; ++i)
                                $root.metamoto.types.ResultMetadata.encode(message.resultsData[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Binary message, length delimited. Does not implicitly {@link metamoto.types.TestResult.Vehicle.Binary.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {metamoto.types.TestResult.Vehicle.IBinary} message Binary message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Binary.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Binary message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.types.TestResult.Vehicle.Binary} Binary
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Binary.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.Vehicle.Binary();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.controller = $root.metamoto.types.Controller.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.sensor = $root.metamoto.types.Sensor.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.resultsDirectory = reader.string();
                                break;
                            case 4:
                                if (!(message.resultsData && message.resultsData.length))
                                    message.resultsData = [];
                                message.resultsData.push($root.metamoto.types.ResultMetadata.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Binary message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.types.TestResult.Vehicle.Binary} Binary
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Binary.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Binary message.
                     * @function verify
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Binary.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.controller != null && message.hasOwnProperty("controller")) {
                            properties.typeOneof = 1;
                            {
                                var error = $root.metamoto.types.Controller.verify(message.controller);
                                if (error)
                                    return "controller." + error;
                            }
                        }
                        if (message.sensor != null && message.hasOwnProperty("sensor")) {
                            if (properties.typeOneof === 1)
                                return "typeOneof: multiple values";
                            properties.typeOneof = 1;
                            {
                                var error = $root.metamoto.types.Sensor.verify(message.sensor);
                                if (error)
                                    return "sensor." + error;
                            }
                        }
                        if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                            if (!$util.isString(message.resultsDirectory))
                                return "resultsDirectory: string expected";
                        if (message.resultsData != null && message.hasOwnProperty("resultsData")) {
                            if (!Array.isArray(message.resultsData))
                                return "resultsData: array expected";
                            for (var i = 0; i < message.resultsData.length; ++i) {
                                var error = $root.metamoto.types.ResultMetadata.verify(message.resultsData[i]);
                                if (error)
                                    return "resultsData." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Binary message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.types.TestResult.Vehicle.Binary} Binary
                     */
                    Binary.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.types.TestResult.Vehicle.Binary)
                            return object;
                        var message = new $root.metamoto.types.TestResult.Vehicle.Binary();
                        if (object.controller != null) {
                            if (typeof object.controller !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.Binary.controller: object expected");
                            message.controller = $root.metamoto.types.Controller.fromObject(object.controller);
                        }
                        if (object.sensor != null) {
                            if (typeof object.sensor !== "object")
                                throw TypeError(".metamoto.types.TestResult.Vehicle.Binary.sensor: object expected");
                            message.sensor = $root.metamoto.types.Sensor.fromObject(object.sensor);
                        }
                        if (object.resultsDirectory != null)
                            message.resultsDirectory = String(object.resultsDirectory);
                        if (object.resultsData) {
                            if (!Array.isArray(object.resultsData))
                                throw TypeError(".metamoto.types.TestResult.Vehicle.Binary.resultsData: array expected");
                            message.resultsData = [];
                            for (var i = 0; i < object.resultsData.length; ++i) {
                                if (typeof object.resultsData[i] !== "object")
                                    throw TypeError(".metamoto.types.TestResult.Vehicle.Binary.resultsData: object expected");
                                message.resultsData[i] = $root.metamoto.types.ResultMetadata.fromObject(object.resultsData[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Binary message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @static
                     * @param {metamoto.types.TestResult.Vehicle.Binary} message Binary
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Binary.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.resultsData = [];
                        if (options.defaults)
                            object.resultsDirectory = "";
                        if (message.controller != null && message.hasOwnProperty("controller")) {
                            object.controller = $root.metamoto.types.Controller.toObject(message.controller, options);
                            if (options.oneofs)
                                object.typeOneof = "controller";
                        }
                        if (message.sensor != null && message.hasOwnProperty("sensor")) {
                            object.sensor = $root.metamoto.types.Sensor.toObject(message.sensor, options);
                            if (options.oneofs)
                                object.typeOneof = "sensor";
                        }
                        if (message.resultsDirectory != null && message.hasOwnProperty("resultsDirectory"))
                            object.resultsDirectory = message.resultsDirectory;
                        if (message.resultsData && message.resultsData.length) {
                            object.resultsData = [];
                            for (var j = 0; j < message.resultsData.length; ++j)
                                object.resultsData[j] = $root.metamoto.types.ResultMetadata.toObject(message.resultsData[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Binary to JSON.
                     * @function toJSON
                     * @memberof metamoto.types.TestResult.Vehicle.Binary
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Binary.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Binary;
                })();

                return Vehicle;
            })();

            TestResult.Pedestrian = (function() {

                /**
                 * Properties of a Pedestrian.
                 * @memberof metamoto.types.TestResult
                 * @interface IPedestrian
                 * @property {string|null} [name] Pedestrian name
                 * @property {string|null} [transformsFile] Pedestrian transformsFile
                 */

                /**
                 * Constructs a new Pedestrian.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a Pedestrian.
                 * @implements IPedestrian
                 * @constructor
                 * @param {metamoto.types.TestResult.IPedestrian=} [properties] Properties to set
                 */
                function Pedestrian(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pedestrian name.
                 * @member {string} name
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @instance
                 */
                Pedestrian.prototype.name = "";

                /**
                 * Pedestrian transformsFile.
                 * @member {string} transformsFile
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @instance
                 */
                Pedestrian.prototype.transformsFile = "";

                /**
                 * Creates a new Pedestrian instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {metamoto.types.TestResult.IPedestrian=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.Pedestrian} Pedestrian instance
                 */
                Pedestrian.create = function create(properties) {
                    return new Pedestrian(properties);
                };

                /**
                 * Encodes the specified Pedestrian message. Does not implicitly {@link metamoto.types.TestResult.Pedestrian.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {metamoto.types.TestResult.IPedestrian} message Pedestrian message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pedestrian.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.transformsFile);
                    return writer;
                };

                /**
                 * Encodes the specified Pedestrian message, length delimited. Does not implicitly {@link metamoto.types.TestResult.Pedestrian.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {metamoto.types.TestResult.IPedestrian} message Pedestrian message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pedestrian.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pedestrian message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.Pedestrian} Pedestrian
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pedestrian.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.Pedestrian();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.transformsFile = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Pedestrian message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.Pedestrian} Pedestrian
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pedestrian.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pedestrian message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pedestrian.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        if (!$util.isString(message.transformsFile))
                            return "transformsFile: string expected";
                    return null;
                };

                /**
                 * Creates a Pedestrian message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.Pedestrian} Pedestrian
                 */
                Pedestrian.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.Pedestrian)
                        return object;
                    var message = new $root.metamoto.types.TestResult.Pedestrian();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.transformsFile != null)
                        message.transformsFile = String(object.transformsFile);
                    return message;
                };

                /**
                 * Creates a plain object from a Pedestrian message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @static
                 * @param {metamoto.types.TestResult.Pedestrian} message Pedestrian
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pedestrian.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.transformsFile = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.transformsFile != null && message.hasOwnProperty("transformsFile"))
                        object.transformsFile = message.transformsFile;
                    return object;
                };

                /**
                 * Converts this Pedestrian to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.Pedestrian
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pedestrian.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Pedestrian;
            })();

            TestResult.DataStream = (function() {

                /**
                 * Properties of a DataStream.
                 * @memberof metamoto.types.TestResult
                 * @interface IDataStream
                 * @property {string|null} [name] DataStream name
                 * @property {string|null} [description] DataStream description
                 * @property {string|null} [units] DataStream units
                 * @property {string|null} [filename] DataStream filename
                 */

                /**
                 * Constructs a new DataStream.
                 * @memberof metamoto.types.TestResult
                 * @classdesc Represents a DataStream.
                 * @implements IDataStream
                 * @constructor
                 * @param {metamoto.types.TestResult.IDataStream=} [properties] Properties to set
                 */
                function DataStream(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DataStream name.
                 * @member {string} name
                 * @memberof metamoto.types.TestResult.DataStream
                 * @instance
                 */
                DataStream.prototype.name = "";

                /**
                 * DataStream description.
                 * @member {string} description
                 * @memberof metamoto.types.TestResult.DataStream
                 * @instance
                 */
                DataStream.prototype.description = "";

                /**
                 * DataStream units.
                 * @member {string} units
                 * @memberof metamoto.types.TestResult.DataStream
                 * @instance
                 */
                DataStream.prototype.units = "";

                /**
                 * DataStream filename.
                 * @member {string} filename
                 * @memberof metamoto.types.TestResult.DataStream
                 * @instance
                 */
                DataStream.prototype.filename = "";

                /**
                 * Creates a new DataStream instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {metamoto.types.TestResult.IDataStream=} [properties] Properties to set
                 * @returns {metamoto.types.TestResult.DataStream} DataStream instance
                 */
                DataStream.create = function create(properties) {
                    return new DataStream(properties);
                };

                /**
                 * Encodes the specified DataStream message. Does not implicitly {@link metamoto.types.TestResult.DataStream.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {metamoto.types.TestResult.IDataStream} message DataStream message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataStream.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.units != null && message.hasOwnProperty("units"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.units);
                    if (message.filename != null && message.hasOwnProperty("filename"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.filename);
                    return writer;
                };

                /**
                 * Encodes the specified DataStream message, length delimited. Does not implicitly {@link metamoto.types.TestResult.DataStream.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {metamoto.types.TestResult.IDataStream} message DataStream message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataStream.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DataStream message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.TestResult.DataStream} DataStream
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataStream.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestResult.DataStream();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            message.units = reader.string();
                            break;
                        case 4:
                            message.filename = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DataStream message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.TestResult.DataStream} DataStream
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataStream.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DataStream message.
                 * @function verify
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DataStream.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.units != null && message.hasOwnProperty("units"))
                        if (!$util.isString(message.units))
                            return "units: string expected";
                    if (message.filename != null && message.hasOwnProperty("filename"))
                        if (!$util.isString(message.filename))
                            return "filename: string expected";
                    return null;
                };

                /**
                 * Creates a DataStream message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.TestResult.DataStream} DataStream
                 */
                DataStream.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.TestResult.DataStream)
                        return object;
                    var message = new $root.metamoto.types.TestResult.DataStream();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.units != null)
                        message.units = String(object.units);
                    if (object.filename != null)
                        message.filename = String(object.filename);
                    return message;
                };

                /**
                 * Creates a plain object from a DataStream message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.TestResult.DataStream
                 * @static
                 * @param {metamoto.types.TestResult.DataStream} message DataStream
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataStream.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.description = "";
                        object.units = "";
                        object.filename = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.units != null && message.hasOwnProperty("units"))
                        object.units = message.units;
                    if (message.filename != null && message.hasOwnProperty("filename"))
                        object.filename = message.filename;
                    return object;
                };

                /**
                 * Converts this DataStream to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.TestResult.DataStream
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DataStream.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DataStream;
            })();

            return TestResult;
        })();

        types.TestRun = (function() {

            /**
             * Properties of a TestRun.
             * @memberof metamoto.types
             * @interface ITestRun
             * @property {string|null} [id] TestRun id
             * @property {string|null} [testSuiteId] TestRun testSuiteId
             * @property {string|null} [testSuiteName] TestRun testSuiteName
             * @property {string|null} [startTime] TestRun startTime
             * @property {string|null} [endTime] TestRun endTime
             * @property {metamoto.types.TestResult.Status|null} [status] TestRun status
             * @property {string|null} [resultText] TestRun resultText
             * @property {number|null} [numPassed] TestRun numPassed
             * @property {number|null} [numFailed] TestRun numFailed
             * @property {number|null} [numStopped] TestRun numStopped
             * @property {number|null} [numErrored] TestRun numErrored
             * @property {number|null} [numRunning] TestRun numRunning
             * @property {number|null} [numPending] TestRun numPending
             * @property {number|null} [computeTime] TestRun computeTime
             * @property {string|null} [startedBy] TestRun startedBy
             * @property {number|null} [progress] TestRun progress
             * @property {Array.<metamoto.types.ITestJob>|null} [testJobs] TestRun testJobs
             */

            /**
             * Constructs a new TestRun.
             * @memberof metamoto.types
             * @classdesc Represents a TestRun.
             * @implements ITestRun
             * @constructor
             * @param {metamoto.types.ITestRun=} [properties] Properties to set
             */
            function TestRun(properties) {
                this.testJobs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestRun id.
             * @member {string} id
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.id = "";

            /**
             * TestRun testSuiteId.
             * @member {string} testSuiteId
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.testSuiteId = "";

            /**
             * TestRun testSuiteName.
             * @member {string} testSuiteName
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.testSuiteName = "";

            /**
             * TestRun startTime.
             * @member {string} startTime
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.startTime = "";

            /**
             * TestRun endTime.
             * @member {string} endTime
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.endTime = "";

            /**
             * TestRun status.
             * @member {metamoto.types.TestResult.Status} status
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.status = 0;

            /**
             * TestRun resultText.
             * @member {string} resultText
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.resultText = "";

            /**
             * TestRun numPassed.
             * @member {number} numPassed
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numPassed = 0;

            /**
             * TestRun numFailed.
             * @member {number} numFailed
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numFailed = 0;

            /**
             * TestRun numStopped.
             * @member {number} numStopped
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numStopped = 0;

            /**
             * TestRun numErrored.
             * @member {number} numErrored
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numErrored = 0;

            /**
             * TestRun numRunning.
             * @member {number} numRunning
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numRunning = 0;

            /**
             * TestRun numPending.
             * @member {number} numPending
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.numPending = 0;

            /**
             * TestRun computeTime.
             * @member {number} computeTime
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.computeTime = 0;

            /**
             * TestRun startedBy.
             * @member {string} startedBy
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.startedBy = "";

            /**
             * TestRun progress.
             * @member {number} progress
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.progress = 0;

            /**
             * TestRun testJobs.
             * @member {Array.<metamoto.types.ITestJob>} testJobs
             * @memberof metamoto.types.TestRun
             * @instance
             */
            TestRun.prototype.testJobs = $util.emptyArray;

            /**
             * Creates a new TestRun instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestRun
             * @static
             * @param {metamoto.types.ITestRun=} [properties] Properties to set
             * @returns {metamoto.types.TestRun} TestRun instance
             */
            TestRun.create = function create(properties) {
                return new TestRun(properties);
            };

            /**
             * Encodes the specified TestRun message. Does not implicitly {@link metamoto.types.TestRun.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestRun
             * @static
             * @param {metamoto.types.ITestRun} message TestRun message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestRun.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.testSuiteId != null && message.hasOwnProperty("testSuiteId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.testSuiteId);
                if (message.testSuiteName != null && message.hasOwnProperty("testSuiteName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.testSuiteName);
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.startTime);
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.status);
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.resultText);
                if (message.numPassed != null && message.hasOwnProperty("numPassed"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.numPassed);
                if (message.numFailed != null && message.hasOwnProperty("numFailed"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.numFailed);
                if (message.numStopped != null && message.hasOwnProperty("numStopped"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.numStopped);
                if (message.numErrored != null && message.hasOwnProperty("numErrored"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.numErrored);
                if (message.numRunning != null && message.hasOwnProperty("numRunning"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.numRunning);
                if (message.numPending != null && message.hasOwnProperty("numPending"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.numPending);
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.computeTime);
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.startedBy);
                if (message.progress != null && message.hasOwnProperty("progress"))
                    writer.uint32(/* id 16, wireType 5 =*/133).float(message.progress);
                if (message.testJobs != null && message.testJobs.length)
                    for (var i = 0; i < message.testJobs.length; ++i)
                        $root.metamoto.types.TestJob.encode(message.testJobs[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TestRun message, length delimited. Does not implicitly {@link metamoto.types.TestRun.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestRun
             * @static
             * @param {metamoto.types.ITestRun} message TestRun message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestRun.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestRun message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestRun
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestRun} TestRun
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestRun.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestRun();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.testSuiteId = reader.string();
                        break;
                    case 3:
                        message.testSuiteName = reader.string();
                        break;
                    case 4:
                        message.startTime = reader.string();
                        break;
                    case 5:
                        message.endTime = reader.string();
                        break;
                    case 6:
                        message.status = reader.int32();
                        break;
                    case 7:
                        message.resultText = reader.string();
                        break;
                    case 8:
                        message.numPassed = reader.int32();
                        break;
                    case 9:
                        message.numFailed = reader.int32();
                        break;
                    case 10:
                        message.numStopped = reader.int32();
                        break;
                    case 11:
                        message.numErrored = reader.int32();
                        break;
                    case 12:
                        message.numRunning = reader.int32();
                        break;
                    case 13:
                        message.numPending = reader.int32();
                        break;
                    case 14:
                        message.computeTime = reader.float();
                        break;
                    case 15:
                        message.startedBy = reader.string();
                        break;
                    case 16:
                        message.progress = reader.float();
                        break;
                    case 17:
                        if (!(message.testJobs && message.testJobs.length))
                            message.testJobs = [];
                        message.testJobs.push($root.metamoto.types.TestJob.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestRun message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestRun
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestRun} TestRun
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestRun.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestRun message.
             * @function verify
             * @memberof metamoto.types.TestRun
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestRun.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.testSuiteId != null && message.hasOwnProperty("testSuiteId"))
                    if (!$util.isString(message.testSuiteId))
                        return "testSuiteId: string expected";
                if (message.testSuiteName != null && message.hasOwnProperty("testSuiteName"))
                    if (!$util.isString(message.testSuiteName))
                        return "testSuiteName: string expected";
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isString(message.startTime))
                        return "startTime: string expected";
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (!$util.isString(message.endTime))
                        return "endTime: string expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    if (!$util.isString(message.resultText))
                        return "resultText: string expected";
                if (message.numPassed != null && message.hasOwnProperty("numPassed"))
                    if (!$util.isInteger(message.numPassed))
                        return "numPassed: integer expected";
                if (message.numFailed != null && message.hasOwnProperty("numFailed"))
                    if (!$util.isInteger(message.numFailed))
                        return "numFailed: integer expected";
                if (message.numStopped != null && message.hasOwnProperty("numStopped"))
                    if (!$util.isInteger(message.numStopped))
                        return "numStopped: integer expected";
                if (message.numErrored != null && message.hasOwnProperty("numErrored"))
                    if (!$util.isInteger(message.numErrored))
                        return "numErrored: integer expected";
                if (message.numRunning != null && message.hasOwnProperty("numRunning"))
                    if (!$util.isInteger(message.numRunning))
                        return "numRunning: integer expected";
                if (message.numPending != null && message.hasOwnProperty("numPending"))
                    if (!$util.isInteger(message.numPending))
                        return "numPending: integer expected";
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    if (typeof message.computeTime !== "number")
                        return "computeTime: number expected";
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    if (!$util.isString(message.startedBy))
                        return "startedBy: string expected";
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (typeof message.progress !== "number")
                        return "progress: number expected";
                if (message.testJobs != null && message.hasOwnProperty("testJobs")) {
                    if (!Array.isArray(message.testJobs))
                        return "testJobs: array expected";
                    for (var i = 0; i < message.testJobs.length; ++i) {
                        var error = $root.metamoto.types.TestJob.verify(message.testJobs[i]);
                        if (error)
                            return "testJobs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TestRun message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestRun
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestRun} TestRun
             */
            TestRun.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestRun)
                    return object;
                var message = new $root.metamoto.types.TestRun();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.testSuiteId != null)
                    message.testSuiteId = String(object.testSuiteId);
                if (object.testSuiteName != null)
                    message.testSuiteName = String(object.testSuiteName);
                if (object.startTime != null)
                    message.startTime = String(object.startTime);
                if (object.endTime != null)
                    message.endTime = String(object.endTime);
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "OTHER":
                case 1:
                    message.status = 1;
                    break;
                case "PASS":
                case 2:
                    message.status = 2;
                    break;
                case "FAIL":
                case 3:
                    message.status = 3;
                    break;
                case "STOP":
                case 4:
                    message.status = 4;
                    break;
                case "ERROR":
                case 5:
                    message.status = 5;
                    break;
                case "PENDING":
                case 6:
                    message.status = 6;
                    break;
                case "RUNNING":
                case 7:
                    message.status = 7;
                    break;
                case "STOPPING":
                case 8:
                    message.status = 8;
                    break;
                case "POST_PROCESSING":
                case 9:
                    message.status = 9;
                    break;
                }
                if (object.resultText != null)
                    message.resultText = String(object.resultText);
                if (object.numPassed != null)
                    message.numPassed = object.numPassed | 0;
                if (object.numFailed != null)
                    message.numFailed = object.numFailed | 0;
                if (object.numStopped != null)
                    message.numStopped = object.numStopped | 0;
                if (object.numErrored != null)
                    message.numErrored = object.numErrored | 0;
                if (object.numRunning != null)
                    message.numRunning = object.numRunning | 0;
                if (object.numPending != null)
                    message.numPending = object.numPending | 0;
                if (object.computeTime != null)
                    message.computeTime = Number(object.computeTime);
                if (object.startedBy != null)
                    message.startedBy = String(object.startedBy);
                if (object.progress != null)
                    message.progress = Number(object.progress);
                if (object.testJobs) {
                    if (!Array.isArray(object.testJobs))
                        throw TypeError(".metamoto.types.TestRun.testJobs: array expected");
                    message.testJobs = [];
                    for (var i = 0; i < object.testJobs.length; ++i) {
                        if (typeof object.testJobs[i] !== "object")
                            throw TypeError(".metamoto.types.TestRun.testJobs: object expected");
                        message.testJobs[i] = $root.metamoto.types.TestJob.fromObject(object.testJobs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TestRun message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestRun
             * @static
             * @param {metamoto.types.TestRun} message TestRun
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestRun.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.testJobs = [];
                if (options.defaults) {
                    object.id = "";
                    object.testSuiteId = "";
                    object.testSuiteName = "";
                    object.startTime = "";
                    object.endTime = "";
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.resultText = "";
                    object.numPassed = 0;
                    object.numFailed = 0;
                    object.numStopped = 0;
                    object.numErrored = 0;
                    object.numRunning = 0;
                    object.numPending = 0;
                    object.computeTime = 0;
                    object.startedBy = "";
                    object.progress = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.testSuiteId != null && message.hasOwnProperty("testSuiteId"))
                    object.testSuiteId = message.testSuiteId;
                if (message.testSuiteName != null && message.hasOwnProperty("testSuiteName"))
                    object.testSuiteName = message.testSuiteName;
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    object.startTime = message.startTime;
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    object.endTime = message.endTime;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.metamoto.types.TestResult.Status[message.status] : message.status;
                if (message.resultText != null && message.hasOwnProperty("resultText"))
                    object.resultText = message.resultText;
                if (message.numPassed != null && message.hasOwnProperty("numPassed"))
                    object.numPassed = message.numPassed;
                if (message.numFailed != null && message.hasOwnProperty("numFailed"))
                    object.numFailed = message.numFailed;
                if (message.numStopped != null && message.hasOwnProperty("numStopped"))
                    object.numStopped = message.numStopped;
                if (message.numErrored != null && message.hasOwnProperty("numErrored"))
                    object.numErrored = message.numErrored;
                if (message.numRunning != null && message.hasOwnProperty("numRunning"))
                    object.numRunning = message.numRunning;
                if (message.numPending != null && message.hasOwnProperty("numPending"))
                    object.numPending = message.numPending;
                if (message.computeTime != null && message.hasOwnProperty("computeTime"))
                    object.computeTime = options.json && !isFinite(message.computeTime) ? String(message.computeTime) : message.computeTime;
                if (message.startedBy != null && message.hasOwnProperty("startedBy"))
                    object.startedBy = message.startedBy;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
                if (message.testJobs && message.testJobs.length) {
                    object.testJobs = [];
                    for (var j = 0; j < message.testJobs.length; ++j)
                        object.testJobs[j] = $root.metamoto.types.TestJob.toObject(message.testJobs[j], options);
                }
                return object;
            };

            /**
             * Converts this TestRun to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestRun
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestRun.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TestRun;
        })();

        types.TestSuite = (function() {

            /**
             * Properties of a TestSuite.
             * @memberof metamoto.types
             * @interface ITestSuite
             * @property {string|null} [id] TestSuite id
             * @property {string|null} [name] TestSuite name
             * @property {metamoto.types.TestSuite.ScheduleType|null} [schedule] TestSuite schedule
             * @property {string|null} [startTime] TestSuite startTime
             * @property {string|null} [nextRunTime] TestSuite nextRunTime
             * @property {Array.<string>|null} [testVectorIds] TestSuite testVectorIds
             * @property {number|null} [priority] TestSuite priority
             */

            /**
             * Constructs a new TestSuite.
             * @memberof metamoto.types
             * @classdesc Represents a TestSuite.
             * @implements ITestSuite
             * @constructor
             * @param {metamoto.types.ITestSuite=} [properties] Properties to set
             */
            function TestSuite(properties) {
                this.testVectorIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestSuite id.
             * @member {string} id
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.id = "";

            /**
             * TestSuite name.
             * @member {string} name
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.name = "";

            /**
             * TestSuite schedule.
             * @member {metamoto.types.TestSuite.ScheduleType} schedule
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.schedule = 0;

            /**
             * TestSuite startTime.
             * @member {string} startTime
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.startTime = "";

            /**
             * TestSuite nextRunTime.
             * @member {string} nextRunTime
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.nextRunTime = "";

            /**
             * TestSuite testVectorIds.
             * @member {Array.<string>} testVectorIds
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.testVectorIds = $util.emptyArray;

            /**
             * TestSuite priority.
             * @member {number} priority
             * @memberof metamoto.types.TestSuite
             * @instance
             */
            TestSuite.prototype.priority = 0;

            /**
             * Creates a new TestSuite instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {metamoto.types.ITestSuite=} [properties] Properties to set
             * @returns {metamoto.types.TestSuite} TestSuite instance
             */
            TestSuite.create = function create(properties) {
                return new TestSuite(properties);
            };

            /**
             * Encodes the specified TestSuite message. Does not implicitly {@link metamoto.types.TestSuite.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {metamoto.types.ITestSuite} message TestSuite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestSuite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.schedule != null && message.hasOwnProperty("schedule"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.schedule);
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.startTime);
                if (message.nextRunTime != null && message.hasOwnProperty("nextRunTime"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.nextRunTime);
                if (message.testVectorIds != null && message.testVectorIds.length)
                    for (var i = 0; i < message.testVectorIds.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.testVectorIds[i]);
                if (message.priority != null && message.hasOwnProperty("priority"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.priority);
                return writer;
            };

            /**
             * Encodes the specified TestSuite message, length delimited. Does not implicitly {@link metamoto.types.TestSuite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {metamoto.types.ITestSuite} message TestSuite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestSuite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestSuite message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestSuite} TestSuite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestSuite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestSuite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.schedule = reader.int32();
                        break;
                    case 4:
                        message.startTime = reader.string();
                        break;
                    case 5:
                        message.nextRunTime = reader.string();
                        break;
                    case 6:
                        if (!(message.testVectorIds && message.testVectorIds.length))
                            message.testVectorIds = [];
                        message.testVectorIds.push(reader.string());
                        break;
                    case 7:
                        message.priority = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestSuite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestSuite} TestSuite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestSuite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestSuite message.
             * @function verify
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestSuite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.schedule != null && message.hasOwnProperty("schedule"))
                    switch (message.schedule) {
                    default:
                        return "schedule: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isString(message.startTime))
                        return "startTime: string expected";
                if (message.nextRunTime != null && message.hasOwnProperty("nextRunTime"))
                    if (!$util.isString(message.nextRunTime))
                        return "nextRunTime: string expected";
                if (message.testVectorIds != null && message.hasOwnProperty("testVectorIds")) {
                    if (!Array.isArray(message.testVectorIds))
                        return "testVectorIds: array expected";
                    for (var i = 0; i < message.testVectorIds.length; ++i)
                        if (!$util.isString(message.testVectorIds[i]))
                            return "testVectorIds: string[] expected";
                }
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                return null;
            };

            /**
             * Creates a TestSuite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestSuite} TestSuite
             */
            TestSuite.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestSuite)
                    return object;
                var message = new $root.metamoto.types.TestSuite();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.schedule) {
                case "UNKNOWN":
                case 0:
                    message.schedule = 0;
                    break;
                case "OTHER":
                case 1:
                    message.schedule = 1;
                    break;
                case "RUN_ONCE":
                case 2:
                    message.schedule = 2;
                    break;
                case "DAILY":
                case 3:
                    message.schedule = 3;
                    break;
                case "WEEKLY":
                case 4:
                    message.schedule = 4;
                    break;
                case "DISABLE":
                case 5:
                    message.schedule = 5;
                    break;
                }
                if (object.startTime != null)
                    message.startTime = String(object.startTime);
                if (object.nextRunTime != null)
                    message.nextRunTime = String(object.nextRunTime);
                if (object.testVectorIds) {
                    if (!Array.isArray(object.testVectorIds))
                        throw TypeError(".metamoto.types.TestSuite.testVectorIds: array expected");
                    message.testVectorIds = [];
                    for (var i = 0; i < object.testVectorIds.length; ++i)
                        message.testVectorIds[i] = String(object.testVectorIds[i]);
                }
                if (object.priority != null)
                    message.priority = object.priority | 0;
                return message;
            };

            /**
             * Creates a plain object from a TestSuite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestSuite
             * @static
             * @param {metamoto.types.TestSuite} message TestSuite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestSuite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.testVectorIds = [];
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.schedule = options.enums === String ? "UNKNOWN" : 0;
                    object.startTime = "";
                    object.nextRunTime = "";
                    object.priority = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.schedule != null && message.hasOwnProperty("schedule"))
                    object.schedule = options.enums === String ? $root.metamoto.types.TestSuite.ScheduleType[message.schedule] : message.schedule;
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    object.startTime = message.startTime;
                if (message.nextRunTime != null && message.hasOwnProperty("nextRunTime"))
                    object.nextRunTime = message.nextRunTime;
                if (message.testVectorIds && message.testVectorIds.length) {
                    object.testVectorIds = [];
                    for (var j = 0; j < message.testVectorIds.length; ++j)
                        object.testVectorIds[j] = message.testVectorIds[j];
                }
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                return object;
            };

            /**
             * Converts this TestSuite to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestSuite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestSuite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ScheduleType enum.
             * @name metamoto.types.TestSuite.ScheduleType
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} RUN_ONCE=2 RUN_ONCE value
             * @property {number} DAILY=3 DAILY value
             * @property {number} WEEKLY=4 WEEKLY value
             * @property {number} DISABLE=5 DISABLE value
             */
            TestSuite.ScheduleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "RUN_ONCE"] = 2;
                values[valuesById[3] = "DAILY"] = 3;
                values[valuesById[4] = "WEEKLY"] = 4;
                values[valuesById[5] = "DISABLE"] = 5;
                return values;
            })();

            return TestSuite;
        })();

        types.TestVector = (function() {

            /**
             * Properties of a TestVector.
             * @memberof metamoto.types
             * @interface ITestVector
             * @property {string|null} [id] TestVector id
             * @property {string|null} [name] TestVector name
             * @property {metamoto.types.TestVector.Strategy|null} [strategy] TestVector strategy
             * @property {number|null} [numTests] TestVector numTests
             * @property {metamoto.types.IScenario|null} [scenario] TestVector scenario
             * @property {metamoto.types.IEgoVehicle|null} [egoVehicle] TestVector egoVehicle
             * @property {Object.<string,metamoto.types.IParameter>|null} [parameters] TestVector parameters
             */

            /**
             * Constructs a new TestVector.
             * @memberof metamoto.types
             * @classdesc Represents a TestVector.
             * @implements ITestVector
             * @constructor
             * @param {metamoto.types.ITestVector=} [properties] Properties to set
             */
            function TestVector(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TestVector id.
             * @member {string} id
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.id = "";

            /**
             * TestVector name.
             * @member {string} name
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.name = "";

            /**
             * TestVector strategy.
             * @member {metamoto.types.TestVector.Strategy} strategy
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.strategy = 0;

            /**
             * TestVector numTests.
             * @member {number} numTests
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.numTests = 0;

            /**
             * TestVector scenario.
             * @member {metamoto.types.IScenario|null|undefined} scenario
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.scenario = null;

            /**
             * TestVector egoVehicle.
             * @member {metamoto.types.IEgoVehicle|null|undefined} egoVehicle
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.egoVehicle = null;

            /**
             * TestVector parameters.
             * @member {Object.<string,metamoto.types.IParameter>} parameters
             * @memberof metamoto.types.TestVector
             * @instance
             */
            TestVector.prototype.parameters = $util.emptyObject;

            /**
             * Creates a new TestVector instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TestVector
             * @static
             * @param {metamoto.types.ITestVector=} [properties] Properties to set
             * @returns {metamoto.types.TestVector} TestVector instance
             */
            TestVector.create = function create(properties) {
                return new TestVector(properties);
            };

            /**
             * Encodes the specified TestVector message. Does not implicitly {@link metamoto.types.TestVector.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TestVector
             * @static
             * @param {metamoto.types.ITestVector} message TestVector message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestVector.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.strategy != null && message.hasOwnProperty("strategy"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.strategy);
                if (message.numTests != null && message.hasOwnProperty("numTests"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.numTests);
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    $root.metamoto.types.Scenario.encode(message.scenario, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    $root.metamoto.types.EgoVehicle.encode(message.egoVehicle, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.metamoto.types.Parameter.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified TestVector message, length delimited. Does not implicitly {@link metamoto.types.TestVector.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TestVector
             * @static
             * @param {metamoto.types.ITestVector} message TestVector message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestVector.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestVector message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TestVector
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TestVector} TestVector
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestVector.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TestVector(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.strategy = reader.int32();
                        break;
                    case 4:
                        message.numTests = reader.int32();
                        break;
                    case 5:
                        message.scenario = $root.metamoto.types.Scenario.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.egoVehicle = $root.metamoto.types.EgoVehicle.decode(reader, reader.uint32());
                        break;
                    case 100:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.metamoto.types.Parameter.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TestVector message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TestVector
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TestVector} TestVector
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestVector.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TestVector message.
             * @function verify
             * @memberof metamoto.types.TestVector
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestVector.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.strategy != null && message.hasOwnProperty("strategy"))
                    switch (message.strategy) {
                    default:
                        return "strategy: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.numTests != null && message.hasOwnProperty("numTests"))
                    if (!$util.isInteger(message.numTests))
                        return "numTests: integer expected";
                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                    var error = $root.metamoto.types.Scenario.verify(message.scenario);
                    if (error)
                        return "scenario." + error;
                }
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle")) {
                    var error = $root.metamoto.types.EgoVehicle.verify(message.egoVehicle);
                    if (error)
                        return "egoVehicle." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.metamoto.types.Parameter.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TestVector message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TestVector
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TestVector} TestVector
             */
            TestVector.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TestVector)
                    return object;
                var message = new $root.metamoto.types.TestVector();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.strategy) {
                case "UNKNOWN":
                case 0:
                    message.strategy = 0;
                    break;
                case "OTHER":
                case 1:
                    message.strategy = 1;
                    break;
                case "SINGLE":
                case 2:
                    message.strategy = 2;
                    break;
                case "EXHAUSTIVE":
                case 3:
                    message.strategy = 3;
                    break;
                case "RANDOM":
                case 4:
                    message.strategy = 4;
                    break;
                case "EDGES":
                case 5:
                    message.strategy = 5;
                    break;
                }
                if (object.numTests != null)
                    message.numTests = object.numTests | 0;
                if (object.scenario != null) {
                    if (typeof object.scenario !== "object")
                        throw TypeError(".metamoto.types.TestVector.scenario: object expected");
                    message.scenario = $root.metamoto.types.Scenario.fromObject(object.scenario);
                }
                if (object.egoVehicle != null) {
                    if (typeof object.egoVehicle !== "object")
                        throw TypeError(".metamoto.types.TestVector.egoVehicle: object expected");
                    message.egoVehicle = $root.metamoto.types.EgoVehicle.fromObject(object.egoVehicle);
                }
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".metamoto.types.TestVector.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".metamoto.types.TestVector.parameters: object expected");
                        message.parameters[keys[i]] = $root.metamoto.types.Parameter.fromObject(object.parameters[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TestVector message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TestVector
             * @static
             * @param {metamoto.types.TestVector} message TestVector
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestVector.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.strategy = options.enums === String ? "UNKNOWN" : 0;
                    object.numTests = 0;
                    object.scenario = null;
                    object.egoVehicle = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.strategy != null && message.hasOwnProperty("strategy"))
                    object.strategy = options.enums === String ? $root.metamoto.types.TestVector.Strategy[message.strategy] : message.strategy;
                if (message.numTests != null && message.hasOwnProperty("numTests"))
                    object.numTests = message.numTests;
                if (message.scenario != null && message.hasOwnProperty("scenario"))
                    object.scenario = $root.metamoto.types.Scenario.toObject(message.scenario, options);
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    object.egoVehicle = $root.metamoto.types.EgoVehicle.toObject(message.egoVehicle, options);
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.metamoto.types.Parameter.toObject(message.parameters[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this TestVector to JSON.
             * @function toJSON
             * @memberof metamoto.types.TestVector
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestVector.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Strategy enum.
             * @name metamoto.types.TestVector.Strategy
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} SINGLE=2 SINGLE value
             * @property {number} EXHAUSTIVE=3 EXHAUSTIVE value
             * @property {number} RANDOM=4 RANDOM value
             * @property {number} EDGES=5 EDGES value
             */
            TestVector.Strategy = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "SINGLE"] = 2;
                values[valuesById[3] = "EXHAUSTIVE"] = 3;
                values[valuesById[4] = "RANDOM"] = 4;
                values[valuesById[5] = "EDGES"] = 5;
                return values;
            })();

            return TestVector;
        })();

        types.TrafficLight = (function() {

            /**
             * Properties of a TrafficLight.
             * @memberof metamoto.types
             * @interface ITrafficLight
             * @property {string|null} [id] TrafficLight id
             * @property {string|null} [signalId] TrafficLight signalId
             * @property {metamoto.types.IPose|null} [pose] TrafficLight pose
             * @property {metamoto.types.IShape|null} [shape] TrafficLight shape
             * @property {metamoto.types.TrafficLight.Type|null} [type] TrafficLight type
             * @property {metamoto.types.TrafficLight.Color|null} [color] TrafficLight color
             * @property {metamoto.types.TrafficLight.Mode|null} [mode] TrafficLight mode
             * @property {string|null} [intersectionId] TrafficLight intersectionId
             * @property {metamoto.types.SignalConfiguration.Signal.ISignalState|null} [state] TrafficLight state
             * @property {Array.<metamoto.types.SignalConfiguration.Signal.IBulbType>|null} [bulbTypes] TrafficLight bulbTypes
             */

            /**
             * Constructs a new TrafficLight.
             * @memberof metamoto.types
             * @classdesc Represents a TrafficLight.
             * @implements ITrafficLight
             * @constructor
             * @param {metamoto.types.ITrafficLight=} [properties] Properties to set
             */
            function TrafficLight(properties) {
                this.bulbTypes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TrafficLight id.
             * @member {string} id
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.id = "";

            /**
             * TrafficLight signalId.
             * @member {string} signalId
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.signalId = "";

            /**
             * TrafficLight pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.pose = null;

            /**
             * TrafficLight shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.shape = null;

            /**
             * TrafficLight type.
             * @member {metamoto.types.TrafficLight.Type} type
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.type = 0;

            /**
             * TrafficLight color.
             * @member {metamoto.types.TrafficLight.Color} color
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.color = 0;

            /**
             * TrafficLight mode.
             * @member {metamoto.types.TrafficLight.Mode} mode
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.mode = 0;

            /**
             * TrafficLight intersectionId.
             * @member {string} intersectionId
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.intersectionId = "";

            /**
             * TrafficLight state.
             * @member {metamoto.types.SignalConfiguration.Signal.ISignalState|null|undefined} state
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.state = null;

            /**
             * TrafficLight bulbTypes.
             * @member {Array.<metamoto.types.SignalConfiguration.Signal.IBulbType>} bulbTypes
             * @memberof metamoto.types.TrafficLight
             * @instance
             */
            TrafficLight.prototype.bulbTypes = $util.emptyArray;

            /**
             * Creates a new TrafficLight instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {metamoto.types.ITrafficLight=} [properties] Properties to set
             * @returns {metamoto.types.TrafficLight} TrafficLight instance
             */
            TrafficLight.create = function create(properties) {
                return new TrafficLight(properties);
            };

            /**
             * Encodes the specified TrafficLight message. Does not implicitly {@link metamoto.types.TrafficLight.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {metamoto.types.ITrafficLight} message TrafficLight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficLight.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.signalId);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.color != null && message.hasOwnProperty("color"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.color);
                if (message.mode != null && message.hasOwnProperty("mode"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.mode);
                if (message.intersectionId != null && message.hasOwnProperty("intersectionId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.intersectionId);
                if (message.state != null && message.hasOwnProperty("state"))
                    $root.metamoto.types.SignalConfiguration.Signal.SignalState.encode(message.state, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.bulbTypes != null && message.bulbTypes.length)
                    for (var i = 0; i < message.bulbTypes.length; ++i)
                        $root.metamoto.types.SignalConfiguration.Signal.BulbType.encode(message.bulbTypes[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TrafficLight message, length delimited. Does not implicitly {@link metamoto.types.TrafficLight.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {metamoto.types.ITrafficLight} message TrafficLight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficLight.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TrafficLight message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TrafficLight} TrafficLight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficLight.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TrafficLight();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.signalId = reader.string();
                        break;
                    case 3:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.color = reader.int32();
                        break;
                    case 7:
                        message.mode = reader.int32();
                        break;
                    case 8:
                        message.intersectionId = reader.string();
                        break;
                    case 9:
                        message.state = $root.metamoto.types.SignalConfiguration.Signal.SignalState.decode(reader, reader.uint32());
                        break;
                    case 10:
                        if (!(message.bulbTypes && message.bulbTypes.length))
                            message.bulbTypes = [];
                        message.bulbTypes.push($root.metamoto.types.SignalConfiguration.Signal.BulbType.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TrafficLight message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TrafficLight} TrafficLight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficLight.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TrafficLight message.
             * @function verify
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TrafficLight.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    if (!$util.isString(message.signalId))
                        return "signalId: string expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.color != null && message.hasOwnProperty("color"))
                    switch (message.color) {
                    default:
                        return "color: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.intersectionId != null && message.hasOwnProperty("intersectionId"))
                    if (!$util.isString(message.intersectionId))
                        return "intersectionId: string expected";
                if (message.state != null && message.hasOwnProperty("state")) {
                    var error = $root.metamoto.types.SignalConfiguration.Signal.SignalState.verify(message.state);
                    if (error)
                        return "state." + error;
                }
                if (message.bulbTypes != null && message.hasOwnProperty("bulbTypes")) {
                    if (!Array.isArray(message.bulbTypes))
                        return "bulbTypes: array expected";
                    for (var i = 0; i < message.bulbTypes.length; ++i) {
                        var error = $root.metamoto.types.SignalConfiguration.Signal.BulbType.verify(message.bulbTypes[i]);
                        if (error)
                            return "bulbTypes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TrafficLight message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TrafficLight} TrafficLight
             */
            TrafficLight.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TrafficLight)
                    return object;
                var message = new $root.metamoto.types.TrafficLight();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.signalId != null)
                    message.signalId = String(object.signalId);
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.TrafficLight.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.TrafficLight.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                switch (object.type) {
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "NORMAL":
                case 2:
                    message.type = 2;
                    break;
                case "LEFT":
                case 3:
                    message.type = 3;
                    break;
                case "LEFT_STRAIGHT":
                case 4:
                    message.type = 4;
                    break;
                case "RIGHT":
                case 5:
                    message.type = 5;
                    break;
                case "RIGHT_STRAIGHT":
                case 6:
                    message.type = 6;
                    break;
                }
                switch (object.color) {
                case "COLOR_UNKNOWN":
                case 0:
                    message.color = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.color = 1;
                    break;
                case "RED":
                case 2:
                    message.color = 2;
                    break;
                case "YELLOW":
                case 3:
                    message.color = 3;
                    break;
                case "GREEN":
                case 4:
                    message.color = 4;
                    break;
                }
                switch (object.mode) {
                case "MODE_UNKNOWN":
                case 0:
                    message.mode = 0;
                    break;
                case "MODE_OTHER":
                case 1:
                    message.mode = 1;
                    break;
                case "OFF":
                case 2:
                    message.mode = 2;
                    break;
                case "CONSTANT":
                case 3:
                    message.mode = 3;
                    break;
                case "BLINKING":
                case 4:
                    message.mode = 4;
                    break;
                }
                if (object.intersectionId != null)
                    message.intersectionId = String(object.intersectionId);
                if (object.state != null) {
                    if (typeof object.state !== "object")
                        throw TypeError(".metamoto.types.TrafficLight.state: object expected");
                    message.state = $root.metamoto.types.SignalConfiguration.Signal.SignalState.fromObject(object.state);
                }
                if (object.bulbTypes) {
                    if (!Array.isArray(object.bulbTypes))
                        throw TypeError(".metamoto.types.TrafficLight.bulbTypes: array expected");
                    message.bulbTypes = [];
                    for (var i = 0; i < object.bulbTypes.length; ++i) {
                        if (typeof object.bulbTypes[i] !== "object")
                            throw TypeError(".metamoto.types.TrafficLight.bulbTypes: object expected");
                        message.bulbTypes[i] = $root.metamoto.types.SignalConfiguration.Signal.BulbType.fromObject(object.bulbTypes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TrafficLight message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TrafficLight
             * @static
             * @param {metamoto.types.TrafficLight} message TrafficLight
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TrafficLight.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.bulbTypes = [];
                if (options.defaults) {
                    object.id = "";
                    object.signalId = "";
                    object.pose = null;
                    object.shape = null;
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                    object.mode = options.enums === String ? "MODE_UNKNOWN" : 0;
                    object.intersectionId = "";
                    object.state = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    object.signalId = message.signalId;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.TrafficLight.Type[message.type] : message.type;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = options.enums === String ? $root.metamoto.types.TrafficLight.Color[message.color] : message.color;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.metamoto.types.TrafficLight.Mode[message.mode] : message.mode;
                if (message.intersectionId != null && message.hasOwnProperty("intersectionId"))
                    object.intersectionId = message.intersectionId;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = $root.metamoto.types.SignalConfiguration.Signal.SignalState.toObject(message.state, options);
                if (message.bulbTypes && message.bulbTypes.length) {
                    object.bulbTypes = [];
                    for (var j = 0; j < message.bulbTypes.length; ++j)
                        object.bulbTypes[j] = $root.metamoto.types.SignalConfiguration.Signal.BulbType.toObject(message.bulbTypes[j], options);
                }
                return object;
            };

            /**
             * Converts this TrafficLight to JSON.
             * @function toJSON
             * @memberof metamoto.types.TrafficLight
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TrafficLight.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.TrafficLight.Type
             * @enum {string}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} NORMAL=2 NORMAL value
             * @property {number} LEFT=3 LEFT value
             * @property {number} LEFT_STRAIGHT=4 LEFT_STRAIGHT value
             * @property {number} RIGHT=5 RIGHT value
             * @property {number} RIGHT_STRAIGHT=6 RIGHT_STRAIGHT value
             */
            TrafficLight.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "NORMAL"] = 2;
                values[valuesById[3] = "LEFT"] = 3;
                values[valuesById[4] = "LEFT_STRAIGHT"] = 4;
                values[valuesById[5] = "RIGHT"] = 5;
                values[valuesById[6] = "RIGHT_STRAIGHT"] = 6;
                return values;
            })();

            /**
             * Color enum.
             * @name metamoto.types.TrafficLight.Color
             * @enum {string}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} RED=2 RED value
             * @property {number} YELLOW=3 YELLOW value
             * @property {number} GREEN=4 GREEN value
             */
            TrafficLight.Color = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "RED"] = 2;
                values[valuesById[3] = "YELLOW"] = 3;
                values[valuesById[4] = "GREEN"] = 4;
                return values;
            })();

            /**
             * Mode enum.
             * @name metamoto.types.TrafficLight.Mode
             * @enum {string}
             * @property {number} MODE_UNKNOWN=0 MODE_UNKNOWN value
             * @property {number} MODE_OTHER=1 MODE_OTHER value
             * @property {number} OFF=2 OFF value
             * @property {number} CONSTANT=3 CONSTANT value
             * @property {number} BLINKING=4 BLINKING value
             */
            TrafficLight.Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODE_UNKNOWN"] = 0;
                values[valuesById[1] = "MODE_OTHER"] = 1;
                values[valuesById[2] = "OFF"] = 2;
                values[valuesById[3] = "CONSTANT"] = 3;
                values[valuesById[4] = "BLINKING"] = 4;
                return values;
            })();

            return TrafficLight;
        })();

        types.TrafficSign = (function() {

            /**
             * Properties of a TrafficSign.
             * @memberof metamoto.types
             * @interface ITrafficSign
             * @property {string|null} [id] TrafficSign id
             * @property {string|null} [signalId] TrafficSign signalId
             * @property {metamoto.types.IPose|null} [pose] TrafficSign pose
             * @property {metamoto.types.IShape|null} [shape] TrafficSign shape
             * @property {metamoto.types.TrafficSign.Type|null} [type] TrafficSign type
             * @property {number|null} [value] TrafficSign value
             */

            /**
             * Constructs a new TrafficSign.
             * @memberof metamoto.types
             * @classdesc Represents a TrafficSign.
             * @implements ITrafficSign
             * @constructor
             * @param {metamoto.types.ITrafficSign=} [properties] Properties to set
             */
            function TrafficSign(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TrafficSign id.
             * @member {string} id
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.id = "";

            /**
             * TrafficSign signalId.
             * @member {string} signalId
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.signalId = "";

            /**
             * TrafficSign pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.pose = null;

            /**
             * TrafficSign shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.shape = null;

            /**
             * TrafficSign type.
             * @member {metamoto.types.TrafficSign.Type} type
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.type = 0;

            /**
             * TrafficSign value.
             * @member {number} value
             * @memberof metamoto.types.TrafficSign
             * @instance
             */
            TrafficSign.prototype.value = 0;

            /**
             * Creates a new TrafficSign instance using the specified properties.
             * @function create
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {metamoto.types.ITrafficSign=} [properties] Properties to set
             * @returns {metamoto.types.TrafficSign} TrafficSign instance
             */
            TrafficSign.create = function create(properties) {
                return new TrafficSign(properties);
            };

            /**
             * Encodes the specified TrafficSign message. Does not implicitly {@link metamoto.types.TrafficSign.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {metamoto.types.ITrafficSign} message TrafficSign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficSign.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.signalId);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified TrafficSign message, length delimited. Does not implicitly {@link metamoto.types.TrafficSign.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {metamoto.types.ITrafficSign} message TrafficSign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficSign.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TrafficSign message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.TrafficSign} TrafficSign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficSign.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.TrafficSign();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.signalId = reader.string();
                        break;
                    case 3:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.value = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TrafficSign message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.TrafficSign} TrafficSign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficSign.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TrafficSign message.
             * @function verify
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TrafficSign.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    if (!$util.isString(message.signalId))
                        return "signalId: string expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a TrafficSign message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.TrafficSign} TrafficSign
             */
            TrafficSign.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.TrafficSign)
                    return object;
                var message = new $root.metamoto.types.TrafficSign();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.signalId != null)
                    message.signalId = String(object.signalId);
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.TrafficSign.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.TrafficSign.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "STOP":
                case 2:
                    message.type = 2;
                    break;
                case "YIELD":
                case 3:
                    message.type = 3;
                    break;
                case "DO_NOT_ENTER":
                case 4:
                    message.type = 4;
                    break;
                case "NO_LEFT_TURN":
                case 5:
                    message.type = 5;
                    break;
                case "NO_RIGHT_TURN":
                case 6:
                    message.type = 6;
                    break;
                case "NO_U_TURN":
                case 7:
                    message.type = 7;
                    break;
                case "NO_LEFT_OR_U_TURN":
                case 8:
                    message.type = 8;
                    break;
                case "ONE_WAY":
                case 9:
                    message.type = 9;
                    break;
                case "SPEED_LIMIT":
                case 10:
                    message.type = 10;
                    break;
                case "NO_TRUCKS":
                case 11:
                    message.type = 11;
                    break;
                case "NO_PEDESTRIANS":
                case 12:
                    message.type = 12;
                    break;
                case "NO_BICYCLES":
                case 13:
                    message.type = 13;
                    break;
                case "NO_PARKING":
                case 14:
                    message.type = 14;
                    break;
                }
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a TrafficSign message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.TrafficSign
             * @static
             * @param {metamoto.types.TrafficSign} message TrafficSign
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TrafficSign.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.signalId = "";
                    object.pose = null;
                    object.shape = null;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.value = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.signalId != null && message.hasOwnProperty("signalId"))
                    object.signalId = message.signalId;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.TrafficSign.Type[message.type] : message.type;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this TrafficSign to JSON.
             * @function toJSON
             * @memberof metamoto.types.TrafficSign
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TrafficSign.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.TrafficSign.Type
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} OTHER=1 OTHER value
             * @property {number} STOP=2 STOP value
             * @property {number} YIELD=3 YIELD value
             * @property {number} DO_NOT_ENTER=4 DO_NOT_ENTER value
             * @property {number} NO_LEFT_TURN=5 NO_LEFT_TURN value
             * @property {number} NO_RIGHT_TURN=6 NO_RIGHT_TURN value
             * @property {number} NO_U_TURN=7 NO_U_TURN value
             * @property {number} NO_LEFT_OR_U_TURN=8 NO_LEFT_OR_U_TURN value
             * @property {number} ONE_WAY=9 ONE_WAY value
             * @property {number} SPEED_LIMIT=10 SPEED_LIMIT value
             * @property {number} NO_TRUCKS=11 NO_TRUCKS value
             * @property {number} NO_PEDESTRIANS=12 NO_PEDESTRIANS value
             * @property {number} NO_BICYCLES=13 NO_BICYCLES value
             * @property {number} NO_PARKING=14 NO_PARKING value
             */
            TrafficSign.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "OTHER"] = 1;
                values[valuesById[2] = "STOP"] = 2;
                values[valuesById[3] = "YIELD"] = 3;
                values[valuesById[4] = "DO_NOT_ENTER"] = 4;
                values[valuesById[5] = "NO_LEFT_TURN"] = 5;
                values[valuesById[6] = "NO_RIGHT_TURN"] = 6;
                values[valuesById[7] = "NO_U_TURN"] = 7;
                values[valuesById[8] = "NO_LEFT_OR_U_TURN"] = 8;
                values[valuesById[9] = "ONE_WAY"] = 9;
                values[valuesById[10] = "SPEED_LIMIT"] = 10;
                values[valuesById[11] = "NO_TRUCKS"] = 11;
                values[valuesById[12] = "NO_PEDESTRIANS"] = 12;
                values[valuesById[13] = "NO_BICYCLES"] = 13;
                values[valuesById[14] = "NO_PARKING"] = 14;
                return values;
            })();

            return TrafficSign;
        })();

        types.Vector3 = (function() {

            /**
             * Properties of a Vector3.
             * @memberof metamoto.types
             * @interface IVector3
             * @property {number|null} [x] Vector3 x
             * @property {number|null} [y] Vector3 y
             * @property {number|null} [z] Vector3 z
             */

            /**
             * Constructs a new Vector3.
             * @memberof metamoto.types
             * @classdesc Represents a Vector3.
             * @implements IVector3
             * @constructor
             * @param {metamoto.types.IVector3=} [properties] Properties to set
             */
            function Vector3(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vector3 x.
             * @member {number} x
             * @memberof metamoto.types.Vector3
             * @instance
             */
            Vector3.prototype.x = 0;

            /**
             * Vector3 y.
             * @member {number} y
             * @memberof metamoto.types.Vector3
             * @instance
             */
            Vector3.prototype.y = 0;

            /**
             * Vector3 z.
             * @member {number} z
             * @memberof metamoto.types.Vector3
             * @instance
             */
            Vector3.prototype.z = 0;

            /**
             * Creates a new Vector3 instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Vector3
             * @static
             * @param {metamoto.types.IVector3=} [properties] Properties to set
             * @returns {metamoto.types.Vector3} Vector3 instance
             */
            Vector3.create = function create(properties) {
                return new Vector3(properties);
            };

            /**
             * Encodes the specified Vector3 message. Does not implicitly {@link metamoto.types.Vector3.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Vector3
             * @static
             * @param {metamoto.types.IVector3} message Vector3 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vector3.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && message.hasOwnProperty("x"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                if (message.y != null && message.hasOwnProperty("y"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                if (message.z != null && message.hasOwnProperty("z"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
                return writer;
            };

            /**
             * Encodes the specified Vector3 message, length delimited. Does not implicitly {@link metamoto.types.Vector3.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Vector3
             * @static
             * @param {metamoto.types.IVector3} message Vector3 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vector3.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Vector3 message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Vector3
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Vector3} Vector3
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vector3.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Vector3();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.float();
                        break;
                    case 2:
                        message.y = reader.float();
                        break;
                    case 3:
                        message.z = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Vector3 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Vector3
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Vector3} Vector3
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vector3.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Vector3 message.
             * @function verify
             * @memberof metamoto.types.Vector3
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Vector3.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                if (message.z != null && message.hasOwnProperty("z"))
                    if (typeof message.z !== "number")
                        return "z: number expected";
                return null;
            };

            /**
             * Creates a Vector3 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Vector3
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Vector3} Vector3
             */
            Vector3.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Vector3)
                    return object;
                var message = new $root.metamoto.types.Vector3();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                return message;
            };

            /**
             * Creates a plain object from a Vector3 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Vector3
             * @static
             * @param {metamoto.types.Vector3} message Vector3
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Vector3.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                return object;
            };

            /**
             * Converts this Vector3 to JSON.
             * @function toJSON
             * @memberof metamoto.types.Vector3
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Vector3.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Vector3;
        })();

        types.Vehicle = (function() {

            /**
             * Properties of a Vehicle.
             * @memberof metamoto.types
             * @interface IVehicle
             * @property {string|null} [id] Vehicle id
             * @property {metamoto.types.IPose|null} [pose] Vehicle pose
             * @property {Array.<metamoto.types.IRoadPoint>|null} [roadPoint] Vehicle roadPoint
             * @property {metamoto.types.IVelocity|null} [velocity] Vehicle velocity
             * @property {metamoto.types.IAcceleration|null} [acceleration] Vehicle acceleration
             * @property {metamoto.types.IShape|null} [shape] Vehicle shape
             * @property {metamoto.types.Vehicle.Type|null} [type] Vehicle type
             * @property {metamoto.types.Vehicle.LightState|null} [headLights] Vehicle headLights
             * @property {metamoto.types.Vehicle.LightState|null} [reverseLights] Vehicle reverseLights
             * @property {metamoto.types.Vehicle.LightState|null} [brakeLights] Vehicle brakeLights
             * @property {metamoto.types.Vehicle.SignalLightState|null} [signalLights] Vehicle signalLights
             * @property {string|null} [model] Vehicle model
             * @property {string|null} [paint] Vehicle paint
             */

            /**
             * Constructs a new Vehicle.
             * @memberof metamoto.types
             * @classdesc Represents a Vehicle.
             * @implements IVehicle
             * @constructor
             * @param {metamoto.types.IVehicle=} [properties] Properties to set
             */
            function Vehicle(properties) {
                this.roadPoint = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vehicle id.
             * @member {string} id
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.id = "";

            /**
             * Vehicle pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.pose = null;

            /**
             * Vehicle roadPoint.
             * @member {Array.<metamoto.types.IRoadPoint>} roadPoint
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.roadPoint = $util.emptyArray;

            /**
             * Vehicle velocity.
             * @member {metamoto.types.IVelocity|null|undefined} velocity
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.velocity = null;

            /**
             * Vehicle acceleration.
             * @member {metamoto.types.IAcceleration|null|undefined} acceleration
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.acceleration = null;

            /**
             * Vehicle shape.
             * @member {metamoto.types.IShape|null|undefined} shape
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.shape = null;

            /**
             * Vehicle type.
             * @member {metamoto.types.Vehicle.Type} type
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.type = 0;

            /**
             * Vehicle headLights.
             * @member {metamoto.types.Vehicle.LightState} headLights
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.headLights = 0;

            /**
             * Vehicle reverseLights.
             * @member {metamoto.types.Vehicle.LightState} reverseLights
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.reverseLights = 0;

            /**
             * Vehicle brakeLights.
             * @member {metamoto.types.Vehicle.LightState} brakeLights
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.brakeLights = 0;

            /**
             * Vehicle signalLights.
             * @member {metamoto.types.Vehicle.SignalLightState} signalLights
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.signalLights = 0;

            /**
             * Vehicle model.
             * @member {string} model
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.model = "";

            /**
             * Vehicle paint.
             * @member {string} paint
             * @memberof metamoto.types.Vehicle
             * @instance
             */
            Vehicle.prototype.paint = "";

            /**
             * Creates a new Vehicle instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {metamoto.types.IVehicle=} [properties] Properties to set
             * @returns {metamoto.types.Vehicle} Vehicle instance
             */
            Vehicle.create = function create(properties) {
                return new Vehicle(properties);
            };

            /**
             * Encodes the specified Vehicle message. Does not implicitly {@link metamoto.types.Vehicle.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {metamoto.types.IVehicle} message Vehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vehicle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.roadPoint != null && message.roadPoint.length)
                    for (var i = 0; i < message.roadPoint.length; ++i)
                        $root.metamoto.types.RoadPoint.encode(message.roadPoint[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    $root.metamoto.types.Velocity.encode(message.velocity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.metamoto.types.Acceleration.encode(message.acceleration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.metamoto.types.Shape.encode(message.shape, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.headLights);
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.reverseLights);
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.brakeLights);
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.signalLights);
                if (message.model != null && message.hasOwnProperty("model"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.model);
                if (message.paint != null && message.hasOwnProperty("paint"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.paint);
                return writer;
            };

            /**
             * Encodes the specified Vehicle message, length delimited. Does not implicitly {@link metamoto.types.Vehicle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {metamoto.types.IVehicle} message Vehicle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vehicle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Vehicle message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Vehicle} Vehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vehicle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Vehicle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.roadPoint && message.roadPoint.length))
                            message.roadPoint = [];
                        message.roadPoint.push($root.metamoto.types.RoadPoint.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.velocity = $root.metamoto.types.Velocity.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.acceleration = $root.metamoto.types.Acceleration.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.shape = $root.metamoto.types.Shape.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.type = reader.int32();
                        break;
                    case 8:
                        message.headLights = reader.int32();
                        break;
                    case 9:
                        message.reverseLights = reader.int32();
                        break;
                    case 10:
                        message.brakeLights = reader.int32();
                        break;
                    case 11:
                        message.signalLights = reader.int32();
                        break;
                    case 12:
                        message.model = reader.string();
                        break;
                    case 13:
                        message.paint = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Vehicle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Vehicle} Vehicle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vehicle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Vehicle message.
             * @function verify
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Vehicle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    if (!Array.isArray(message.roadPoint))
                        return "roadPoint: array expected";
                    for (var i = 0; i < message.roadPoint.length; ++i) {
                        var error = $root.metamoto.types.RoadPoint.verify(message.roadPoint[i]);
                        if (error)
                            return "roadPoint." + error;
                    }
                }
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    var error = $root.metamoto.types.Velocity.verify(message.velocity);
                    if (error)
                        return "velocity." + error;
                }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.metamoto.types.Acceleration.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.metamoto.types.Shape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    switch (message.headLights) {
                    default:
                        return "headLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    switch (message.reverseLights) {
                    default:
                        return "reverseLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    switch (message.brakeLights) {
                    default:
                        return "brakeLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    switch (message.signalLights) {
                    default:
                        return "signalLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.model != null && message.hasOwnProperty("model"))
                    if (!$util.isString(message.model))
                        return "model: string expected";
                if (message.paint != null && message.hasOwnProperty("paint"))
                    if (!$util.isString(message.paint))
                        return "paint: string expected";
                return null;
            };

            /**
             * Creates a Vehicle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Vehicle} Vehicle
             */
            Vehicle.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Vehicle)
                    return object;
                var message = new $root.metamoto.types.Vehicle();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.types.Vehicle.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.roadPoint) {
                    if (!Array.isArray(object.roadPoint))
                        throw TypeError(".metamoto.types.Vehicle.roadPoint: array expected");
                    message.roadPoint = [];
                    for (var i = 0; i < object.roadPoint.length; ++i) {
                        if (typeof object.roadPoint[i] !== "object")
                            throw TypeError(".metamoto.types.Vehicle.roadPoint: object expected");
                        message.roadPoint[i] = $root.metamoto.types.RoadPoint.fromObject(object.roadPoint[i]);
                    }
                }
                if (object.velocity != null) {
                    if (typeof object.velocity !== "object")
                        throw TypeError(".metamoto.types.Vehicle.velocity: object expected");
                    message.velocity = $root.metamoto.types.Velocity.fromObject(object.velocity);
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.types.Vehicle.acceleration: object expected");
                    message.acceleration = $root.metamoto.types.Acceleration.fromObject(object.acceleration);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".metamoto.types.Vehicle.shape: object expected");
                    message.shape = $root.metamoto.types.Shape.fromObject(object.shape);
                }
                switch (object.type) {
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "CAR":
                case 2:
                    message.type = 2;
                    break;
                case "TRUCK":
                case 3:
                    message.type = 3;
                    break;
                case "BUS":
                case 4:
                    message.type = 4;
                    break;
                case "MOTORCYCLE":
                case 5:
                    message.type = 5;
                    break;
                case "BICYCLE":
                case 6:
                    message.type = 6;
                    break;
                case "TRAIN":
                case 7:
                    message.type = 7;
                    break;
                case "STREET_CAR":
                case 8:
                    message.type = 8;
                    break;
                }
                switch (object.headLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.headLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.headLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.headLights = 2;
                    break;
                case "ON":
                case 3:
                    message.headLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.headLights = 4;
                    break;
                }
                switch (object.reverseLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.reverseLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.reverseLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.reverseLights = 2;
                    break;
                case "ON":
                case 3:
                    message.reverseLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.reverseLights = 4;
                    break;
                }
                switch (object.brakeLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.brakeLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.brakeLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.brakeLights = 2;
                    break;
                case "ON":
                case 3:
                    message.brakeLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.brakeLights = 4;
                    break;
                }
                switch (object.signalLights) {
                case "SIGNAL_LIGHT_STATE_UNKNOWN":
                case 0:
                    message.signalLights = 0;
                    break;
                case "SIGNAL_LIGHT_STATE_OTHER":
                case 1:
                    message.signalLights = 1;
                    break;
                case "SIGNAL_LIGHT_STATE_OFF":
                case 2:
                    message.signalLights = 2;
                    break;
                case "LEFT":
                case 3:
                    message.signalLights = 3;
                    break;
                case "RIGHT":
                case 4:
                    message.signalLights = 4;
                    break;
                case "HAZARD":
                case 5:
                    message.signalLights = 5;
                    break;
                }
                if (object.model != null)
                    message.model = String(object.model);
                if (object.paint != null)
                    message.paint = String(object.paint);
                return message;
            };

            /**
             * Creates a plain object from a Vehicle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Vehicle
             * @static
             * @param {metamoto.types.Vehicle} message Vehicle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Vehicle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.roadPoint = [];
                if (options.defaults) {
                    object.id = "";
                    object.pose = null;
                    object.velocity = null;
                    object.acceleration = null;
                    object.shape = null;
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.headLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.reverseLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.brakeLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.signalLights = options.enums === String ? "SIGNAL_LIGHT_STATE_UNKNOWN" : 0;
                    object.model = "";
                    object.paint = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.roadPoint && message.roadPoint.length) {
                    object.roadPoint = [];
                    for (var j = 0; j < message.roadPoint.length; ++j)
                        object.roadPoint[j] = $root.metamoto.types.RoadPoint.toObject(message.roadPoint[j], options);
                }
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = $root.metamoto.types.Velocity.toObject(message.velocity, options);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.metamoto.types.Acceleration.toObject(message.acceleration, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.metamoto.types.Shape.toObject(message.shape, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Vehicle.Type[message.type] : message.type;
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    object.headLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.headLights] : message.headLights;
                if (message.reverseLights != null && message.hasOwnProperty("reverseLights"))
                    object.reverseLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.reverseLights] : message.reverseLights;
                if (message.brakeLights != null && message.hasOwnProperty("brakeLights"))
                    object.brakeLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.brakeLights] : message.brakeLights;
                if (message.signalLights != null && message.hasOwnProperty("signalLights"))
                    object.signalLights = options.enums === String ? $root.metamoto.types.Vehicle.SignalLightState[message.signalLights] : message.signalLights;
                if (message.model != null && message.hasOwnProperty("model"))
                    object.model = message.model;
                if (message.paint != null && message.hasOwnProperty("paint"))
                    object.paint = message.paint;
                return object;
            };

            /**
             * Converts this Vehicle to JSON.
             * @function toJSON
             * @memberof metamoto.types.Vehicle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Vehicle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name metamoto.types.Vehicle.Type
             * @enum {string}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} CAR=2 CAR value
             * @property {number} TRUCK=3 TRUCK value
             * @property {number} BUS=4 BUS value
             * @property {number} MOTORCYCLE=5 MOTORCYCLE value
             * @property {number} BICYCLE=6 BICYCLE value
             * @property {number} TRAIN=7 TRAIN value
             * @property {number} STREET_CAR=8 STREET_CAR value
             */
            Vehicle.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "CAR"] = 2;
                values[valuesById[3] = "TRUCK"] = 3;
                values[valuesById[4] = "BUS"] = 4;
                values[valuesById[5] = "MOTORCYCLE"] = 5;
                values[valuesById[6] = "BICYCLE"] = 6;
                values[valuesById[7] = "TRAIN"] = 7;
                values[valuesById[8] = "STREET_CAR"] = 8;
                return values;
            })();

            /**
             * LightState enum.
             * @name metamoto.types.Vehicle.LightState
             * @enum {string}
             * @property {number} LIGHT_STATE_UNKNOWN=0 LIGHT_STATE_UNKNOWN value
             * @property {number} LIGHT_STATE_OTHER=1 LIGHT_STATE_OTHER value
             * @property {number} OFF=2 OFF value
             * @property {number} ON=3 ON value
             * @property {number} STRONG=4 STRONG value
             */
            Vehicle.LightState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LIGHT_STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "LIGHT_STATE_OTHER"] = 1;
                values[valuesById[2] = "OFF"] = 2;
                values[valuesById[3] = "ON"] = 3;
                values[valuesById[4] = "STRONG"] = 4;
                return values;
            })();

            /**
             * SignalLightState enum.
             * @name metamoto.types.Vehicle.SignalLightState
             * @enum {string}
             * @property {number} SIGNAL_LIGHT_STATE_UNKNOWN=0 SIGNAL_LIGHT_STATE_UNKNOWN value
             * @property {number} SIGNAL_LIGHT_STATE_OTHER=1 SIGNAL_LIGHT_STATE_OTHER value
             * @property {number} SIGNAL_LIGHT_STATE_OFF=2 SIGNAL_LIGHT_STATE_OFF value
             * @property {number} LEFT=3 LEFT value
             * @property {number} RIGHT=4 RIGHT value
             * @property {number} HAZARD=5 HAZARD value
             */
            Vehicle.SignalLightState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SIGNAL_LIGHT_STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "SIGNAL_LIGHT_STATE_OTHER"] = 1;
                values[valuesById[2] = "SIGNAL_LIGHT_STATE_OFF"] = 2;
                values[valuesById[3] = "LEFT"] = 3;
                values[valuesById[4] = "RIGHT"] = 4;
                values[valuesById[5] = "HAZARD"] = 5;
                return values;
            })();

            /**
             * GearSelector enum.
             * @name metamoto.types.Vehicle.GearSelector
             * @enum {string}
             * @property {number} GEAR_UNKNOWN=0 GEAR_UNKNOWN value
             * @property {number} GEAR_OTHER=1 GEAR_OTHER value
             * @property {number} GEAR_P=2 GEAR_P value
             * @property {number} GEAR_R=3 GEAR_R value
             * @property {number} GEAR_N=4 GEAR_N value
             * @property {number} GEAR_D=5 GEAR_D value
             * @property {number} GEAR_L=6 GEAR_L value
             */
            Vehicle.GearSelector = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "GEAR_UNKNOWN"] = 0;
                values[valuesById[1] = "GEAR_OTHER"] = 1;
                values[valuesById[2] = "GEAR_P"] = 2;
                values[valuesById[3] = "GEAR_R"] = 3;
                values[valuesById[4] = "GEAR_N"] = 4;
                values[valuesById[5] = "GEAR_D"] = 5;
                values[valuesById[6] = "GEAR_L"] = 6;
                return values;
            })();

            return Vehicle;
        })();

        types.VehicleInfo = (function() {

            /**
             * Properties of a VehicleInfo.
             * @memberof metamoto.types
             * @interface IVehicleInfo
             * @property {number|null} [maxSteerAngle] VehicleInfo maxSteerAngle
             * @property {number|null} [wheelBase] VehicleInfo wheelBase
             * @property {number|null} [maxAcceleration] VehicleInfo maxAcceleration
             * @property {number|null} [maxBrake] VehicleInfo maxBrake
             * @property {number|null} [coastingDeceleration] VehicleInfo coastingDeceleration
             * @property {metamoto.types.IVector3|null} [dimensions] VehicleInfo dimensions
             * @property {number|null} [mass] VehicleInfo mass
             * @property {metamoto.types.Vehicle.Type|null} [type] VehicleInfo type
             */

            /**
             * Constructs a new VehicleInfo.
             * @memberof metamoto.types
             * @classdesc Represents a VehicleInfo.
             * @implements IVehicleInfo
             * @constructor
             * @param {metamoto.types.IVehicleInfo=} [properties] Properties to set
             */
            function VehicleInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleInfo maxSteerAngle.
             * @member {number} maxSteerAngle
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.maxSteerAngle = 0;

            /**
             * VehicleInfo wheelBase.
             * @member {number} wheelBase
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.wheelBase = 0;

            /**
             * VehicleInfo maxAcceleration.
             * @member {number} maxAcceleration
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.maxAcceleration = 0;

            /**
             * VehicleInfo maxBrake.
             * @member {number} maxBrake
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.maxBrake = 0;

            /**
             * VehicleInfo coastingDeceleration.
             * @member {number} coastingDeceleration
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.coastingDeceleration = 0;

            /**
             * VehicleInfo dimensions.
             * @member {metamoto.types.IVector3|null|undefined} dimensions
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.dimensions = null;

            /**
             * VehicleInfo mass.
             * @member {number} mass
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.mass = 0;

            /**
             * VehicleInfo type.
             * @member {metamoto.types.Vehicle.Type} type
             * @memberof metamoto.types.VehicleInfo
             * @instance
             */
            VehicleInfo.prototype.type = 0;

            /**
             * Creates a new VehicleInfo instance using the specified properties.
             * @function create
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {metamoto.types.IVehicleInfo=} [properties] Properties to set
             * @returns {metamoto.types.VehicleInfo} VehicleInfo instance
             */
            VehicleInfo.create = function create(properties) {
                return new VehicleInfo(properties);
            };

            /**
             * Encodes the specified VehicleInfo message. Does not implicitly {@link metamoto.types.VehicleInfo.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {metamoto.types.IVehicleInfo} message VehicleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxSteerAngle != null && message.hasOwnProperty("maxSteerAngle"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.maxSteerAngle);
                if (message.wheelBase != null && message.hasOwnProperty("wheelBase"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.wheelBase);
                if (message.maxAcceleration != null && message.hasOwnProperty("maxAcceleration"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.maxAcceleration);
                if (message.maxBrake != null && message.hasOwnProperty("maxBrake"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.maxBrake);
                if (message.coastingDeceleration != null && message.hasOwnProperty("coastingDeceleration"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.coastingDeceleration);
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    $root.metamoto.types.Vector3.encode(message.dimensions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.mass != null && message.hasOwnProperty("mass"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.mass);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified VehicleInfo message, length delimited. Does not implicitly {@link metamoto.types.VehicleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {metamoto.types.IVehicleInfo} message VehicleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.VehicleInfo} VehicleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VehicleInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxSteerAngle = reader.float();
                        break;
                    case 2:
                        message.wheelBase = reader.float();
                        break;
                    case 3:
                        message.maxAcceleration = reader.float();
                        break;
                    case 4:
                        message.maxBrake = reader.float();
                        break;
                    case 5:
                        message.coastingDeceleration = reader.float();
                        break;
                    case 6:
                        message.dimensions = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.mass = reader.float();
                        break;
                    case 8:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.VehicleInfo} VehicleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleInfo message.
             * @function verify
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxSteerAngle != null && message.hasOwnProperty("maxSteerAngle"))
                    if (typeof message.maxSteerAngle !== "number")
                        return "maxSteerAngle: number expected";
                if (message.wheelBase != null && message.hasOwnProperty("wheelBase"))
                    if (typeof message.wheelBase !== "number")
                        return "wheelBase: number expected";
                if (message.maxAcceleration != null && message.hasOwnProperty("maxAcceleration"))
                    if (typeof message.maxAcceleration !== "number")
                        return "maxAcceleration: number expected";
                if (message.maxBrake != null && message.hasOwnProperty("maxBrake"))
                    if (typeof message.maxBrake !== "number")
                        return "maxBrake: number expected";
                if (message.coastingDeceleration != null && message.hasOwnProperty("coastingDeceleration"))
                    if (typeof message.coastingDeceleration !== "number")
                        return "coastingDeceleration: number expected";
                if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                    var error = $root.metamoto.types.Vector3.verify(message.dimensions);
                    if (error)
                        return "dimensions." + error;
                }
                if (message.mass != null && message.hasOwnProperty("mass"))
                    if (typeof message.mass !== "number")
                        return "mass: number expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                return null;
            };

            /**
             * Creates a VehicleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.VehicleInfo} VehicleInfo
             */
            VehicleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.VehicleInfo)
                    return object;
                var message = new $root.metamoto.types.VehicleInfo();
                if (object.maxSteerAngle != null)
                    message.maxSteerAngle = Number(object.maxSteerAngle);
                if (object.wheelBase != null)
                    message.wheelBase = Number(object.wheelBase);
                if (object.maxAcceleration != null)
                    message.maxAcceleration = Number(object.maxAcceleration);
                if (object.maxBrake != null)
                    message.maxBrake = Number(object.maxBrake);
                if (object.coastingDeceleration != null)
                    message.coastingDeceleration = Number(object.coastingDeceleration);
                if (object.dimensions != null) {
                    if (typeof object.dimensions !== "object")
                        throw TypeError(".metamoto.types.VehicleInfo.dimensions: object expected");
                    message.dimensions = $root.metamoto.types.Vector3.fromObject(object.dimensions);
                }
                if (object.mass != null)
                    message.mass = Number(object.mass);
                switch (object.type) {
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "CAR":
                case 2:
                    message.type = 2;
                    break;
                case "TRUCK":
                case 3:
                    message.type = 3;
                    break;
                case "BUS":
                case 4:
                    message.type = 4;
                    break;
                case "MOTORCYCLE":
                case 5:
                    message.type = 5;
                    break;
                case "BICYCLE":
                case 6:
                    message.type = 6;
                    break;
                case "TRAIN":
                case 7:
                    message.type = 7;
                    break;
                case "STREET_CAR":
                case 8:
                    message.type = 8;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.VehicleInfo
             * @static
             * @param {metamoto.types.VehicleInfo} message VehicleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.maxSteerAngle = 0;
                    object.wheelBase = 0;
                    object.maxAcceleration = 0;
                    object.maxBrake = 0;
                    object.coastingDeceleration = 0;
                    object.dimensions = null;
                    object.mass = 0;
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                }
                if (message.maxSteerAngle != null && message.hasOwnProperty("maxSteerAngle"))
                    object.maxSteerAngle = options.json && !isFinite(message.maxSteerAngle) ? String(message.maxSteerAngle) : message.maxSteerAngle;
                if (message.wheelBase != null && message.hasOwnProperty("wheelBase"))
                    object.wheelBase = options.json && !isFinite(message.wheelBase) ? String(message.wheelBase) : message.wheelBase;
                if (message.maxAcceleration != null && message.hasOwnProperty("maxAcceleration"))
                    object.maxAcceleration = options.json && !isFinite(message.maxAcceleration) ? String(message.maxAcceleration) : message.maxAcceleration;
                if (message.maxBrake != null && message.hasOwnProperty("maxBrake"))
                    object.maxBrake = options.json && !isFinite(message.maxBrake) ? String(message.maxBrake) : message.maxBrake;
                if (message.coastingDeceleration != null && message.hasOwnProperty("coastingDeceleration"))
                    object.coastingDeceleration = options.json && !isFinite(message.coastingDeceleration) ? String(message.coastingDeceleration) : message.coastingDeceleration;
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    object.dimensions = $root.metamoto.types.Vector3.toObject(message.dimensions, options);
                if (message.mass != null && message.hasOwnProperty("mass"))
                    object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.metamoto.types.Vehicle.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this VehicleInfo to JSON.
             * @function toJSON
             * @memberof metamoto.types.VehicleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VehicleInfo;
        })();

        types.VehicleInstance = (function() {

            /**
             * Properties of a VehicleInstance.
             * @memberof metamoto.types
             * @interface IVehicleInstance
             * @property {string|null} [model] VehicleInstance model
             * @property {metamoto.types.Vehicle.Type|null} [type] VehicleInstance type
             * @property {metamoto.types.VehicleInstance.IBody|null} [body] VehicleInstance body
             */

            /**
             * Constructs a new VehicleInstance.
             * @memberof metamoto.types
             * @classdesc Represents a VehicleInstance.
             * @implements IVehicleInstance
             * @constructor
             * @param {metamoto.types.IVehicleInstance=} [properties] Properties to set
             */
            function VehicleInstance(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleInstance model.
             * @member {string} model
             * @memberof metamoto.types.VehicleInstance
             * @instance
             */
            VehicleInstance.prototype.model = "";

            /**
             * VehicleInstance type.
             * @member {metamoto.types.Vehicle.Type} type
             * @memberof metamoto.types.VehicleInstance
             * @instance
             */
            VehicleInstance.prototype.type = 0;

            /**
             * VehicleInstance body.
             * @member {metamoto.types.VehicleInstance.IBody|null|undefined} body
             * @memberof metamoto.types.VehicleInstance
             * @instance
             */
            VehicleInstance.prototype.body = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * VehicleInstance modelOneof.
             * @member {"model"|"type"|undefined} modelOneof
             * @memberof metamoto.types.VehicleInstance
             * @instance
             */
            Object.defineProperty(VehicleInstance.prototype, "modelOneof", {
                get: $util.oneOfGetter($oneOfFields = ["model", "type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VehicleInstance instance using the specified properties.
             * @function create
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {metamoto.types.IVehicleInstance=} [properties] Properties to set
             * @returns {metamoto.types.VehicleInstance} VehicleInstance instance
             */
            VehicleInstance.create = function create(properties) {
                return new VehicleInstance(properties);
            };

            /**
             * Encodes the specified VehicleInstance message. Does not implicitly {@link metamoto.types.VehicleInstance.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {metamoto.types.IVehicleInstance} message VehicleInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleInstance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.model != null && message.hasOwnProperty("model"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.model);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.body != null && message.hasOwnProperty("body"))
                    $root.metamoto.types.VehicleInstance.Body.encode(message.body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VehicleInstance message, length delimited. Does not implicitly {@link metamoto.types.VehicleInstance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {metamoto.types.IVehicleInstance} message VehicleInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleInstance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleInstance message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.VehicleInstance} VehicleInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleInstance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VehicleInstance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.model = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.body = $root.metamoto.types.VehicleInstance.Body.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleInstance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.VehicleInstance} VehicleInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleInstance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleInstance message.
             * @function verify
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleInstance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.model != null && message.hasOwnProperty("model")) {
                    properties.modelOneof = 1;
                    if (!$util.isString(message.model))
                        return "model: string expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    if (properties.modelOneof === 1)
                        return "modelOneof: multiple values";
                    properties.modelOneof = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                    var error = $root.metamoto.types.VehicleInstance.Body.verify(message.body);
                    if (error)
                        return "body." + error;
                }
                return null;
            };

            /**
             * Creates a VehicleInstance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.VehicleInstance} VehicleInstance
             */
            VehicleInstance.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.VehicleInstance)
                    return object;
                var message = new $root.metamoto.types.VehicleInstance();
                if (object.model != null)
                    message.model = String(object.model);
                switch (object.type) {
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "CAR":
                case 2:
                    message.type = 2;
                    break;
                case "TRUCK":
                case 3:
                    message.type = 3;
                    break;
                case "BUS":
                case 4:
                    message.type = 4;
                    break;
                case "MOTORCYCLE":
                case 5:
                    message.type = 5;
                    break;
                case "BICYCLE":
                case 6:
                    message.type = 6;
                    break;
                case "TRAIN":
                case 7:
                    message.type = 7;
                    break;
                case "STREET_CAR":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.body != null) {
                    if (typeof object.body !== "object")
                        throw TypeError(".metamoto.types.VehicleInstance.body: object expected");
                    message.body = $root.metamoto.types.VehicleInstance.Body.fromObject(object.body);
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleInstance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.VehicleInstance
             * @static
             * @param {metamoto.types.VehicleInstance} message VehicleInstance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleInstance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.body = null;
                if (message.model != null && message.hasOwnProperty("model")) {
                    object.model = message.model;
                    if (options.oneofs)
                        object.modelOneof = "model";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.metamoto.types.Vehicle.Type[message.type] : message.type;
                    if (options.oneofs)
                        object.modelOneof = "type";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = $root.metamoto.types.VehicleInstance.Body.toObject(message.body, options);
                return object;
            };

            /**
             * Converts this VehicleInstance to JSON.
             * @function toJSON
             * @memberof metamoto.types.VehicleInstance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleInstance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            VehicleInstance.Body = (function() {

                /**
                 * Properties of a Body.
                 * @memberof metamoto.types.VehicleInstance
                 * @interface IBody
                 * @property {string|null} [paint] Body paint
                 * @property {google.protobuf.IFloatValue|null} [dirt] Body dirt
                 */

                /**
                 * Constructs a new Body.
                 * @memberof metamoto.types.VehicleInstance
                 * @classdesc Represents a Body.
                 * @implements IBody
                 * @constructor
                 * @param {metamoto.types.VehicleInstance.IBody=} [properties] Properties to set
                 */
                function Body(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Body paint.
                 * @member {string} paint
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @instance
                 */
                Body.prototype.paint = "";

                /**
                 * Body dirt.
                 * @member {google.protobuf.IFloatValue|null|undefined} dirt
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @instance
                 */
                Body.prototype.dirt = null;

                /**
                 * Creates a new Body instance using the specified properties.
                 * @function create
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {metamoto.types.VehicleInstance.IBody=} [properties] Properties to set
                 * @returns {metamoto.types.VehicleInstance.Body} Body instance
                 */
                Body.create = function create(properties) {
                    return new Body(properties);
                };

                /**
                 * Encodes the specified Body message. Does not implicitly {@link metamoto.types.VehicleInstance.Body.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {metamoto.types.VehicleInstance.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.paint != null && message.hasOwnProperty("paint"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.paint);
                    if (message.dirt != null && message.hasOwnProperty("dirt"))
                        $root.google.protobuf.FloatValue.encode(message.dirt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Body message, length delimited. Does not implicitly {@link metamoto.types.VehicleInstance.Body.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {metamoto.types.VehicleInstance.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.types.VehicleInstance.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VehicleInstance.Body();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.paint = reader.string();
                            break;
                        case 2:
                            message.dirt = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Body message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.types.VehicleInstance.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Body message.
                 * @function verify
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Body.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.paint != null && message.hasOwnProperty("paint"))
                        if (!$util.isString(message.paint))
                            return "paint: string expected";
                    if (message.dirt != null && message.hasOwnProperty("dirt")) {
                        var error = $root.google.protobuf.FloatValue.verify(message.dirt);
                        if (error)
                            return "dirt." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Body message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.types.VehicleInstance.Body} Body
                 */
                Body.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.types.VehicleInstance.Body)
                        return object;
                    var message = new $root.metamoto.types.VehicleInstance.Body();
                    if (object.paint != null)
                        message.paint = String(object.paint);
                    if (object.dirt != null) {
                        if (typeof object.dirt !== "object")
                            throw TypeError(".metamoto.types.VehicleInstance.Body.dirt: object expected");
                        message.dirt = $root.google.protobuf.FloatValue.fromObject(object.dirt);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Body message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @static
                 * @param {metamoto.types.VehicleInstance.Body} message Body
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Body.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.paint = "";
                        object.dirt = null;
                    }
                    if (message.paint != null && message.hasOwnProperty("paint"))
                        object.paint = message.paint;
                    if (message.dirt != null && message.hasOwnProperty("dirt"))
                        object.dirt = $root.google.protobuf.FloatValue.toObject(message.dirt, options);
                    return object;
                };

                /**
                 * Converts this Body to JSON.
                 * @function toJSON
                 * @memberof metamoto.types.VehicleInstance.Body
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Body.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Body;
            })();

            return VehicleInstance;
        })();

        types.Velocity = (function() {

            /**
             * Properties of a Velocity.
             * @memberof metamoto.types
             * @interface IVelocity
             * @property {metamoto.types.IVector3|null} [linear] Velocity linear
             * @property {metamoto.types.IVector3|null} [angular] Velocity angular
             */

            /**
             * Constructs a new Velocity.
             * @memberof metamoto.types
             * @classdesc Represents a Velocity.
             * @implements IVelocity
             * @constructor
             * @param {metamoto.types.IVelocity=} [properties] Properties to set
             */
            function Velocity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Velocity linear.
             * @member {metamoto.types.IVector3|null|undefined} linear
             * @memberof metamoto.types.Velocity
             * @instance
             */
            Velocity.prototype.linear = null;

            /**
             * Velocity angular.
             * @member {metamoto.types.IVector3|null|undefined} angular
             * @memberof metamoto.types.Velocity
             * @instance
             */
            Velocity.prototype.angular = null;

            /**
             * Creates a new Velocity instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Velocity
             * @static
             * @param {metamoto.types.IVelocity=} [properties] Properties to set
             * @returns {metamoto.types.Velocity} Velocity instance
             */
            Velocity.create = function create(properties) {
                return new Velocity(properties);
            };

            /**
             * Encodes the specified Velocity message. Does not implicitly {@link metamoto.types.Velocity.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Velocity
             * @static
             * @param {metamoto.types.IVelocity} message Velocity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Velocity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.linear != null && message.hasOwnProperty("linear"))
                    $root.metamoto.types.Vector3.encode(message.linear, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.angular != null && message.hasOwnProperty("angular"))
                    $root.metamoto.types.Vector3.encode(message.angular, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Velocity message, length delimited. Does not implicitly {@link metamoto.types.Velocity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Velocity
             * @static
             * @param {metamoto.types.IVelocity} message Velocity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Velocity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Velocity message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Velocity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Velocity} Velocity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Velocity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Velocity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.linear = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.angular = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Velocity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Velocity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Velocity} Velocity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Velocity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Velocity message.
             * @function verify
             * @memberof metamoto.types.Velocity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Velocity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.linear != null && message.hasOwnProperty("linear")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linear);
                    if (error)
                        return "linear." + error;
                }
                if (message.angular != null && message.hasOwnProperty("angular")) {
                    var error = $root.metamoto.types.Vector3.verify(message.angular);
                    if (error)
                        return "angular." + error;
                }
                return null;
            };

            /**
             * Creates a Velocity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Velocity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Velocity} Velocity
             */
            Velocity.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Velocity)
                    return object;
                var message = new $root.metamoto.types.Velocity();
                if (object.linear != null) {
                    if (typeof object.linear !== "object")
                        throw TypeError(".metamoto.types.Velocity.linear: object expected");
                    message.linear = $root.metamoto.types.Vector3.fromObject(object.linear);
                }
                if (object.angular != null) {
                    if (typeof object.angular !== "object")
                        throw TypeError(".metamoto.types.Velocity.angular: object expected");
                    message.angular = $root.metamoto.types.Vector3.fromObject(object.angular);
                }
                return message;
            };

            /**
             * Creates a plain object from a Velocity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Velocity
             * @static
             * @param {metamoto.types.Velocity} message Velocity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Velocity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.linear = null;
                    object.angular = null;
                }
                if (message.linear != null && message.hasOwnProperty("linear"))
                    object.linear = $root.metamoto.types.Vector3.toObject(message.linear, options);
                if (message.angular != null && message.hasOwnProperty("angular"))
                    object.angular = $root.metamoto.types.Vector3.toObject(message.angular, options);
                return object;
            };

            /**
             * Converts this Velocity to JSON.
             * @function toJSON
             * @memberof metamoto.types.Velocity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Velocity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Velocity;
        })();

        types.Version = (function() {

            /**
             * Properties of a Version.
             * @memberof metamoto.types
             * @interface IVersion
             * @property {number|null} [major] Version major
             * @property {number|null} [minor] Version minor
             * @property {number|null} [patch] Version patch
             * @property {string|null} [build] Version build
             * @property {string|null} [timestamp] Version timestamp
             */

            /**
             * Constructs a new Version.
             * @memberof metamoto.types
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {metamoto.types.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Version major.
             * @member {number} major
             * @memberof metamoto.types.Version
             * @instance
             */
            Version.prototype.major = 0;

            /**
             * Version minor.
             * @member {number} minor
             * @memberof metamoto.types.Version
             * @instance
             */
            Version.prototype.minor = 0;

            /**
             * Version patch.
             * @member {number} patch
             * @memberof metamoto.types.Version
             * @instance
             */
            Version.prototype.patch = 0;

            /**
             * Version build.
             * @member {string} build
             * @memberof metamoto.types.Version
             * @instance
             */
            Version.prototype.build = "";

            /**
             * Version timestamp.
             * @member {string} timestamp
             * @memberof metamoto.types.Version
             * @instance
             */
            Version.prototype.timestamp = "";

            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Version
             * @static
             * @param {metamoto.types.IVersion=} [properties] Properties to set
             * @returns {metamoto.types.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };

            /**
             * Encodes the specified Version message. Does not implicitly {@link metamoto.types.Version.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Version
             * @static
             * @param {metamoto.types.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.major != null && message.hasOwnProperty("major"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.major);
                if (message.minor != null && message.hasOwnProperty("minor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minor);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.patch);
                if (message.build != null && message.hasOwnProperty("build"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.build);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link metamoto.types.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Version
             * @static
             * @param {metamoto.types.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Version();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.major = reader.int32();
                        break;
                    case 2:
                        message.minor = reader.int32();
                        break;
                    case 3:
                        message.patch = reader.int32();
                        break;
                    case 4:
                        message.build = reader.string();
                        break;
                    case 5:
                        message.timestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Version message.
             * @function verify
             * @memberof metamoto.types.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.major != null && message.hasOwnProperty("major"))
                    if (!$util.isInteger(message.major))
                        return "major: integer expected";
                if (message.minor != null && message.hasOwnProperty("minor"))
                    if (!$util.isInteger(message.minor))
                        return "minor: integer expected";
                if (message.patch != null && message.hasOwnProperty("patch"))
                    if (!$util.isInteger(message.patch))
                        return "patch: integer expected";
                if (message.build != null && message.hasOwnProperty("build"))
                    if (!$util.isString(message.build))
                        return "build: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                return null;
            };

            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Version)
                    return object;
                var message = new $root.metamoto.types.Version();
                if (object.major != null)
                    message.major = object.major | 0;
                if (object.minor != null)
                    message.minor = object.minor | 0;
                if (object.patch != null)
                    message.patch = object.patch | 0;
                if (object.build != null)
                    message.build = String(object.build);
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                return message;
            };

            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Version
             * @static
             * @param {metamoto.types.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.major = 0;
                    object.minor = 0;
                    object.patch = 0;
                    object.build = "";
                    object.timestamp = "";
                }
                if (message.major != null && message.hasOwnProperty("major"))
                    object.major = message.major;
                if (message.minor != null && message.hasOwnProperty("minor"))
                    object.minor = message.minor;
                if (message.patch != null && message.hasOwnProperty("patch"))
                    object.patch = message.patch;
                if (message.build != null && message.hasOwnProperty("build"))
                    object.build = message.build;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };

            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof metamoto.types.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Version;
        })();

        types.VisualPathPoint = (function() {

            /**
             * Properties of a VisualPathPoint.
             * @memberof metamoto.types
             * @interface IVisualPathPoint
             * @property {metamoto.types.IVector3|null} [position] VisualPathPoint position
             * @property {metamoto.types.IVector3|null} [normal] VisualPathPoint normal
             * @property {number|null} [smoothness] VisualPathPoint smoothness
             * @property {boolean|null} [glue] VisualPathPoint glue
             * @property {number|null} [width] VisualPathPoint width
             * @property {string|null} [color] VisualPathPoint color
             * @property {number|null} [transparency] VisualPathPoint transparency
             */

            /**
             * Constructs a new VisualPathPoint.
             * @memberof metamoto.types
             * @classdesc Represents a VisualPathPoint.
             * @implements IVisualPathPoint
             * @constructor
             * @param {metamoto.types.IVisualPathPoint=} [properties] Properties to set
             */
            function VisualPathPoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisualPathPoint position.
             * @member {metamoto.types.IVector3|null|undefined} position
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.position = null;

            /**
             * VisualPathPoint normal.
             * @member {metamoto.types.IVector3|null|undefined} normal
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.normal = null;

            /**
             * VisualPathPoint smoothness.
             * @member {number} smoothness
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.smoothness = 0;

            /**
             * VisualPathPoint glue.
             * @member {boolean} glue
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.glue = false;

            /**
             * VisualPathPoint width.
             * @member {number} width
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.width = 0;

            /**
             * VisualPathPoint color.
             * @member {string} color
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.color = "";

            /**
             * VisualPathPoint transparency.
             * @member {number} transparency
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             */
            VisualPathPoint.prototype.transparency = 0;

            /**
             * Creates a new VisualPathPoint instance using the specified properties.
             * @function create
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {metamoto.types.IVisualPathPoint=} [properties] Properties to set
             * @returns {metamoto.types.VisualPathPoint} VisualPathPoint instance
             */
            VisualPathPoint.create = function create(properties) {
                return new VisualPathPoint(properties);
            };

            /**
             * Encodes the specified VisualPathPoint message. Does not implicitly {@link metamoto.types.VisualPathPoint.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {metamoto.types.IVisualPathPoint} message VisualPathPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualPathPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.metamoto.types.Vector3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.normal != null && message.hasOwnProperty("normal"))
                    $root.metamoto.types.Vector3.encode(message.normal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.smoothness != null && message.hasOwnProperty("smoothness"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.smoothness);
                if (message.glue != null && message.hasOwnProperty("glue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.glue);
                if (message.width != null && message.hasOwnProperty("width"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.width);
                if (message.color != null && message.hasOwnProperty("color"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.color);
                if (message.transparency != null && message.hasOwnProperty("transparency"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.transparency);
                return writer;
            };

            /**
             * Encodes the specified VisualPathPoint message, length delimited. Does not implicitly {@link metamoto.types.VisualPathPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {metamoto.types.IVisualPathPoint} message VisualPathPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualPathPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisualPathPoint message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.VisualPathPoint} VisualPathPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualPathPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VisualPathPoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.normal = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.smoothness = reader.uint32();
                        break;
                    case 4:
                        message.glue = reader.bool();
                        break;
                    case 5:
                        message.width = reader.float();
                        break;
                    case 6:
                        message.color = reader.string();
                        break;
                    case 7:
                        message.transparency = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisualPathPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.VisualPathPoint} VisualPathPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualPathPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisualPathPoint message.
             * @function verify
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VisualPathPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.metamoto.types.Vector3.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.normal != null && message.hasOwnProperty("normal")) {
                    var error = $root.metamoto.types.Vector3.verify(message.normal);
                    if (error)
                        return "normal." + error;
                }
                if (message.smoothness != null && message.hasOwnProperty("smoothness"))
                    if (!$util.isInteger(message.smoothness))
                        return "smoothness: integer expected";
                if (message.glue != null && message.hasOwnProperty("glue"))
                    if (typeof message.glue !== "boolean")
                        return "glue: boolean expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (typeof message.width !== "number")
                        return "width: number expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isString(message.color))
                        return "color: string expected";
                if (message.transparency != null && message.hasOwnProperty("transparency"))
                    if (typeof message.transparency !== "number")
                        return "transparency: number expected";
                return null;
            };

            /**
             * Creates a VisualPathPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.VisualPathPoint} VisualPathPoint
             */
            VisualPathPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.VisualPathPoint)
                    return object;
                var message = new $root.metamoto.types.VisualPathPoint();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".metamoto.types.VisualPathPoint.position: object expected");
                    message.position = $root.metamoto.types.Vector3.fromObject(object.position);
                }
                if (object.normal != null) {
                    if (typeof object.normal !== "object")
                        throw TypeError(".metamoto.types.VisualPathPoint.normal: object expected");
                    message.normal = $root.metamoto.types.Vector3.fromObject(object.normal);
                }
                if (object.smoothness != null)
                    message.smoothness = object.smoothness >>> 0;
                if (object.glue != null)
                    message.glue = Boolean(object.glue);
                if (object.width != null)
                    message.width = Number(object.width);
                if (object.color != null)
                    message.color = String(object.color);
                if (object.transparency != null)
                    message.transparency = Number(object.transparency);
                return message;
            };

            /**
             * Creates a plain object from a VisualPathPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.VisualPathPoint
             * @static
             * @param {metamoto.types.VisualPathPoint} message VisualPathPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisualPathPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.normal = null;
                    object.smoothness = 0;
                    object.glue = false;
                    object.width = 0;
                    object.color = "";
                    object.transparency = 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.metamoto.types.Vector3.toObject(message.position, options);
                if (message.normal != null && message.hasOwnProperty("normal"))
                    object.normal = $root.metamoto.types.Vector3.toObject(message.normal, options);
                if (message.smoothness != null && message.hasOwnProperty("smoothness"))
                    object.smoothness = message.smoothness;
                if (message.glue != null && message.hasOwnProperty("glue"))
                    object.glue = message.glue;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = message.color;
                if (message.transparency != null && message.hasOwnProperty("transparency"))
                    object.transparency = options.json && !isFinite(message.transparency) ? String(message.transparency) : message.transparency;
                return object;
            };

            /**
             * Converts this VisualPathPoint to JSON.
             * @function toJSON
             * @memberof metamoto.types.VisualPathPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VisualPathPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VisualPathPoint;
        })();

        types.VisualPath = (function() {

            /**
             * Properties of a VisualPath.
             * @memberof metamoto.types
             * @interface IVisualPath
             * @property {Array.<metamoto.types.IVisualPathPoint>|null} [pathPoints] VisualPath pathPoints
             */

            /**
             * Constructs a new VisualPath.
             * @memberof metamoto.types
             * @classdesc Represents a VisualPath.
             * @implements IVisualPath
             * @constructor
             * @param {metamoto.types.IVisualPath=} [properties] Properties to set
             */
            function VisualPath(properties) {
                this.pathPoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisualPath pathPoints.
             * @member {Array.<metamoto.types.IVisualPathPoint>} pathPoints
             * @memberof metamoto.types.VisualPath
             * @instance
             */
            VisualPath.prototype.pathPoints = $util.emptyArray;

            /**
             * Creates a new VisualPath instance using the specified properties.
             * @function create
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {metamoto.types.IVisualPath=} [properties] Properties to set
             * @returns {metamoto.types.VisualPath} VisualPath instance
             */
            VisualPath.create = function create(properties) {
                return new VisualPath(properties);
            };

            /**
             * Encodes the specified VisualPath message. Does not implicitly {@link metamoto.types.VisualPath.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {metamoto.types.IVisualPath} message VisualPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualPath.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pathPoints != null && message.pathPoints.length)
                    for (var i = 0; i < message.pathPoints.length; ++i)
                        $root.metamoto.types.VisualPathPoint.encode(message.pathPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VisualPath message, length delimited. Does not implicitly {@link metamoto.types.VisualPath.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {metamoto.types.IVisualPath} message VisualPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualPath.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisualPath message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.VisualPath} VisualPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualPath.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.VisualPath();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pathPoints && message.pathPoints.length))
                            message.pathPoints = [];
                        message.pathPoints.push($root.metamoto.types.VisualPathPoint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisualPath message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.VisualPath} VisualPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualPath.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisualPath message.
             * @function verify
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VisualPath.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pathPoints != null && message.hasOwnProperty("pathPoints")) {
                    if (!Array.isArray(message.pathPoints))
                        return "pathPoints: array expected";
                    for (var i = 0; i < message.pathPoints.length; ++i) {
                        var error = $root.metamoto.types.VisualPathPoint.verify(message.pathPoints[i]);
                        if (error)
                            return "pathPoints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VisualPath message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.VisualPath} VisualPath
             */
            VisualPath.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.VisualPath)
                    return object;
                var message = new $root.metamoto.types.VisualPath();
                if (object.pathPoints) {
                    if (!Array.isArray(object.pathPoints))
                        throw TypeError(".metamoto.types.VisualPath.pathPoints: array expected");
                    message.pathPoints = [];
                    for (var i = 0; i < object.pathPoints.length; ++i) {
                        if (typeof object.pathPoints[i] !== "object")
                            throw TypeError(".metamoto.types.VisualPath.pathPoints: object expected");
                        message.pathPoints[i] = $root.metamoto.types.VisualPathPoint.fromObject(object.pathPoints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VisualPath message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.VisualPath
             * @static
             * @param {metamoto.types.VisualPath} message VisualPath
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisualPath.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pathPoints = [];
                if (message.pathPoints && message.pathPoints.length) {
                    object.pathPoints = [];
                    for (var j = 0; j < message.pathPoints.length; ++j)
                        object.pathPoints[j] = $root.metamoto.types.VisualPathPoint.toObject(message.pathPoints[j], options);
                }
                return object;
            };

            /**
             * Converts this VisualPath to JSON.
             * @function toJSON
             * @memberof metamoto.types.VisualPath
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VisualPath.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VisualPath;
        })();

        types.Waypoint = (function() {

            /**
             * Properties of a Waypoint.
             * @memberof metamoto.types
             * @interface IWaypoint
             * @property {metamoto.types.IPose|null} [worldPoint] Waypoint worldPoint
             * @property {metamoto.types.IRoadPoint|null} [roadPoint] Waypoint roadPoint
             * @property {google.protobuf.IFloatValue|null} [targetSpeed] Waypoint targetSpeed
             * @property {boolean|null} [purePursuit] Waypoint purePursuit
             * @property {number|null} [idleTime] Waypoint idleTime
             * @property {string|null} [relativeObjectId] Waypoint relativeObjectId
             */

            /**
             * Constructs a new Waypoint.
             * @memberof metamoto.types
             * @classdesc Represents a Waypoint.
             * @implements IWaypoint
             * @constructor
             * @param {metamoto.types.IWaypoint=} [properties] Properties to set
             */
            function Waypoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Waypoint worldPoint.
             * @member {metamoto.types.IPose|null|undefined} worldPoint
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.worldPoint = null;

            /**
             * Waypoint roadPoint.
             * @member {metamoto.types.IRoadPoint|null|undefined} roadPoint
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.roadPoint = null;

            /**
             * Waypoint targetSpeed.
             * @member {google.protobuf.IFloatValue|null|undefined} targetSpeed
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.targetSpeed = null;

            /**
             * Waypoint purePursuit.
             * @member {boolean} purePursuit
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.purePursuit = false;

            /**
             * Waypoint idleTime.
             * @member {number} idleTime
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.idleTime = 0;

            /**
             * Waypoint relativeObjectId.
             * @member {string} relativeObjectId
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Waypoint.prototype.relativeObjectId = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Waypoint pointOneof.
             * @member {"worldPoint"|"roadPoint"|undefined} pointOneof
             * @memberof metamoto.types.Waypoint
             * @instance
             */
            Object.defineProperty(Waypoint.prototype, "pointOneof", {
                get: $util.oneOfGetter($oneOfFields = ["worldPoint", "roadPoint"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Waypoint instance using the specified properties.
             * @function create
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {metamoto.types.IWaypoint=} [properties] Properties to set
             * @returns {metamoto.types.Waypoint} Waypoint instance
             */
            Waypoint.create = function create(properties) {
                return new Waypoint(properties);
            };

            /**
             * Encodes the specified Waypoint message. Does not implicitly {@link metamoto.types.Waypoint.verify|verify} messages.
             * @function encode
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {metamoto.types.IWaypoint} message Waypoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Waypoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint"))
                    $root.metamoto.types.Pose.encode(message.worldPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint"))
                    $root.metamoto.types.RoadPoint.encode(message.roadPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                    $root.google.protobuf.FloatValue.encode(message.targetSpeed, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.purePursuit != null && message.hasOwnProperty("purePursuit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.purePursuit);
                if (message.idleTime != null && message.hasOwnProperty("idleTime"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.idleTime);
                if (message.relativeObjectId != null && message.hasOwnProperty("relativeObjectId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.relativeObjectId);
                return writer;
            };

            /**
             * Encodes the specified Waypoint message, length delimited. Does not implicitly {@link metamoto.types.Waypoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {metamoto.types.IWaypoint} message Waypoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Waypoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Waypoint message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.types.Waypoint} Waypoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Waypoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.types.Waypoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.worldPoint = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.roadPoint = $root.metamoto.types.RoadPoint.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.targetSpeed = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.purePursuit = reader.bool();
                        break;
                    case 5:
                        message.idleTime = reader.float();
                        break;
                    case 6:
                        message.relativeObjectId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Waypoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.types.Waypoint} Waypoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Waypoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Waypoint message.
             * @function verify
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Waypoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint")) {
                    properties.pointOneof = 1;
                    {
                        var error = $root.metamoto.types.Pose.verify(message.worldPoint);
                        if (error)
                            return "worldPoint." + error;
                    }
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    if (properties.pointOneof === 1)
                        return "pointOneof: multiple values";
                    properties.pointOneof = 1;
                    {
                        var error = $root.metamoto.types.RoadPoint.verify(message.roadPoint);
                        if (error)
                            return "roadPoint." + error;
                    }
                }
                if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.targetSpeed);
                    if (error)
                        return "targetSpeed." + error;
                }
                if (message.purePursuit != null && message.hasOwnProperty("purePursuit"))
                    if (typeof message.purePursuit !== "boolean")
                        return "purePursuit: boolean expected";
                if (message.idleTime != null && message.hasOwnProperty("idleTime"))
                    if (typeof message.idleTime !== "number")
                        return "idleTime: number expected";
                if (message.relativeObjectId != null && message.hasOwnProperty("relativeObjectId"))
                    if (!$util.isString(message.relativeObjectId))
                        return "relativeObjectId: string expected";
                return null;
            };

            /**
             * Creates a Waypoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.types.Waypoint} Waypoint
             */
            Waypoint.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.types.Waypoint)
                    return object;
                var message = new $root.metamoto.types.Waypoint();
                if (object.worldPoint != null) {
                    if (typeof object.worldPoint !== "object")
                        throw TypeError(".metamoto.types.Waypoint.worldPoint: object expected");
                    message.worldPoint = $root.metamoto.types.Pose.fromObject(object.worldPoint);
                }
                if (object.roadPoint != null) {
                    if (typeof object.roadPoint !== "object")
                        throw TypeError(".metamoto.types.Waypoint.roadPoint: object expected");
                    message.roadPoint = $root.metamoto.types.RoadPoint.fromObject(object.roadPoint);
                }
                if (object.targetSpeed != null) {
                    if (typeof object.targetSpeed !== "object")
                        throw TypeError(".metamoto.types.Waypoint.targetSpeed: object expected");
                    message.targetSpeed = $root.google.protobuf.FloatValue.fromObject(object.targetSpeed);
                }
                if (object.purePursuit != null)
                    message.purePursuit = Boolean(object.purePursuit);
                if (object.idleTime != null)
                    message.idleTime = Number(object.idleTime);
                if (object.relativeObjectId != null)
                    message.relativeObjectId = String(object.relativeObjectId);
                return message;
            };

            /**
             * Creates a plain object from a Waypoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.types.Waypoint
             * @static
             * @param {metamoto.types.Waypoint} message Waypoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Waypoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.targetSpeed = null;
                    object.purePursuit = false;
                    object.idleTime = 0;
                    object.relativeObjectId = "";
                }
                if (message.worldPoint != null && message.hasOwnProperty("worldPoint")) {
                    object.worldPoint = $root.metamoto.types.Pose.toObject(message.worldPoint, options);
                    if (options.oneofs)
                        object.pointOneof = "worldPoint";
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    object.roadPoint = $root.metamoto.types.RoadPoint.toObject(message.roadPoint, options);
                    if (options.oneofs)
                        object.pointOneof = "roadPoint";
                }
                if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                    object.targetSpeed = $root.google.protobuf.FloatValue.toObject(message.targetSpeed, options);
                if (message.purePursuit != null && message.hasOwnProperty("purePursuit"))
                    object.purePursuit = message.purePursuit;
                if (message.idleTime != null && message.hasOwnProperty("idleTime"))
                    object.idleTime = options.json && !isFinite(message.idleTime) ? String(message.idleTime) : message.idleTime;
                if (message.relativeObjectId != null && message.hasOwnProperty("relativeObjectId"))
                    object.relativeObjectId = message.relativeObjectId;
                return object;
            };

            /**
             * Converts this Waypoint to JSON.
             * @function toJSON
             * @memberof metamoto.types.Waypoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Waypoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Waypoint;
        })();

        return types;
    })();

    metamoto.messages = (function() {

        /**
         * Namespace messages.
         * @memberof metamoto
         * @namespace
         */
        var messages = {};

        messages.Camera = (function() {

            /**
             * Properties of a Camera.
             * @memberof metamoto.messages
             * @interface ICamera
             * @property {metamoto.types.IImage|null} [image] Camera image
             * @property {Array.<metamoto.types.ICameraObject>|null} [objects] Camera objects
             * @property {Array.<number>|null} [K] Camera K
             * @property {Array.<number>|null} [D] Camera D
             * @property {Array.<number>|null} [P] Camera P
             */

            /**
             * Constructs a new Camera.
             * @memberof metamoto.messages
             * @classdesc Represents a Camera.
             * @implements ICamera
             * @constructor
             * @param {metamoto.messages.ICamera=} [properties] Properties to set
             */
            function Camera(properties) {
                this.objects = [];
                this.K = [];
                this.D = [];
                this.P = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Camera image.
             * @member {metamoto.types.IImage|null|undefined} image
             * @memberof metamoto.messages.Camera
             * @instance
             */
            Camera.prototype.image = null;

            /**
             * Camera objects.
             * @member {Array.<metamoto.types.ICameraObject>} objects
             * @memberof metamoto.messages.Camera
             * @instance
             */
            Camera.prototype.objects = $util.emptyArray;

            /**
             * Camera K.
             * @member {Array.<number>} K
             * @memberof metamoto.messages.Camera
             * @instance
             */
            Camera.prototype.K = $util.emptyArray;

            /**
             * Camera D.
             * @member {Array.<number>} D
             * @memberof metamoto.messages.Camera
             * @instance
             */
            Camera.prototype.D = $util.emptyArray;

            /**
             * Camera P.
             * @member {Array.<number>} P
             * @memberof metamoto.messages.Camera
             * @instance
             */
            Camera.prototype.P = $util.emptyArray;

            /**
             * Creates a new Camera instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Camera
             * @static
             * @param {metamoto.messages.ICamera=} [properties] Properties to set
             * @returns {metamoto.messages.Camera} Camera instance
             */
            Camera.create = function create(properties) {
                return new Camera(properties);
            };

            /**
             * Encodes the specified Camera message. Does not implicitly {@link metamoto.messages.Camera.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Camera
             * @static
             * @param {metamoto.messages.ICamera} message Camera message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Camera.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.image != null && message.hasOwnProperty("image"))
                    $root.metamoto.types.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.objects != null && message.objects.length)
                    for (var i = 0; i < message.objects.length; ++i)
                        $root.metamoto.types.CameraObject.encode(message.objects[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.K != null && message.K.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.K.length; ++i)
                        writer.float(message.K[i]);
                    writer.ldelim();
                }
                if (message.D != null && message.D.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.D.length; ++i)
                        writer.float(message.D[i]);
                    writer.ldelim();
                }
                if (message.P != null && message.P.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (var i = 0; i < message.P.length; ++i)
                        writer.float(message.P[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified Camera message, length delimited. Does not implicitly {@link metamoto.messages.Camera.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Camera
             * @static
             * @param {metamoto.messages.ICamera} message Camera message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Camera.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Camera message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Camera
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Camera} Camera
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Camera.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Camera();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.image = $root.metamoto.types.Image.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push($root.metamoto.types.CameraObject.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.K && message.K.length))
                            message.K = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.K.push(reader.float());
                        } else
                            message.K.push(reader.float());
                        break;
                    case 4:
                        if (!(message.D && message.D.length))
                            message.D = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.D.push(reader.float());
                        } else
                            message.D.push(reader.float());
                        break;
                    case 5:
                        if (!(message.P && message.P.length))
                            message.P = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.P.push(reader.float());
                        } else
                            message.P.push(reader.float());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Camera message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Camera
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Camera} Camera
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Camera.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Camera message.
             * @function verify
             * @memberof metamoto.messages.Camera
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Camera.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.image != null && message.hasOwnProperty("image")) {
                    var error = $root.metamoto.types.Image.verify(message.image);
                    if (error)
                        return "image." + error;
                }
                if (message.objects != null && message.hasOwnProperty("objects")) {
                    if (!Array.isArray(message.objects))
                        return "objects: array expected";
                    for (var i = 0; i < message.objects.length; ++i) {
                        var error = $root.metamoto.types.CameraObject.verify(message.objects[i]);
                        if (error)
                            return "objects." + error;
                    }
                }
                if (message.K != null && message.hasOwnProperty("K")) {
                    if (!Array.isArray(message.K))
                        return "K: array expected";
                    for (var i = 0; i < message.K.length; ++i)
                        if (typeof message.K[i] !== "number")
                            return "K: number[] expected";
                }
                if (message.D != null && message.hasOwnProperty("D")) {
                    if (!Array.isArray(message.D))
                        return "D: array expected";
                    for (var i = 0; i < message.D.length; ++i)
                        if (typeof message.D[i] !== "number")
                            return "D: number[] expected";
                }
                if (message.P != null && message.hasOwnProperty("P")) {
                    if (!Array.isArray(message.P))
                        return "P: array expected";
                    for (var i = 0; i < message.P.length; ++i)
                        if (typeof message.P[i] !== "number")
                            return "P: number[] expected";
                }
                return null;
            };

            /**
             * Creates a Camera message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Camera
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Camera} Camera
             */
            Camera.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Camera)
                    return object;
                var message = new $root.metamoto.messages.Camera();
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".metamoto.messages.Camera.image: object expected");
                    message.image = $root.metamoto.types.Image.fromObject(object.image);
                }
                if (object.objects) {
                    if (!Array.isArray(object.objects))
                        throw TypeError(".metamoto.messages.Camera.objects: array expected");
                    message.objects = [];
                    for (var i = 0; i < object.objects.length; ++i) {
                        if (typeof object.objects[i] !== "object")
                            throw TypeError(".metamoto.messages.Camera.objects: object expected");
                        message.objects[i] = $root.metamoto.types.CameraObject.fromObject(object.objects[i]);
                    }
                }
                if (object.K) {
                    if (!Array.isArray(object.K))
                        throw TypeError(".metamoto.messages.Camera.K: array expected");
                    message.K = [];
                    for (var i = 0; i < object.K.length; ++i)
                        message.K[i] = Number(object.K[i]);
                }
                if (object.D) {
                    if (!Array.isArray(object.D))
                        throw TypeError(".metamoto.messages.Camera.D: array expected");
                    message.D = [];
                    for (var i = 0; i < object.D.length; ++i)
                        message.D[i] = Number(object.D[i]);
                }
                if (object.P) {
                    if (!Array.isArray(object.P))
                        throw TypeError(".metamoto.messages.Camera.P: array expected");
                    message.P = [];
                    for (var i = 0; i < object.P.length; ++i)
                        message.P[i] = Number(object.P[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Camera message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Camera
             * @static
             * @param {metamoto.messages.Camera} message Camera
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Camera.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.objects = [];
                    object.K = [];
                    object.D = [];
                    object.P = [];
                }
                if (options.defaults)
                    object.image = null;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.metamoto.types.Image.toObject(message.image, options);
                if (message.objects && message.objects.length) {
                    object.objects = [];
                    for (var j = 0; j < message.objects.length; ++j)
                        object.objects[j] = $root.metamoto.types.CameraObject.toObject(message.objects[j], options);
                }
                if (message.K && message.K.length) {
                    object.K = [];
                    for (var j = 0; j < message.K.length; ++j)
                        object.K[j] = options.json && !isFinite(message.K[j]) ? String(message.K[j]) : message.K[j];
                }
                if (message.D && message.D.length) {
                    object.D = [];
                    for (var j = 0; j < message.D.length; ++j)
                        object.D[j] = options.json && !isFinite(message.D[j]) ? String(message.D[j]) : message.D[j];
                }
                if (message.P && message.P.length) {
                    object.P = [];
                    for (var j = 0; j < message.P.length; ++j)
                        object.P[j] = options.json && !isFinite(message.P[j]) ? String(message.P[j]) : message.P[j];
                }
                return object;
            };

            /**
             * Converts this Camera to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Camera
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Camera.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Camera;
        })();

        messages.Header = (function() {

            /**
             * Properties of a Header.
             * @memberof metamoto.messages
             * @interface IHeader
             * @property {number|null} [time] Header time
             */

            /**
             * Constructs a new Header.
             * @memberof metamoto.messages
             * @classdesc Represents a Header.
             * @implements IHeader
             * @constructor
             * @param {metamoto.messages.IHeader=} [properties] Properties to set
             */
            function Header(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Header time.
             * @member {number} time
             * @memberof metamoto.messages.Header
             * @instance
             */
            Header.prototype.time = 0;

            /**
             * Creates a new Header instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Header
             * @static
             * @param {metamoto.messages.IHeader=} [properties] Properties to set
             * @returns {metamoto.messages.Header} Header instance
             */
            Header.create = function create(properties) {
                return new Header(properties);
            };

            /**
             * Encodes the specified Header message. Does not implicitly {@link metamoto.messages.Header.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Header
             * @static
             * @param {metamoto.messages.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && message.hasOwnProperty("time"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                return writer;
            };

            /**
             * Encodes the specified Header message, length delimited. Does not implicitly {@link metamoto.messages.Header.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Header
             * @static
             * @param {metamoto.messages.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Header message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Header();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Header message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Header message.
             * @function verify
             * @memberof metamoto.messages.Header
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Header.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                return null;
            };

            /**
             * Creates a Header message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Header
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Header} Header
             */
            Header.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Header)
                    return object;
                var message = new $root.metamoto.messages.Header();
                if (object.time != null)
                    message.time = Number(object.time);
                return message;
            };

            /**
             * Creates a plain object from a Header message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Header
             * @static
             * @param {metamoto.messages.Header} message Header
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Header.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.time = 0;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                return object;
            };

            /**
             * Converts this Header to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Header
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Header.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Header;
        })();

        messages.DataBusMessage = (function() {

            /**
             * Properties of a DataBusMessage.
             * @memberof metamoto.messages
             * @interface IDataBusMessage
             * @property {metamoto.messages.IHeader|null} [header] DataBusMessage header
             * @property {metamoto.messages.IVehicleState|null} [vehicleState] DataBusMessage vehicleState
             * @property {metamoto.messages.IVehicleControls|null} [vehicleControls] DataBusMessage vehicleControls
             * @property {metamoto.messages.ICamera|null} [camera] DataBusMessage camera
             * @property {metamoto.messages.ILidar|null} [lidar] DataBusMessage lidar
             * @property {metamoto.messages.IRadar|null} [radar] DataBusMessage radar
             * @property {metamoto.messages.IGPS|null} [gps] DataBusMessage gps
             * @property {metamoto.messages.IIMU|null} [imu] DataBusMessage imu
             * @property {metamoto.messages.ILocalizer|null} [localizer] DataBusMessage localizer
             * @property {metamoto.messages.IV2X|null} [v2x] DataBusMessage v2x
             * @property {metamoto.messages.IEvent|null} [event] DataBusMessage event
             * @property {metamoto.messages.IPerception|null} [perception] DataBusMessage perception
             * @property {metamoto.messages.IGroundTruth|null} [groundTruth] DataBusMessage groundTruth
             * @property {google.protobuf.IAny|null} [other] DataBusMessage other
             */

            /**
             * Constructs a new DataBusMessage.
             * @memberof metamoto.messages
             * @classdesc Represents a DataBusMessage.
             * @implements IDataBusMessage
             * @constructor
             * @param {metamoto.messages.IDataBusMessage=} [properties] Properties to set
             */
            function DataBusMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DataBusMessage header.
             * @member {metamoto.messages.IHeader|null|undefined} header
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.header = null;

            /**
             * DataBusMessage vehicleState.
             * @member {metamoto.messages.IVehicleState|null|undefined} vehicleState
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.vehicleState = null;

            /**
             * DataBusMessage vehicleControls.
             * @member {metamoto.messages.IVehicleControls|null|undefined} vehicleControls
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.vehicleControls = null;

            /**
             * DataBusMessage camera.
             * @member {metamoto.messages.ICamera|null|undefined} camera
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.camera = null;

            /**
             * DataBusMessage lidar.
             * @member {metamoto.messages.ILidar|null|undefined} lidar
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.lidar = null;

            /**
             * DataBusMessage radar.
             * @member {metamoto.messages.IRadar|null|undefined} radar
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.radar = null;

            /**
             * DataBusMessage gps.
             * @member {metamoto.messages.IGPS|null|undefined} gps
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.gps = null;

            /**
             * DataBusMessage imu.
             * @member {metamoto.messages.IIMU|null|undefined} imu
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.imu = null;

            /**
             * DataBusMessage localizer.
             * @member {metamoto.messages.ILocalizer|null|undefined} localizer
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.localizer = null;

            /**
             * DataBusMessage v2x.
             * @member {metamoto.messages.IV2X|null|undefined} v2x
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.v2x = null;

            /**
             * DataBusMessage event.
             * @member {metamoto.messages.IEvent|null|undefined} event
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.event = null;

            /**
             * DataBusMessage perception.
             * @member {metamoto.messages.IPerception|null|undefined} perception
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.perception = null;

            /**
             * DataBusMessage groundTruth.
             * @member {metamoto.messages.IGroundTruth|null|undefined} groundTruth
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.groundTruth = null;

            /**
             * DataBusMessage other.
             * @member {google.protobuf.IAny|null|undefined} other
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            DataBusMessage.prototype.other = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * DataBusMessage dataOneof.
             * @member {"vehicleState"|"vehicleControls"|"camera"|"lidar"|"radar"|"gps"|"imu"|"localizer"|"v2x"|"event"|"perception"|"groundTruth"|"other"|undefined} dataOneof
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             */
            Object.defineProperty(DataBusMessage.prototype, "dataOneof", {
                get: $util.oneOfGetter($oneOfFields = ["vehicleState", "vehicleControls", "camera", "lidar", "radar", "gps", "imu", "localizer", "v2x", "event", "perception", "groundTruth", "other"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DataBusMessage instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {metamoto.messages.IDataBusMessage=} [properties] Properties to set
             * @returns {metamoto.messages.DataBusMessage} DataBusMessage instance
             */
            DataBusMessage.create = function create(properties) {
                return new DataBusMessage(properties);
            };

            /**
             * Encodes the specified DataBusMessage message. Does not implicitly {@link metamoto.messages.DataBusMessage.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {metamoto.messages.IDataBusMessage} message DataBusMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBusMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && message.hasOwnProperty("header"))
                    $root.metamoto.messages.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.vehicleState != null && message.hasOwnProperty("vehicleState"))
                    $root.metamoto.messages.VehicleState.encode(message.vehicleState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.vehicleControls != null && message.hasOwnProperty("vehicleControls"))
                    $root.metamoto.messages.VehicleControls.encode(message.vehicleControls, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.camera != null && message.hasOwnProperty("camera"))
                    $root.metamoto.messages.Camera.encode(message.camera, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.lidar != null && message.hasOwnProperty("lidar"))
                    $root.metamoto.messages.Lidar.encode(message.lidar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.radar != null && message.hasOwnProperty("radar"))
                    $root.metamoto.messages.Radar.encode(message.radar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.gps != null && message.hasOwnProperty("gps"))
                    $root.metamoto.messages.GPS.encode(message.gps, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.imu != null && message.hasOwnProperty("imu"))
                    $root.metamoto.messages.IMU.encode(message.imu, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.localizer != null && message.hasOwnProperty("localizer"))
                    $root.metamoto.messages.Localizer.encode(message.localizer, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.v2x != null && message.hasOwnProperty("v2x"))
                    $root.metamoto.messages.V2X.encode(message.v2x, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.event != null && message.hasOwnProperty("event"))
                    $root.metamoto.messages.Event.encode(message.event, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.perception != null && message.hasOwnProperty("perception"))
                    $root.metamoto.messages.Perception.encode(message.perception, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.groundTruth != null && message.hasOwnProperty("groundTruth"))
                    $root.metamoto.messages.GroundTruth.encode(message.groundTruth, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.other != null && message.hasOwnProperty("other"))
                    $root.google.protobuf.Any.encode(message.other, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DataBusMessage message, length delimited. Does not implicitly {@link metamoto.messages.DataBusMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {metamoto.messages.IDataBusMessage} message DataBusMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBusMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DataBusMessage message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.DataBusMessage} DataBusMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBusMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.DataBusMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.metamoto.messages.Header.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.vehicleState = $root.metamoto.messages.VehicleState.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.vehicleControls = $root.metamoto.messages.VehicleControls.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.camera = $root.metamoto.messages.Camera.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.lidar = $root.metamoto.messages.Lidar.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.radar = $root.metamoto.messages.Radar.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.gps = $root.metamoto.messages.GPS.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.imu = $root.metamoto.messages.IMU.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.localizer = $root.metamoto.messages.Localizer.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.v2x = $root.metamoto.messages.V2X.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.event = $root.metamoto.messages.Event.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.perception = $root.metamoto.messages.Perception.decode(reader, reader.uint32());
                        break;
                    case 30:
                        message.groundTruth = $root.metamoto.messages.GroundTruth.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.other = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DataBusMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.DataBusMessage} DataBusMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBusMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DataBusMessage message.
             * @function verify
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataBusMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.metamoto.messages.Header.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.vehicleState != null && message.hasOwnProperty("vehicleState")) {
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.VehicleState.verify(message.vehicleState);
                        if (error)
                            return "vehicleState." + error;
                    }
                }
                if (message.vehicleControls != null && message.hasOwnProperty("vehicleControls")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.VehicleControls.verify(message.vehicleControls);
                        if (error)
                            return "vehicleControls." + error;
                    }
                }
                if (message.camera != null && message.hasOwnProperty("camera")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Camera.verify(message.camera);
                        if (error)
                            return "camera." + error;
                    }
                }
                if (message.lidar != null && message.hasOwnProperty("lidar")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Lidar.verify(message.lidar);
                        if (error)
                            return "lidar." + error;
                    }
                }
                if (message.radar != null && message.hasOwnProperty("radar")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Radar.verify(message.radar);
                        if (error)
                            return "radar." + error;
                    }
                }
                if (message.gps != null && message.hasOwnProperty("gps")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.GPS.verify(message.gps);
                        if (error)
                            return "gps." + error;
                    }
                }
                if (message.imu != null && message.hasOwnProperty("imu")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.IMU.verify(message.imu);
                        if (error)
                            return "imu." + error;
                    }
                }
                if (message.localizer != null && message.hasOwnProperty("localizer")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Localizer.verify(message.localizer);
                        if (error)
                            return "localizer." + error;
                    }
                }
                if (message.v2x != null && message.hasOwnProperty("v2x")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.V2X.verify(message.v2x);
                        if (error)
                            return "v2x." + error;
                    }
                }
                if (message.event != null && message.hasOwnProperty("event")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Event.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                }
                if (message.perception != null && message.hasOwnProperty("perception")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.Perception.verify(message.perception);
                        if (error)
                            return "perception." + error;
                    }
                }
                if (message.groundTruth != null && message.hasOwnProperty("groundTruth")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.metamoto.messages.GroundTruth.verify(message.groundTruth);
                        if (error)
                            return "groundTruth." + error;
                    }
                }
                if (message.other != null && message.hasOwnProperty("other")) {
                    if (properties.dataOneof === 1)
                        return "dataOneof: multiple values";
                    properties.dataOneof = 1;
                    {
                        var error = $root.google.protobuf.Any.verify(message.other);
                        if (error)
                            return "other." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DataBusMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.DataBusMessage} DataBusMessage
             */
            DataBusMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.DataBusMessage)
                    return object;
                var message = new $root.metamoto.messages.DataBusMessage();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.header: object expected");
                    message.header = $root.metamoto.messages.Header.fromObject(object.header);
                }
                if (object.vehicleState != null) {
                    if (typeof object.vehicleState !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.vehicleState: object expected");
                    message.vehicleState = $root.metamoto.messages.VehicleState.fromObject(object.vehicleState);
                }
                if (object.vehicleControls != null) {
                    if (typeof object.vehicleControls !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.vehicleControls: object expected");
                    message.vehicleControls = $root.metamoto.messages.VehicleControls.fromObject(object.vehicleControls);
                }
                if (object.camera != null) {
                    if (typeof object.camera !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.camera: object expected");
                    message.camera = $root.metamoto.messages.Camera.fromObject(object.camera);
                }
                if (object.lidar != null) {
                    if (typeof object.lidar !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.lidar: object expected");
                    message.lidar = $root.metamoto.messages.Lidar.fromObject(object.lidar);
                }
                if (object.radar != null) {
                    if (typeof object.radar !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.radar: object expected");
                    message.radar = $root.metamoto.messages.Radar.fromObject(object.radar);
                }
                if (object.gps != null) {
                    if (typeof object.gps !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.gps: object expected");
                    message.gps = $root.metamoto.messages.GPS.fromObject(object.gps);
                }
                if (object.imu != null) {
                    if (typeof object.imu !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.imu: object expected");
                    message.imu = $root.metamoto.messages.IMU.fromObject(object.imu);
                }
                if (object.localizer != null) {
                    if (typeof object.localizer !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.localizer: object expected");
                    message.localizer = $root.metamoto.messages.Localizer.fromObject(object.localizer);
                }
                if (object.v2x != null) {
                    if (typeof object.v2x !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.v2x: object expected");
                    message.v2x = $root.metamoto.messages.V2X.fromObject(object.v2x);
                }
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.event: object expected");
                    message.event = $root.metamoto.messages.Event.fromObject(object.event);
                }
                if (object.perception != null) {
                    if (typeof object.perception !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.perception: object expected");
                    message.perception = $root.metamoto.messages.Perception.fromObject(object.perception);
                }
                if (object.groundTruth != null) {
                    if (typeof object.groundTruth !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.groundTruth: object expected");
                    message.groundTruth = $root.metamoto.messages.GroundTruth.fromObject(object.groundTruth);
                }
                if (object.other != null) {
                    if (typeof object.other !== "object")
                        throw TypeError(".metamoto.messages.DataBusMessage.other: object expected");
                    message.other = $root.google.protobuf.Any.fromObject(object.other);
                }
                return message;
            };

            /**
             * Creates a plain object from a DataBusMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.DataBusMessage
             * @static
             * @param {metamoto.messages.DataBusMessage} message DataBusMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataBusMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.metamoto.messages.Header.toObject(message.header, options);
                if (message.vehicleState != null && message.hasOwnProperty("vehicleState")) {
                    object.vehicleState = $root.metamoto.messages.VehicleState.toObject(message.vehicleState, options);
                    if (options.oneofs)
                        object.dataOneof = "vehicleState";
                }
                if (message.vehicleControls != null && message.hasOwnProperty("vehicleControls")) {
                    object.vehicleControls = $root.metamoto.messages.VehicleControls.toObject(message.vehicleControls, options);
                    if (options.oneofs)
                        object.dataOneof = "vehicleControls";
                }
                if (message.camera != null && message.hasOwnProperty("camera")) {
                    object.camera = $root.metamoto.messages.Camera.toObject(message.camera, options);
                    if (options.oneofs)
                        object.dataOneof = "camera";
                }
                if (message.lidar != null && message.hasOwnProperty("lidar")) {
                    object.lidar = $root.metamoto.messages.Lidar.toObject(message.lidar, options);
                    if (options.oneofs)
                        object.dataOneof = "lidar";
                }
                if (message.radar != null && message.hasOwnProperty("radar")) {
                    object.radar = $root.metamoto.messages.Radar.toObject(message.radar, options);
                    if (options.oneofs)
                        object.dataOneof = "radar";
                }
                if (message.gps != null && message.hasOwnProperty("gps")) {
                    object.gps = $root.metamoto.messages.GPS.toObject(message.gps, options);
                    if (options.oneofs)
                        object.dataOneof = "gps";
                }
                if (message.imu != null && message.hasOwnProperty("imu")) {
                    object.imu = $root.metamoto.messages.IMU.toObject(message.imu, options);
                    if (options.oneofs)
                        object.dataOneof = "imu";
                }
                if (message.localizer != null && message.hasOwnProperty("localizer")) {
                    object.localizer = $root.metamoto.messages.Localizer.toObject(message.localizer, options);
                    if (options.oneofs)
                        object.dataOneof = "localizer";
                }
                if (message.v2x != null && message.hasOwnProperty("v2x")) {
                    object.v2x = $root.metamoto.messages.V2X.toObject(message.v2x, options);
                    if (options.oneofs)
                        object.dataOneof = "v2x";
                }
                if (message.event != null && message.hasOwnProperty("event")) {
                    object.event = $root.metamoto.messages.Event.toObject(message.event, options);
                    if (options.oneofs)
                        object.dataOneof = "event";
                }
                if (message.perception != null && message.hasOwnProperty("perception")) {
                    object.perception = $root.metamoto.messages.Perception.toObject(message.perception, options);
                    if (options.oneofs)
                        object.dataOneof = "perception";
                }
                if (message.groundTruth != null && message.hasOwnProperty("groundTruth")) {
                    object.groundTruth = $root.metamoto.messages.GroundTruth.toObject(message.groundTruth, options);
                    if (options.oneofs)
                        object.dataOneof = "groundTruth";
                }
                if (message.other != null && message.hasOwnProperty("other")) {
                    object.other = $root.google.protobuf.Any.toObject(message.other, options);
                    if (options.oneofs)
                        object.dataOneof = "other";
                }
                return object;
            };

            /**
             * Converts this DataBusMessage to JSON.
             * @function toJSON
             * @memberof metamoto.messages.DataBusMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataBusMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DataBusMessage;
        })();

        messages.Event = (function() {

            /**
             * Properties of an Event.
             * @memberof metamoto.messages
             * @interface IEvent
             * @property {metamoto.types.IEvent|null} [event] Event event
             * @property {metamoto.types.IInfraction|null} [infraction] Event infraction
             * @property {metamoto.types.Action|null} [reportedAction] Event reportedAction
             * @property {string|null} [primaryId] Event primaryId
             * @property {string|null} [secondaryId] Event secondaryId
             * @property {number|null} [value] Event value
             * @property {string|null} [description] Event description
             */

            /**
             * Constructs a new Event.
             * @memberof metamoto.messages
             * @classdesc Represents an Event.
             * @implements IEvent
             * @constructor
             * @param {metamoto.messages.IEvent=} [properties] Properties to set
             */
            function Event(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Event event.
             * @member {metamoto.types.IEvent|null|undefined} event
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.event = null;

            /**
             * Event infraction.
             * @member {metamoto.types.IInfraction|null|undefined} infraction
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.infraction = null;

            /**
             * Event reportedAction.
             * @member {metamoto.types.Action} reportedAction
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.reportedAction = 0;

            /**
             * Event primaryId.
             * @member {string} primaryId
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.primaryId = "";

            /**
             * Event secondaryId.
             * @member {string} secondaryId
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.secondaryId = "";

            /**
             * Event value.
             * @member {number} value
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.value = 0;

            /**
             * Event description.
             * @member {string} description
             * @memberof metamoto.messages.Event
             * @instance
             */
            Event.prototype.description = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Event typeOneof.
             * @member {"event"|"infraction"|"reportedAction"|undefined} typeOneof
             * @memberof metamoto.messages.Event
             * @instance
             */
            Object.defineProperty(Event.prototype, "typeOneof", {
                get: $util.oneOfGetter($oneOfFields = ["event", "infraction", "reportedAction"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Event instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Event
             * @static
             * @param {metamoto.messages.IEvent=} [properties] Properties to set
             * @returns {metamoto.messages.Event} Event instance
             */
            Event.create = function create(properties) {
                return new Event(properties);
            };

            /**
             * Encodes the specified Event message. Does not implicitly {@link metamoto.messages.Event.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Event
             * @static
             * @param {metamoto.messages.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event != null && message.hasOwnProperty("event"))
                    $root.metamoto.types.Event.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.infraction != null && message.hasOwnProperty("infraction"))
                    $root.metamoto.types.Infraction.encode(message.infraction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.reportedAction != null && message.hasOwnProperty("reportedAction"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reportedAction);
                if (message.primaryId != null && message.hasOwnProperty("primaryId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.primaryId);
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.secondaryId);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.value);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified Event message, length delimited. Does not implicitly {@link metamoto.messages.Event.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Event
             * @static
             * @param {metamoto.messages.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Event message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Event();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event = $root.metamoto.types.Event.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.infraction = $root.metamoto.types.Infraction.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.reportedAction = reader.int32();
                        break;
                    case 4:
                        message.primaryId = reader.string();
                        break;
                    case 5:
                        message.secondaryId = reader.string();
                        break;
                    case 6:
                        message.value = reader.float();
                        break;
                    case 7:
                        message.description = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Event message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Event message.
             * @function verify
             * @memberof metamoto.messages.Event
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.event != null && message.hasOwnProperty("event")) {
                    properties.typeOneof = 1;
                    {
                        var error = $root.metamoto.types.Event.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                }
                if (message.infraction != null && message.hasOwnProperty("infraction")) {
                    if (properties.typeOneof === 1)
                        return "typeOneof: multiple values";
                    properties.typeOneof = 1;
                    {
                        var error = $root.metamoto.types.Infraction.verify(message.infraction);
                        if (error)
                            return "infraction." + error;
                    }
                }
                if (message.reportedAction != null && message.hasOwnProperty("reportedAction")) {
                    if (properties.typeOneof === 1)
                        return "typeOneof: multiple values";
                    properties.typeOneof = 1;
                    switch (message.reportedAction) {
                    default:
                        return "reportedAction: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                }
                if (message.primaryId != null && message.hasOwnProperty("primaryId"))
                    if (!$util.isString(message.primaryId))
                        return "primaryId: string expected";
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    if (!$util.isString(message.secondaryId))
                        return "secondaryId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates an Event message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Event
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Event} Event
             */
            Event.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Event)
                    return object;
                var message = new $root.metamoto.messages.Event();
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".metamoto.messages.Event.event: object expected");
                    message.event = $root.metamoto.types.Event.fromObject(object.event);
                }
                if (object.infraction != null) {
                    if (typeof object.infraction !== "object")
                        throw TypeError(".metamoto.messages.Event.infraction: object expected");
                    message.infraction = $root.metamoto.types.Infraction.fromObject(object.infraction);
                }
                switch (object.reportedAction) {
                case "ACTION_UNKNOWN":
                case 0:
                    message.reportedAction = 0;
                    break;
                case "ACTION_PASS":
                case 1:
                    message.reportedAction = 1;
                    break;
                case "ACTION_WARN":
                case 2:
                    message.reportedAction = 2;
                    break;
                case "ACTION_FAIL":
                case 3:
                    message.reportedAction = 3;
                    break;
                case "ACTION_STOP":
                case 4:
                    message.reportedAction = 4;
                    break;
                }
                if (object.primaryId != null)
                    message.primaryId = String(object.primaryId);
                if (object.secondaryId != null)
                    message.secondaryId = String(object.secondaryId);
                if (object.value != null)
                    message.value = Number(object.value);
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from an Event message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Event
             * @static
             * @param {metamoto.messages.Event} message Event
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Event.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.primaryId = "";
                    object.secondaryId = "";
                    object.value = 0;
                    object.description = "";
                }
                if (message.event != null && message.hasOwnProperty("event")) {
                    object.event = $root.metamoto.types.Event.toObject(message.event, options);
                    if (options.oneofs)
                        object.typeOneof = "event";
                }
                if (message.infraction != null && message.hasOwnProperty("infraction")) {
                    object.infraction = $root.metamoto.types.Infraction.toObject(message.infraction, options);
                    if (options.oneofs)
                        object.typeOneof = "infraction";
                }
                if (message.reportedAction != null && message.hasOwnProperty("reportedAction")) {
                    object.reportedAction = options.enums === String ? $root.metamoto.types.Action[message.reportedAction] : message.reportedAction;
                    if (options.oneofs)
                        object.typeOneof = "reportedAction";
                }
                if (message.primaryId != null && message.hasOwnProperty("primaryId"))
                    object.primaryId = message.primaryId;
                if (message.secondaryId != null && message.hasOwnProperty("secondaryId"))
                    object.secondaryId = message.secondaryId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this Event to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Event
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Event;
        })();

        messages.GPS = (function() {

            /**
             * Properties of a GPS.
             * @memberof metamoto.messages
             * @interface IGPS
             * @property {metamoto.types.IGeoCoordinates|null} [coordinate] GPS coordinate
             */

            /**
             * Constructs a new GPS.
             * @memberof metamoto.messages
             * @classdesc Represents a GPS.
             * @implements IGPS
             * @constructor
             * @param {metamoto.messages.IGPS=} [properties] Properties to set
             */
            function GPS(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GPS coordinate.
             * @member {metamoto.types.IGeoCoordinates|null|undefined} coordinate
             * @memberof metamoto.messages.GPS
             * @instance
             */
            GPS.prototype.coordinate = null;

            /**
             * Creates a new GPS instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.GPS
             * @static
             * @param {metamoto.messages.IGPS=} [properties] Properties to set
             * @returns {metamoto.messages.GPS} GPS instance
             */
            GPS.create = function create(properties) {
                return new GPS(properties);
            };

            /**
             * Encodes the specified GPS message. Does not implicitly {@link metamoto.messages.GPS.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.GPS
             * @static
             * @param {metamoto.messages.IGPS} message GPS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GPS.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.coordinate != null && message.hasOwnProperty("coordinate"))
                    $root.metamoto.types.GeoCoordinates.encode(message.coordinate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GPS message, length delimited. Does not implicitly {@link metamoto.messages.GPS.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.GPS
             * @static
             * @param {metamoto.messages.IGPS} message GPS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GPS.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GPS message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.GPS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.GPS} GPS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GPS.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.GPS();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.coordinate = $root.metamoto.types.GeoCoordinates.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GPS message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.GPS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.GPS} GPS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GPS.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GPS message.
             * @function verify
             * @memberof metamoto.messages.GPS
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GPS.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.coordinate != null && message.hasOwnProperty("coordinate")) {
                    var error = $root.metamoto.types.GeoCoordinates.verify(message.coordinate);
                    if (error)
                        return "coordinate." + error;
                }
                return null;
            };

            /**
             * Creates a GPS message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.GPS
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.GPS} GPS
             */
            GPS.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.GPS)
                    return object;
                var message = new $root.metamoto.messages.GPS();
                if (object.coordinate != null) {
                    if (typeof object.coordinate !== "object")
                        throw TypeError(".metamoto.messages.GPS.coordinate: object expected");
                    message.coordinate = $root.metamoto.types.GeoCoordinates.fromObject(object.coordinate);
                }
                return message;
            };

            /**
             * Creates a plain object from a GPS message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.GPS
             * @static
             * @param {metamoto.messages.GPS} message GPS
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GPS.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.coordinate = null;
                if (message.coordinate != null && message.hasOwnProperty("coordinate"))
                    object.coordinate = $root.metamoto.types.GeoCoordinates.toObject(message.coordinate, options);
                return object;
            };

            /**
             * Converts this GPS to JSON.
             * @function toJSON
             * @memberof metamoto.messages.GPS
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GPS.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GPS;
        })();

        messages.GroundTruth = (function() {

            /**
             * Properties of a GroundTruth.
             * @memberof metamoto.messages
             * @interface IGroundTruth
             * @property {metamoto.types.IEnvironment|null} [environment] GroundTruth environment
             * @property {metamoto.types.IVehicle|null} [egoVehicle] GroundTruth egoVehicle
             * @property {Array.<metamoto.types.IVehicle>|null} [vehicles] GroundTruth vehicles
             * @property {Array.<metamoto.types.IPedestrian>|null} [pedestrians] GroundTruth pedestrians
             * @property {Array.<metamoto.types.ITrafficLight>|null} [trafficLights] GroundTruth trafficLights
             * @property {Array.<metamoto.types.ITrafficSign>|null} [trafficSigns] GroundTruth trafficSigns
             * @property {Array.<metamoto.types.IVehicle>|null} [egoVehicles] GroundTruth egoVehicles
             */

            /**
             * Constructs a new GroundTruth.
             * @memberof metamoto.messages
             * @classdesc Represents a GroundTruth.
             * @implements IGroundTruth
             * @constructor
             * @param {metamoto.messages.IGroundTruth=} [properties] Properties to set
             */
            function GroundTruth(properties) {
                this.vehicles = [];
                this.pedestrians = [];
                this.trafficLights = [];
                this.trafficSigns = [];
                this.egoVehicles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroundTruth environment.
             * @member {metamoto.types.IEnvironment|null|undefined} environment
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.environment = null;

            /**
             * GroundTruth egoVehicle.
             * @member {metamoto.types.IVehicle|null|undefined} egoVehicle
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.egoVehicle = null;

            /**
             * GroundTruth vehicles.
             * @member {Array.<metamoto.types.IVehicle>} vehicles
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.vehicles = $util.emptyArray;

            /**
             * GroundTruth pedestrians.
             * @member {Array.<metamoto.types.IPedestrian>} pedestrians
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.pedestrians = $util.emptyArray;

            /**
             * GroundTruth trafficLights.
             * @member {Array.<metamoto.types.ITrafficLight>} trafficLights
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.trafficLights = $util.emptyArray;

            /**
             * GroundTruth trafficSigns.
             * @member {Array.<metamoto.types.ITrafficSign>} trafficSigns
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.trafficSigns = $util.emptyArray;

            /**
             * GroundTruth egoVehicles.
             * @member {Array.<metamoto.types.IVehicle>} egoVehicles
             * @memberof metamoto.messages.GroundTruth
             * @instance
             */
            GroundTruth.prototype.egoVehicles = $util.emptyArray;

            /**
             * Creates a new GroundTruth instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {metamoto.messages.IGroundTruth=} [properties] Properties to set
             * @returns {metamoto.messages.GroundTruth} GroundTruth instance
             */
            GroundTruth.create = function create(properties) {
                return new GroundTruth(properties);
            };

            /**
             * Encodes the specified GroundTruth message. Does not implicitly {@link metamoto.messages.GroundTruth.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {metamoto.messages.IGroundTruth} message GroundTruth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroundTruth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.environment != null && message.hasOwnProperty("environment"))
                    $root.metamoto.types.Environment.encode(message.environment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    $root.metamoto.types.Vehicle.encode(message.egoVehicle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.vehicles != null && message.vehicles.length)
                    for (var i = 0; i < message.vehicles.length; ++i)
                        $root.metamoto.types.Vehicle.encode(message.vehicles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.pedestrians != null && message.pedestrians.length)
                    for (var i = 0; i < message.pedestrians.length; ++i)
                        $root.metamoto.types.Pedestrian.encode(message.pedestrians[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.trafficLights != null && message.trafficLights.length)
                    for (var i = 0; i < message.trafficLights.length; ++i)
                        $root.metamoto.types.TrafficLight.encode(message.trafficLights[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.trafficSigns != null && message.trafficSigns.length)
                    for (var i = 0; i < message.trafficSigns.length; ++i)
                        $root.metamoto.types.TrafficSign.encode(message.trafficSigns[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.egoVehicles != null && message.egoVehicles.length)
                    for (var i = 0; i < message.egoVehicles.length; ++i)
                        $root.metamoto.types.Vehicle.encode(message.egoVehicles[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroundTruth message, length delimited. Does not implicitly {@link metamoto.messages.GroundTruth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {metamoto.messages.IGroundTruth} message GroundTruth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroundTruth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroundTruth message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.GroundTruth} GroundTruth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroundTruth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.GroundTruth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.environment = $root.metamoto.types.Environment.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.egoVehicle = $root.metamoto.types.Vehicle.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.vehicles && message.vehicles.length))
                            message.vehicles = [];
                        message.vehicles.push($root.metamoto.types.Vehicle.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.pedestrians && message.pedestrians.length))
                            message.pedestrians = [];
                        message.pedestrians.push($root.metamoto.types.Pedestrian.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.trafficLights && message.trafficLights.length))
                            message.trafficLights = [];
                        message.trafficLights.push($root.metamoto.types.TrafficLight.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.trafficSigns && message.trafficSigns.length))
                            message.trafficSigns = [];
                        message.trafficSigns.push($root.metamoto.types.TrafficSign.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.egoVehicles && message.egoVehicles.length))
                            message.egoVehicles = [];
                        message.egoVehicles.push($root.metamoto.types.Vehicle.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroundTruth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.GroundTruth} GroundTruth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroundTruth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroundTruth message.
             * @function verify
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroundTruth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.environment != null && message.hasOwnProperty("environment")) {
                    var error = $root.metamoto.types.Environment.verify(message.environment);
                    if (error)
                        return "environment." + error;
                }
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle")) {
                    var error = $root.metamoto.types.Vehicle.verify(message.egoVehicle);
                    if (error)
                        return "egoVehicle." + error;
                }
                if (message.vehicles != null && message.hasOwnProperty("vehicles")) {
                    if (!Array.isArray(message.vehicles))
                        return "vehicles: array expected";
                    for (var i = 0; i < message.vehicles.length; ++i) {
                        var error = $root.metamoto.types.Vehicle.verify(message.vehicles[i]);
                        if (error)
                            return "vehicles." + error;
                    }
                }
                if (message.pedestrians != null && message.hasOwnProperty("pedestrians")) {
                    if (!Array.isArray(message.pedestrians))
                        return "pedestrians: array expected";
                    for (var i = 0; i < message.pedestrians.length; ++i) {
                        var error = $root.metamoto.types.Pedestrian.verify(message.pedestrians[i]);
                        if (error)
                            return "pedestrians." + error;
                    }
                }
                if (message.trafficLights != null && message.hasOwnProperty("trafficLights")) {
                    if (!Array.isArray(message.trafficLights))
                        return "trafficLights: array expected";
                    for (var i = 0; i < message.trafficLights.length; ++i) {
                        var error = $root.metamoto.types.TrafficLight.verify(message.trafficLights[i]);
                        if (error)
                            return "trafficLights." + error;
                    }
                }
                if (message.trafficSigns != null && message.hasOwnProperty("trafficSigns")) {
                    if (!Array.isArray(message.trafficSigns))
                        return "trafficSigns: array expected";
                    for (var i = 0; i < message.trafficSigns.length; ++i) {
                        var error = $root.metamoto.types.TrafficSign.verify(message.trafficSigns[i]);
                        if (error)
                            return "trafficSigns." + error;
                    }
                }
                if (message.egoVehicles != null && message.hasOwnProperty("egoVehicles")) {
                    if (!Array.isArray(message.egoVehicles))
                        return "egoVehicles: array expected";
                    for (var i = 0; i < message.egoVehicles.length; ++i) {
                        var error = $root.metamoto.types.Vehicle.verify(message.egoVehicles[i]);
                        if (error)
                            return "egoVehicles." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroundTruth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.GroundTruth} GroundTruth
             */
            GroundTruth.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.GroundTruth)
                    return object;
                var message = new $root.metamoto.messages.GroundTruth();
                if (object.environment != null) {
                    if (typeof object.environment !== "object")
                        throw TypeError(".metamoto.messages.GroundTruth.environment: object expected");
                    message.environment = $root.metamoto.types.Environment.fromObject(object.environment);
                }
                if (object.egoVehicle != null) {
                    if (typeof object.egoVehicle !== "object")
                        throw TypeError(".metamoto.messages.GroundTruth.egoVehicle: object expected");
                    message.egoVehicle = $root.metamoto.types.Vehicle.fromObject(object.egoVehicle);
                }
                if (object.vehicles) {
                    if (!Array.isArray(object.vehicles))
                        throw TypeError(".metamoto.messages.GroundTruth.vehicles: array expected");
                    message.vehicles = [];
                    for (var i = 0; i < object.vehicles.length; ++i) {
                        if (typeof object.vehicles[i] !== "object")
                            throw TypeError(".metamoto.messages.GroundTruth.vehicles: object expected");
                        message.vehicles[i] = $root.metamoto.types.Vehicle.fromObject(object.vehicles[i]);
                    }
                }
                if (object.pedestrians) {
                    if (!Array.isArray(object.pedestrians))
                        throw TypeError(".metamoto.messages.GroundTruth.pedestrians: array expected");
                    message.pedestrians = [];
                    for (var i = 0; i < object.pedestrians.length; ++i) {
                        if (typeof object.pedestrians[i] !== "object")
                            throw TypeError(".metamoto.messages.GroundTruth.pedestrians: object expected");
                        message.pedestrians[i] = $root.metamoto.types.Pedestrian.fromObject(object.pedestrians[i]);
                    }
                }
                if (object.trafficLights) {
                    if (!Array.isArray(object.trafficLights))
                        throw TypeError(".metamoto.messages.GroundTruth.trafficLights: array expected");
                    message.trafficLights = [];
                    for (var i = 0; i < object.trafficLights.length; ++i) {
                        if (typeof object.trafficLights[i] !== "object")
                            throw TypeError(".metamoto.messages.GroundTruth.trafficLights: object expected");
                        message.trafficLights[i] = $root.metamoto.types.TrafficLight.fromObject(object.trafficLights[i]);
                    }
                }
                if (object.trafficSigns) {
                    if (!Array.isArray(object.trafficSigns))
                        throw TypeError(".metamoto.messages.GroundTruth.trafficSigns: array expected");
                    message.trafficSigns = [];
                    for (var i = 0; i < object.trafficSigns.length; ++i) {
                        if (typeof object.trafficSigns[i] !== "object")
                            throw TypeError(".metamoto.messages.GroundTruth.trafficSigns: object expected");
                        message.trafficSigns[i] = $root.metamoto.types.TrafficSign.fromObject(object.trafficSigns[i]);
                    }
                }
                if (object.egoVehicles) {
                    if (!Array.isArray(object.egoVehicles))
                        throw TypeError(".metamoto.messages.GroundTruth.egoVehicles: array expected");
                    message.egoVehicles = [];
                    for (var i = 0; i < object.egoVehicles.length; ++i) {
                        if (typeof object.egoVehicles[i] !== "object")
                            throw TypeError(".metamoto.messages.GroundTruth.egoVehicles: object expected");
                        message.egoVehicles[i] = $root.metamoto.types.Vehicle.fromObject(object.egoVehicles[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroundTruth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.GroundTruth
             * @static
             * @param {metamoto.messages.GroundTruth} message GroundTruth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroundTruth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.vehicles = [];
                    object.pedestrians = [];
                    object.trafficLights = [];
                    object.trafficSigns = [];
                    object.egoVehicles = [];
                }
                if (options.defaults) {
                    object.environment = null;
                    object.egoVehicle = null;
                }
                if (message.environment != null && message.hasOwnProperty("environment"))
                    object.environment = $root.metamoto.types.Environment.toObject(message.environment, options);
                if (message.egoVehicle != null && message.hasOwnProperty("egoVehicle"))
                    object.egoVehicle = $root.metamoto.types.Vehicle.toObject(message.egoVehicle, options);
                if (message.vehicles && message.vehicles.length) {
                    object.vehicles = [];
                    for (var j = 0; j < message.vehicles.length; ++j)
                        object.vehicles[j] = $root.metamoto.types.Vehicle.toObject(message.vehicles[j], options);
                }
                if (message.pedestrians && message.pedestrians.length) {
                    object.pedestrians = [];
                    for (var j = 0; j < message.pedestrians.length; ++j)
                        object.pedestrians[j] = $root.metamoto.types.Pedestrian.toObject(message.pedestrians[j], options);
                }
                if (message.trafficLights && message.trafficLights.length) {
                    object.trafficLights = [];
                    for (var j = 0; j < message.trafficLights.length; ++j)
                        object.trafficLights[j] = $root.metamoto.types.TrafficLight.toObject(message.trafficLights[j], options);
                }
                if (message.trafficSigns && message.trafficSigns.length) {
                    object.trafficSigns = [];
                    for (var j = 0; j < message.trafficSigns.length; ++j)
                        object.trafficSigns[j] = $root.metamoto.types.TrafficSign.toObject(message.trafficSigns[j], options);
                }
                if (message.egoVehicles && message.egoVehicles.length) {
                    object.egoVehicles = [];
                    for (var j = 0; j < message.egoVehicles.length; ++j)
                        object.egoVehicles[j] = $root.metamoto.types.Vehicle.toObject(message.egoVehicles[j], options);
                }
                return object;
            };

            /**
             * Converts this GroundTruth to JSON.
             * @function toJSON
             * @memberof metamoto.messages.GroundTruth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroundTruth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroundTruth;
        })();

        messages.IMU = (function() {

            /**
             * Properties of a IMU.
             * @memberof metamoto.messages
             * @interface IIMU
             * @property {metamoto.types.IVector3|null} [angularVelocity] IMU angularVelocity
             * @property {metamoto.types.IVector3|null} [linearAcceleration] IMU linearAcceleration
             */

            /**
             * Constructs a new IMU.
             * @memberof metamoto.messages
             * @classdesc Represents a IMU.
             * @implements IIMU
             * @constructor
             * @param {metamoto.messages.IIMU=} [properties] Properties to set
             */
            function IMU(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IMU angularVelocity.
             * @member {metamoto.types.IVector3|null|undefined} angularVelocity
             * @memberof metamoto.messages.IMU
             * @instance
             */
            IMU.prototype.angularVelocity = null;

            /**
             * IMU linearAcceleration.
             * @member {metamoto.types.IVector3|null|undefined} linearAcceleration
             * @memberof metamoto.messages.IMU
             * @instance
             */
            IMU.prototype.linearAcceleration = null;

            /**
             * Creates a new IMU instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.IMU
             * @static
             * @param {metamoto.messages.IIMU=} [properties] Properties to set
             * @returns {metamoto.messages.IMU} IMU instance
             */
            IMU.create = function create(properties) {
                return new IMU(properties);
            };

            /**
             * Encodes the specified IMU message. Does not implicitly {@link metamoto.messages.IMU.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.IMU
             * @static
             * @param {metamoto.messages.IIMU} message IMU message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IMU.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                    $root.metamoto.types.Vector3.encode(message.angularVelocity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                    $root.metamoto.types.Vector3.encode(message.linearAcceleration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IMU message, length delimited. Does not implicitly {@link metamoto.messages.IMU.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.IMU
             * @static
             * @param {metamoto.messages.IIMU} message IMU message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IMU.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a IMU message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.IMU
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.IMU} IMU
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IMU.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.IMU();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.angularVelocity = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.linearAcceleration = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a IMU message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.IMU
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.IMU} IMU
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IMU.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a IMU message.
             * @function verify
             * @memberof metamoto.messages.IMU
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IMU.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity")) {
                    var error = $root.metamoto.types.Vector3.verify(message.angularVelocity);
                    if (error)
                        return "angularVelocity." + error;
                }
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linearAcceleration);
                    if (error)
                        return "linearAcceleration." + error;
                }
                return null;
            };

            /**
             * Creates a IMU message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.IMU
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.IMU} IMU
             */
            IMU.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.IMU)
                    return object;
                var message = new $root.metamoto.messages.IMU();
                if (object.angularVelocity != null) {
                    if (typeof object.angularVelocity !== "object")
                        throw TypeError(".metamoto.messages.IMU.angularVelocity: object expected");
                    message.angularVelocity = $root.metamoto.types.Vector3.fromObject(object.angularVelocity);
                }
                if (object.linearAcceleration != null) {
                    if (typeof object.linearAcceleration !== "object")
                        throw TypeError(".metamoto.messages.IMU.linearAcceleration: object expected");
                    message.linearAcceleration = $root.metamoto.types.Vector3.fromObject(object.linearAcceleration);
                }
                return message;
            };

            /**
             * Creates a plain object from a IMU message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.IMU
             * @static
             * @param {metamoto.messages.IMU} message IMU
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IMU.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.angularVelocity = null;
                    object.linearAcceleration = null;
                }
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                    object.angularVelocity = $root.metamoto.types.Vector3.toObject(message.angularVelocity, options);
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                    object.linearAcceleration = $root.metamoto.types.Vector3.toObject(message.linearAcceleration, options);
                return object;
            };

            /**
             * Converts this IMU to JSON.
             * @function toJSON
             * @memberof metamoto.messages.IMU
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IMU.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IMU;
        })();

        messages.Lidar = (function() {

            /**
             * Properties of a Lidar.
             * @memberof metamoto.messages
             * @interface ILidar
             * @property {number|null} [timeIncrement] Lidar timeIncrement
             * @property {Array.<metamoto.types.ILaserReturnGroup>|null} [groups] Lidar groups
             */

            /**
             * Constructs a new Lidar.
             * @memberof metamoto.messages
             * @classdesc Represents a Lidar.
             * @implements ILidar
             * @constructor
             * @param {metamoto.messages.ILidar=} [properties] Properties to set
             */
            function Lidar(properties) {
                this.groups = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Lidar timeIncrement.
             * @member {number} timeIncrement
             * @memberof metamoto.messages.Lidar
             * @instance
             */
            Lidar.prototype.timeIncrement = 0;

            /**
             * Lidar groups.
             * @member {Array.<metamoto.types.ILaserReturnGroup>} groups
             * @memberof metamoto.messages.Lidar
             * @instance
             */
            Lidar.prototype.groups = $util.emptyArray;

            /**
             * Creates a new Lidar instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {metamoto.messages.ILidar=} [properties] Properties to set
             * @returns {metamoto.messages.Lidar} Lidar instance
             */
            Lidar.create = function create(properties) {
                return new Lidar(properties);
            };

            /**
             * Encodes the specified Lidar message. Does not implicitly {@link metamoto.messages.Lidar.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {metamoto.messages.ILidar} message Lidar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lidar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timeIncrement != null && message.hasOwnProperty("timeIncrement"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.timeIncrement);
                if (message.groups != null && message.groups.length)
                    for (var i = 0; i < message.groups.length; ++i)
                        $root.metamoto.types.LaserReturnGroup.encode(message.groups[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Lidar message, length delimited. Does not implicitly {@link metamoto.messages.Lidar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {metamoto.messages.ILidar} message Lidar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lidar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Lidar message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Lidar} Lidar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lidar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Lidar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timeIncrement = reader.double();
                        break;
                    case 2:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push($root.metamoto.types.LaserReturnGroup.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Lidar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Lidar} Lidar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lidar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Lidar message.
             * @function verify
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Lidar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timeIncrement != null && message.hasOwnProperty("timeIncrement"))
                    if (typeof message.timeIncrement !== "number")
                        return "timeIncrement: number expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (var i = 0; i < message.groups.length; ++i) {
                        var error = $root.metamoto.types.LaserReturnGroup.verify(message.groups[i]);
                        if (error)
                            return "groups." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Lidar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Lidar} Lidar
             */
            Lidar.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Lidar)
                    return object;
                var message = new $root.metamoto.messages.Lidar();
                if (object.timeIncrement != null)
                    message.timeIncrement = Number(object.timeIncrement);
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".metamoto.messages.Lidar.groups: array expected");
                    message.groups = [];
                    for (var i = 0; i < object.groups.length; ++i) {
                        if (typeof object.groups[i] !== "object")
                            throw TypeError(".metamoto.messages.Lidar.groups: object expected");
                        message.groups[i] = $root.metamoto.types.LaserReturnGroup.fromObject(object.groups[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Lidar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Lidar
             * @static
             * @param {metamoto.messages.Lidar} message Lidar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Lidar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (options.defaults)
                    object.timeIncrement = 0;
                if (message.timeIncrement != null && message.hasOwnProperty("timeIncrement"))
                    object.timeIncrement = options.json && !isFinite(message.timeIncrement) ? String(message.timeIncrement) : message.timeIncrement;
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (var j = 0; j < message.groups.length; ++j)
                        object.groups[j] = $root.metamoto.types.LaserReturnGroup.toObject(message.groups[j], options);
                }
                return object;
            };

            /**
             * Converts this Lidar to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Lidar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Lidar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Lidar;
        })();

        messages.Localizer = (function() {

            /**
             * Properties of a Localizer.
             * @memberof metamoto.messages
             * @interface ILocalizer
             * @property {metamoto.types.IVector3|null} [position] Localizer position
             * @property {metamoto.types.IQuaternion|null} [orientation] Localizer orientation
             * @property {metamoto.types.IVector3|null} [linearVelocity] Localizer linearVelocity
             * @property {metamoto.types.IVector3|null} [linearAcceleration] Localizer linearAcceleration
             * @property {metamoto.types.IVector3|null} [angularVelocity] Localizer angularVelocity
             * @property {metamoto.messages.IUncertainty|null} [uncertainty] Localizer uncertainty
             */

            /**
             * Constructs a new Localizer.
             * @memberof metamoto.messages
             * @classdesc Represents a Localizer.
             * @implements ILocalizer
             * @constructor
             * @param {metamoto.messages.ILocalizer=} [properties] Properties to set
             */
            function Localizer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Localizer position.
             * @member {metamoto.types.IVector3|null|undefined} position
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.position = null;

            /**
             * Localizer orientation.
             * @member {metamoto.types.IQuaternion|null|undefined} orientation
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.orientation = null;

            /**
             * Localizer linearVelocity.
             * @member {metamoto.types.IVector3|null|undefined} linearVelocity
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.linearVelocity = null;

            /**
             * Localizer linearAcceleration.
             * @member {metamoto.types.IVector3|null|undefined} linearAcceleration
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.linearAcceleration = null;

            /**
             * Localizer angularVelocity.
             * @member {metamoto.types.IVector3|null|undefined} angularVelocity
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.angularVelocity = null;

            /**
             * Localizer uncertainty.
             * @member {metamoto.messages.IUncertainty|null|undefined} uncertainty
             * @memberof metamoto.messages.Localizer
             * @instance
             */
            Localizer.prototype.uncertainty = null;

            /**
             * Creates a new Localizer instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {metamoto.messages.ILocalizer=} [properties] Properties to set
             * @returns {metamoto.messages.Localizer} Localizer instance
             */
            Localizer.create = function create(properties) {
                return new Localizer(properties);
            };

            /**
             * Encodes the specified Localizer message. Does not implicitly {@link metamoto.messages.Localizer.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {metamoto.messages.ILocalizer} message Localizer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Localizer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.metamoto.types.Vector3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    $root.metamoto.types.Quaternion.encode(message.orientation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity"))
                    $root.metamoto.types.Vector3.encode(message.linearVelocity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                    $root.metamoto.types.Vector3.encode(message.linearAcceleration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                    $root.metamoto.types.Vector3.encode(message.angularVelocity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.uncertainty != null && message.hasOwnProperty("uncertainty"))
                    $root.metamoto.messages.Uncertainty.encode(message.uncertainty, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Localizer message, length delimited. Does not implicitly {@link metamoto.messages.Localizer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {metamoto.messages.ILocalizer} message Localizer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Localizer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Localizer message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Localizer} Localizer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Localizer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Localizer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.orientation = $root.metamoto.types.Quaternion.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.linearVelocity = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.linearAcceleration = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.angularVelocity = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.uncertainty = $root.metamoto.messages.Uncertainty.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Localizer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Localizer} Localizer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Localizer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Localizer message.
             * @function verify
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Localizer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.metamoto.types.Vector3.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.orientation != null && message.hasOwnProperty("orientation")) {
                    var error = $root.metamoto.types.Quaternion.verify(message.orientation);
                    if (error)
                        return "orientation." + error;
                }
                if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linearVelocity);
                    if (error)
                        return "linearVelocity." + error;
                }
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linearAcceleration);
                    if (error)
                        return "linearAcceleration." + error;
                }
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity")) {
                    var error = $root.metamoto.types.Vector3.verify(message.angularVelocity);
                    if (error)
                        return "angularVelocity." + error;
                }
                if (message.uncertainty != null && message.hasOwnProperty("uncertainty")) {
                    var error = $root.metamoto.messages.Uncertainty.verify(message.uncertainty);
                    if (error)
                        return "uncertainty." + error;
                }
                return null;
            };

            /**
             * Creates a Localizer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Localizer} Localizer
             */
            Localizer.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Localizer)
                    return object;
                var message = new $root.metamoto.messages.Localizer();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".metamoto.messages.Localizer.position: object expected");
                    message.position = $root.metamoto.types.Vector3.fromObject(object.position);
                }
                if (object.orientation != null) {
                    if (typeof object.orientation !== "object")
                        throw TypeError(".metamoto.messages.Localizer.orientation: object expected");
                    message.orientation = $root.metamoto.types.Quaternion.fromObject(object.orientation);
                }
                if (object.linearVelocity != null) {
                    if (typeof object.linearVelocity !== "object")
                        throw TypeError(".metamoto.messages.Localizer.linearVelocity: object expected");
                    message.linearVelocity = $root.metamoto.types.Vector3.fromObject(object.linearVelocity);
                }
                if (object.linearAcceleration != null) {
                    if (typeof object.linearAcceleration !== "object")
                        throw TypeError(".metamoto.messages.Localizer.linearAcceleration: object expected");
                    message.linearAcceleration = $root.metamoto.types.Vector3.fromObject(object.linearAcceleration);
                }
                if (object.angularVelocity != null) {
                    if (typeof object.angularVelocity !== "object")
                        throw TypeError(".metamoto.messages.Localizer.angularVelocity: object expected");
                    message.angularVelocity = $root.metamoto.types.Vector3.fromObject(object.angularVelocity);
                }
                if (object.uncertainty != null) {
                    if (typeof object.uncertainty !== "object")
                        throw TypeError(".metamoto.messages.Localizer.uncertainty: object expected");
                    message.uncertainty = $root.metamoto.messages.Uncertainty.fromObject(object.uncertainty);
                }
                return message;
            };

            /**
             * Creates a plain object from a Localizer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Localizer
             * @static
             * @param {metamoto.messages.Localizer} message Localizer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Localizer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.orientation = null;
                    object.linearVelocity = null;
                    object.linearAcceleration = null;
                    object.angularVelocity = null;
                    object.uncertainty = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.metamoto.types.Vector3.toObject(message.position, options);
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    object.orientation = $root.metamoto.types.Quaternion.toObject(message.orientation, options);
                if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity"))
                    object.linearVelocity = $root.metamoto.types.Vector3.toObject(message.linearVelocity, options);
                if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                    object.linearAcceleration = $root.metamoto.types.Vector3.toObject(message.linearAcceleration, options);
                if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                    object.angularVelocity = $root.metamoto.types.Vector3.toObject(message.angularVelocity, options);
                if (message.uncertainty != null && message.hasOwnProperty("uncertainty"))
                    object.uncertainty = $root.metamoto.messages.Uncertainty.toObject(message.uncertainty, options);
                return object;
            };

            /**
             * Converts this Localizer to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Localizer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Localizer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Localizer;
        })();

        messages.Uncertainty = (function() {

            /**
             * Properties of an Uncertainty.
             * @memberof metamoto.messages
             * @interface IUncertainty
             * @property {metamoto.types.IVector3|null} [positionStdDev] Uncertainty positionStdDev
             * @property {metamoto.types.IVector3|null} [orientationAxisStdDev] Uncertainty orientationAxisStdDev
             * @property {number|null} [orientationAngleStdDev] Uncertainty orientationAngleStdDev
             * @property {metamoto.types.IVector3|null} [linearVelocityStdDev] Uncertainty linearVelocityStdDev
             * @property {metamoto.types.IVector3|null} [linearAccelerationStdDev] Uncertainty linearAccelerationStdDev
             * @property {metamoto.types.IVector3|null} [angularVelocityStdDev] Uncertainty angularVelocityStdDev
             */

            /**
             * Constructs a new Uncertainty.
             * @memberof metamoto.messages
             * @classdesc Represents an Uncertainty.
             * @implements IUncertainty
             * @constructor
             * @param {metamoto.messages.IUncertainty=} [properties] Properties to set
             */
            function Uncertainty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Uncertainty positionStdDev.
             * @member {metamoto.types.IVector3|null|undefined} positionStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.positionStdDev = null;

            /**
             * Uncertainty orientationAxisStdDev.
             * @member {metamoto.types.IVector3|null|undefined} orientationAxisStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.orientationAxisStdDev = null;

            /**
             * Uncertainty orientationAngleStdDev.
             * @member {number} orientationAngleStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.orientationAngleStdDev = 0;

            /**
             * Uncertainty linearVelocityStdDev.
             * @member {metamoto.types.IVector3|null|undefined} linearVelocityStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.linearVelocityStdDev = null;

            /**
             * Uncertainty linearAccelerationStdDev.
             * @member {metamoto.types.IVector3|null|undefined} linearAccelerationStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.linearAccelerationStdDev = null;

            /**
             * Uncertainty angularVelocityStdDev.
             * @member {metamoto.types.IVector3|null|undefined} angularVelocityStdDev
             * @memberof metamoto.messages.Uncertainty
             * @instance
             */
            Uncertainty.prototype.angularVelocityStdDev = null;

            /**
             * Creates a new Uncertainty instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {metamoto.messages.IUncertainty=} [properties] Properties to set
             * @returns {metamoto.messages.Uncertainty} Uncertainty instance
             */
            Uncertainty.create = function create(properties) {
                return new Uncertainty(properties);
            };

            /**
             * Encodes the specified Uncertainty message. Does not implicitly {@link metamoto.messages.Uncertainty.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {metamoto.messages.IUncertainty} message Uncertainty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uncertainty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.positionStdDev != null && message.hasOwnProperty("positionStdDev"))
                    $root.metamoto.types.Vector3.encode(message.positionStdDev, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orientationAxisStdDev != null && message.hasOwnProperty("orientationAxisStdDev"))
                    $root.metamoto.types.Vector3.encode(message.orientationAxisStdDev, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.orientationAngleStdDev != null && message.hasOwnProperty("orientationAngleStdDev"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.orientationAngleStdDev);
                if (message.linearVelocityStdDev != null && message.hasOwnProperty("linearVelocityStdDev"))
                    $root.metamoto.types.Vector3.encode(message.linearVelocityStdDev, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.linearAccelerationStdDev != null && message.hasOwnProperty("linearAccelerationStdDev"))
                    $root.metamoto.types.Vector3.encode(message.linearAccelerationStdDev, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.angularVelocityStdDev != null && message.hasOwnProperty("angularVelocityStdDev"))
                    $root.metamoto.types.Vector3.encode(message.angularVelocityStdDev, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Uncertainty message, length delimited. Does not implicitly {@link metamoto.messages.Uncertainty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {metamoto.messages.IUncertainty} message Uncertainty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uncertainty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Uncertainty message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Uncertainty} Uncertainty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uncertainty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Uncertainty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.positionStdDev = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.orientationAxisStdDev = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.orientationAngleStdDev = reader.float();
                        break;
                    case 4:
                        message.linearVelocityStdDev = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.linearAccelerationStdDev = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.angularVelocityStdDev = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Uncertainty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Uncertainty} Uncertainty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uncertainty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Uncertainty message.
             * @function verify
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Uncertainty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.positionStdDev != null && message.hasOwnProperty("positionStdDev")) {
                    var error = $root.metamoto.types.Vector3.verify(message.positionStdDev);
                    if (error)
                        return "positionStdDev." + error;
                }
                if (message.orientationAxisStdDev != null && message.hasOwnProperty("orientationAxisStdDev")) {
                    var error = $root.metamoto.types.Vector3.verify(message.orientationAxisStdDev);
                    if (error)
                        return "orientationAxisStdDev." + error;
                }
                if (message.orientationAngleStdDev != null && message.hasOwnProperty("orientationAngleStdDev"))
                    if (typeof message.orientationAngleStdDev !== "number")
                        return "orientationAngleStdDev: number expected";
                if (message.linearVelocityStdDev != null && message.hasOwnProperty("linearVelocityStdDev")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linearVelocityStdDev);
                    if (error)
                        return "linearVelocityStdDev." + error;
                }
                if (message.linearAccelerationStdDev != null && message.hasOwnProperty("linearAccelerationStdDev")) {
                    var error = $root.metamoto.types.Vector3.verify(message.linearAccelerationStdDev);
                    if (error)
                        return "linearAccelerationStdDev." + error;
                }
                if (message.angularVelocityStdDev != null && message.hasOwnProperty("angularVelocityStdDev")) {
                    var error = $root.metamoto.types.Vector3.verify(message.angularVelocityStdDev);
                    if (error)
                        return "angularVelocityStdDev." + error;
                }
                return null;
            };

            /**
             * Creates an Uncertainty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Uncertainty} Uncertainty
             */
            Uncertainty.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Uncertainty)
                    return object;
                var message = new $root.metamoto.messages.Uncertainty();
                if (object.positionStdDev != null) {
                    if (typeof object.positionStdDev !== "object")
                        throw TypeError(".metamoto.messages.Uncertainty.positionStdDev: object expected");
                    message.positionStdDev = $root.metamoto.types.Vector3.fromObject(object.positionStdDev);
                }
                if (object.orientationAxisStdDev != null) {
                    if (typeof object.orientationAxisStdDev !== "object")
                        throw TypeError(".metamoto.messages.Uncertainty.orientationAxisStdDev: object expected");
                    message.orientationAxisStdDev = $root.metamoto.types.Vector3.fromObject(object.orientationAxisStdDev);
                }
                if (object.orientationAngleStdDev != null)
                    message.orientationAngleStdDev = Number(object.orientationAngleStdDev);
                if (object.linearVelocityStdDev != null) {
                    if (typeof object.linearVelocityStdDev !== "object")
                        throw TypeError(".metamoto.messages.Uncertainty.linearVelocityStdDev: object expected");
                    message.linearVelocityStdDev = $root.metamoto.types.Vector3.fromObject(object.linearVelocityStdDev);
                }
                if (object.linearAccelerationStdDev != null) {
                    if (typeof object.linearAccelerationStdDev !== "object")
                        throw TypeError(".metamoto.messages.Uncertainty.linearAccelerationStdDev: object expected");
                    message.linearAccelerationStdDev = $root.metamoto.types.Vector3.fromObject(object.linearAccelerationStdDev);
                }
                if (object.angularVelocityStdDev != null) {
                    if (typeof object.angularVelocityStdDev !== "object")
                        throw TypeError(".metamoto.messages.Uncertainty.angularVelocityStdDev: object expected");
                    message.angularVelocityStdDev = $root.metamoto.types.Vector3.fromObject(object.angularVelocityStdDev);
                }
                return message;
            };

            /**
             * Creates a plain object from an Uncertainty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Uncertainty
             * @static
             * @param {metamoto.messages.Uncertainty} message Uncertainty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Uncertainty.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.positionStdDev = null;
                    object.orientationAxisStdDev = null;
                    object.orientationAngleStdDev = 0;
                    object.linearVelocityStdDev = null;
                    object.linearAccelerationStdDev = null;
                    object.angularVelocityStdDev = null;
                }
                if (message.positionStdDev != null && message.hasOwnProperty("positionStdDev"))
                    object.positionStdDev = $root.metamoto.types.Vector3.toObject(message.positionStdDev, options);
                if (message.orientationAxisStdDev != null && message.hasOwnProperty("orientationAxisStdDev"))
                    object.orientationAxisStdDev = $root.metamoto.types.Vector3.toObject(message.orientationAxisStdDev, options);
                if (message.orientationAngleStdDev != null && message.hasOwnProperty("orientationAngleStdDev"))
                    object.orientationAngleStdDev = options.json && !isFinite(message.orientationAngleStdDev) ? String(message.orientationAngleStdDev) : message.orientationAngleStdDev;
                if (message.linearVelocityStdDev != null && message.hasOwnProperty("linearVelocityStdDev"))
                    object.linearVelocityStdDev = $root.metamoto.types.Vector3.toObject(message.linearVelocityStdDev, options);
                if (message.linearAccelerationStdDev != null && message.hasOwnProperty("linearAccelerationStdDev"))
                    object.linearAccelerationStdDev = $root.metamoto.types.Vector3.toObject(message.linearAccelerationStdDev, options);
                if (message.angularVelocityStdDev != null && message.hasOwnProperty("angularVelocityStdDev"))
                    object.angularVelocityStdDev = $root.metamoto.types.Vector3.toObject(message.angularVelocityStdDev, options);
                return object;
            };

            /**
             * Converts this Uncertainty to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Uncertainty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Uncertainty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Uncertainty;
        })();

        messages.LogMessage = (function() {

            /**
             * Properties of a LogMessage.
             * @memberof metamoto.messages
             * @interface ILogMessage
             * @property {number|null} [time] LogMessage time
             * @property {metamoto.messages.LogMessage.Level|null} [level] LogMessage level
             * @property {string|null} [className] LogMessage className
             * @property {string|null} [method] LogMessage method
             * @property {number|null} [lineNumber] LogMessage lineNumber
             * @property {string|null} [message] LogMessage message
             * @property {number|null} [realTime] LogMessage realTime
             * @property {string|null} [filename] LogMessage filename
             */

            /**
             * Constructs a new LogMessage.
             * @memberof metamoto.messages
             * @classdesc Represents a LogMessage.
             * @implements ILogMessage
             * @constructor
             * @param {metamoto.messages.ILogMessage=} [properties] Properties to set
             */
            function LogMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LogMessage time.
             * @member {number} time
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.time = 0;

            /**
             * LogMessage level.
             * @member {metamoto.messages.LogMessage.Level} level
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.level = 0;

            /**
             * LogMessage className.
             * @member {string} className
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.className = "";

            /**
             * LogMessage method.
             * @member {string} method
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.method = "";

            /**
             * LogMessage lineNumber.
             * @member {number} lineNumber
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.lineNumber = 0;

            /**
             * LogMessage message.
             * @member {string} message
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.message = "";

            /**
             * LogMessage realTime.
             * @member {number} realTime
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.realTime = 0;

            /**
             * LogMessage filename.
             * @member {string} filename
             * @memberof metamoto.messages.LogMessage
             * @instance
             */
            LogMessage.prototype.filename = "";

            /**
             * Creates a new LogMessage instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {metamoto.messages.ILogMessage=} [properties] Properties to set
             * @returns {metamoto.messages.LogMessage} LogMessage instance
             */
            LogMessage.create = function create(properties) {
                return new LogMessage(properties);
            };

            /**
             * Encodes the specified LogMessage message. Does not implicitly {@link metamoto.messages.LogMessage.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {metamoto.messages.ILogMessage} message LogMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && message.hasOwnProperty("time"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                if (message.level != null && message.hasOwnProperty("level"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
                if (message.className != null && message.hasOwnProperty("className"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.className);
                if (message.method != null && message.hasOwnProperty("method"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.method);
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lineNumber);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.message);
                if (message.realTime != null && message.hasOwnProperty("realTime"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.realTime);
                if (message.filename != null && message.hasOwnProperty("filename"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.filename);
                return writer;
            };

            /**
             * Encodes the specified LogMessage message, length delimited. Does not implicitly {@link metamoto.messages.LogMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {metamoto.messages.ILogMessage} message LogMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LogMessage message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.LogMessage} LogMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.LogMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = reader.double();
                        break;
                    case 2:
                        message.level = reader.int32();
                        break;
                    case 3:
                        message.className = reader.string();
                        break;
                    case 4:
                        message.method = reader.string();
                        break;
                    case 5:
                        message.lineNumber = reader.int32();
                        break;
                    case 6:
                        message.message = reader.string();
                        break;
                    case 7:
                        message.realTime = reader.float();
                        break;
                    case 8:
                        message.filename = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LogMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.LogMessage} LogMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LogMessage message.
             * @function verify
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LogMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    switch (message.level) {
                    default:
                        return "level: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.className != null && message.hasOwnProperty("className"))
                    if (!$util.isString(message.className))
                        return "className: string expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    if (!$util.isString(message.method))
                        return "method: string expected";
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    if (!$util.isInteger(message.lineNumber))
                        return "lineNumber: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.realTime != null && message.hasOwnProperty("realTime"))
                    if (typeof message.realTime !== "number")
                        return "realTime: number expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                return null;
            };

            /**
             * Creates a LogMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.LogMessage} LogMessage
             */
            LogMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.LogMessage)
                    return object;
                var message = new $root.metamoto.messages.LogMessage();
                if (object.time != null)
                    message.time = Number(object.time);
                switch (object.level) {
                case "LEVEL_UNKNOWN":
                case 0:
                    message.level = 0;
                    break;
                case "LEVEL_ERROR":
                case 1:
                    message.level = 1;
                    break;
                case "LEVEL_WARNING":
                case 2:
                    message.level = 2;
                    break;
                case "LEVEL_INFO":
                case 3:
                    message.level = 3;
                    break;
                case "LEVEL_TRACE":
                case 4:
                    message.level = 4;
                    break;
                }
                if (object.className != null)
                    message.className = String(object.className);
                if (object.method != null)
                    message.method = String(object.method);
                if (object.lineNumber != null)
                    message.lineNumber = object.lineNumber | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.realTime != null)
                    message.realTime = Number(object.realTime);
                if (object.filename != null)
                    message.filename = String(object.filename);
                return message;
            };

            /**
             * Creates a plain object from a LogMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.LogMessage
             * @static
             * @param {metamoto.messages.LogMessage} message LogMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LogMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.time = 0;
                    object.level = options.enums === String ? "LEVEL_UNKNOWN" : 0;
                    object.className = "";
                    object.method = "";
                    object.lineNumber = 0;
                    object.message = "";
                    object.realTime = 0;
                    object.filename = "";
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = options.enums === String ? $root.metamoto.messages.LogMessage.Level[message.level] : message.level;
                if (message.className != null && message.hasOwnProperty("className"))
                    object.className = message.className;
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = message.method;
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    object.lineNumber = message.lineNumber;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.realTime != null && message.hasOwnProperty("realTime"))
                    object.realTime = options.json && !isFinite(message.realTime) ? String(message.realTime) : message.realTime;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                return object;
            };

            /**
             * Converts this LogMessage to JSON.
             * @function toJSON
             * @memberof metamoto.messages.LogMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LogMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Level enum.
             * @name metamoto.messages.LogMessage.Level
             * @enum {string}
             * @property {number} LEVEL_UNKNOWN=0 LEVEL_UNKNOWN value
             * @property {number} LEVEL_ERROR=1 LEVEL_ERROR value
             * @property {number} LEVEL_WARNING=2 LEVEL_WARNING value
             * @property {number} LEVEL_INFO=3 LEVEL_INFO value
             * @property {number} LEVEL_TRACE=4 LEVEL_TRACE value
             */
            LogMessage.Level = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LEVEL_UNKNOWN"] = 0;
                values[valuesById[1] = "LEVEL_ERROR"] = 1;
                values[valuesById[2] = "LEVEL_WARNING"] = 2;
                values[valuesById[3] = "LEVEL_INFO"] = 3;
                values[valuesById[4] = "LEVEL_TRACE"] = 4;
                return values;
            })();

            return LogMessage;
        })();

        messages.Perception = (function() {

            /**
             * Properties of a Perception.
             * @memberof metamoto.messages
             * @interface IPerception
             * @property {Array.<metamoto.types.IPerceptionObject>|null} [objects] Perception objects
             */

            /**
             * Constructs a new Perception.
             * @memberof metamoto.messages
             * @classdesc Represents a Perception.
             * @implements IPerception
             * @constructor
             * @param {metamoto.messages.IPerception=} [properties] Properties to set
             */
            function Perception(properties) {
                this.objects = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Perception objects.
             * @member {Array.<metamoto.types.IPerceptionObject>} objects
             * @memberof metamoto.messages.Perception
             * @instance
             */
            Perception.prototype.objects = $util.emptyArray;

            /**
             * Creates a new Perception instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Perception
             * @static
             * @param {metamoto.messages.IPerception=} [properties] Properties to set
             * @returns {metamoto.messages.Perception} Perception instance
             */
            Perception.create = function create(properties) {
                return new Perception(properties);
            };

            /**
             * Encodes the specified Perception message. Does not implicitly {@link metamoto.messages.Perception.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Perception
             * @static
             * @param {metamoto.messages.IPerception} message Perception message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Perception.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objects != null && message.objects.length)
                    for (var i = 0; i < message.objects.length; ++i)
                        $root.metamoto.types.PerceptionObject.encode(message.objects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Perception message, length delimited. Does not implicitly {@link metamoto.messages.Perception.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Perception
             * @static
             * @param {metamoto.messages.IPerception} message Perception message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Perception.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Perception message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Perception
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Perception} Perception
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Perception.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Perception();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push($root.metamoto.types.PerceptionObject.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Perception message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Perception
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Perception} Perception
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Perception.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Perception message.
             * @function verify
             * @memberof metamoto.messages.Perception
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Perception.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objects != null && message.hasOwnProperty("objects")) {
                    if (!Array.isArray(message.objects))
                        return "objects: array expected";
                    for (var i = 0; i < message.objects.length; ++i) {
                        var error = $root.metamoto.types.PerceptionObject.verify(message.objects[i]);
                        if (error)
                            return "objects." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Perception message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Perception
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Perception} Perception
             */
            Perception.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Perception)
                    return object;
                var message = new $root.metamoto.messages.Perception();
                if (object.objects) {
                    if (!Array.isArray(object.objects))
                        throw TypeError(".metamoto.messages.Perception.objects: array expected");
                    message.objects = [];
                    for (var i = 0; i < object.objects.length; ++i) {
                        if (typeof object.objects[i] !== "object")
                            throw TypeError(".metamoto.messages.Perception.objects: object expected");
                        message.objects[i] = $root.metamoto.types.PerceptionObject.fromObject(object.objects[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Perception message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Perception
             * @static
             * @param {metamoto.messages.Perception} message Perception
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Perception.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.objects = [];
                if (message.objects && message.objects.length) {
                    object.objects = [];
                    for (var j = 0; j < message.objects.length; ++j)
                        object.objects[j] = $root.metamoto.types.PerceptionObject.toObject(message.objects[j], options);
                }
                return object;
            };

            /**
             * Converts this Perception to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Perception
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Perception.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Perception;
        })();

        messages.Radar = (function() {

            /**
             * Properties of a Radar.
             * @memberof metamoto.messages
             * @interface IRadar
             * @property {Array.<metamoto.types.IRadarObject>|null} [objects] Radar objects
             */

            /**
             * Constructs a new Radar.
             * @memberof metamoto.messages
             * @classdesc Represents a Radar.
             * @implements IRadar
             * @constructor
             * @param {metamoto.messages.IRadar=} [properties] Properties to set
             */
            function Radar(properties) {
                this.objects = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Radar objects.
             * @member {Array.<metamoto.types.IRadarObject>} objects
             * @memberof metamoto.messages.Radar
             * @instance
             */
            Radar.prototype.objects = $util.emptyArray;

            /**
             * Creates a new Radar instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Radar
             * @static
             * @param {metamoto.messages.IRadar=} [properties] Properties to set
             * @returns {metamoto.messages.Radar} Radar instance
             */
            Radar.create = function create(properties) {
                return new Radar(properties);
            };

            /**
             * Encodes the specified Radar message. Does not implicitly {@link metamoto.messages.Radar.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Radar
             * @static
             * @param {metamoto.messages.IRadar} message Radar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Radar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objects != null && message.objects.length)
                    for (var i = 0; i < message.objects.length; ++i)
                        $root.metamoto.types.RadarObject.encode(message.objects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Radar message, length delimited. Does not implicitly {@link metamoto.messages.Radar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Radar
             * @static
             * @param {metamoto.messages.IRadar} message Radar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Radar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Radar message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Radar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Radar} Radar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Radar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Radar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push($root.metamoto.types.RadarObject.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Radar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Radar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Radar} Radar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Radar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Radar message.
             * @function verify
             * @memberof metamoto.messages.Radar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Radar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objects != null && message.hasOwnProperty("objects")) {
                    if (!Array.isArray(message.objects))
                        return "objects: array expected";
                    for (var i = 0; i < message.objects.length; ++i) {
                        var error = $root.metamoto.types.RadarObject.verify(message.objects[i]);
                        if (error)
                            return "objects." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Radar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Radar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Radar} Radar
             */
            Radar.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Radar)
                    return object;
                var message = new $root.metamoto.messages.Radar();
                if (object.objects) {
                    if (!Array.isArray(object.objects))
                        throw TypeError(".metamoto.messages.Radar.objects: array expected");
                    message.objects = [];
                    for (var i = 0; i < object.objects.length; ++i) {
                        if (typeof object.objects[i] !== "object")
                            throw TypeError(".metamoto.messages.Radar.objects: object expected");
                        message.objects[i] = $root.metamoto.types.RadarObject.fromObject(object.objects[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Radar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Radar
             * @static
             * @param {metamoto.messages.Radar} message Radar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Radar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.objects = [];
                if (message.objects && message.objects.length) {
                    object.objects = [];
                    for (var j = 0; j < message.objects.length; ++j)
                        object.objects[j] = $root.metamoto.types.RadarObject.toObject(message.objects[j], options);
                }
                return object;
            };

            /**
             * Converts this Radar to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Radar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Radar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Radar;
        })();

        messages.V2X = (function() {

            /**
             * Properties of a V2X.
             * @memberof metamoto.messages
             * @interface IV2X
             * @property {Array.<metamoto.messages.V2X.IBsmPart1>|null} [bsmPart_1] V2X bsmPart_1
             */

            /**
             * Constructs a new V2X.
             * @memberof metamoto.messages
             * @classdesc Represents a V2X.
             * @implements IV2X
             * @constructor
             * @param {metamoto.messages.IV2X=} [properties] Properties to set
             */
            function V2X(properties) {
                this.bsmPart_1 = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * V2X bsmPart_1.
             * @member {Array.<metamoto.messages.V2X.IBsmPart1>} bsmPart_1
             * @memberof metamoto.messages.V2X
             * @instance
             */
            V2X.prototype.bsmPart_1 = $util.emptyArray;

            /**
             * Creates a new V2X instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.V2X
             * @static
             * @param {metamoto.messages.IV2X=} [properties] Properties to set
             * @returns {metamoto.messages.V2X} V2X instance
             */
            V2X.create = function create(properties) {
                return new V2X(properties);
            };

            /**
             * Encodes the specified V2X message. Does not implicitly {@link metamoto.messages.V2X.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.V2X
             * @static
             * @param {metamoto.messages.IV2X} message V2X message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            V2X.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bsmPart_1 != null && message.bsmPart_1.length)
                    for (var i = 0; i < message.bsmPart_1.length; ++i)
                        $root.metamoto.messages.V2X.BsmPart1.encode(message.bsmPart_1[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified V2X message, length delimited. Does not implicitly {@link metamoto.messages.V2X.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.V2X
             * @static
             * @param {metamoto.messages.IV2X} message V2X message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            V2X.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a V2X message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.V2X
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.V2X} V2X
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            V2X.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.V2X();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.bsmPart_1 && message.bsmPart_1.length))
                            message.bsmPart_1 = [];
                        message.bsmPart_1.push($root.metamoto.messages.V2X.BsmPart1.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a V2X message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.V2X
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.V2X} V2X
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            V2X.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a V2X message.
             * @function verify
             * @memberof metamoto.messages.V2X
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            V2X.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bsmPart_1 != null && message.hasOwnProperty("bsmPart_1")) {
                    if (!Array.isArray(message.bsmPart_1))
                        return "bsmPart_1: array expected";
                    for (var i = 0; i < message.bsmPart_1.length; ++i) {
                        var error = $root.metamoto.messages.V2X.BsmPart1.verify(message.bsmPart_1[i]);
                        if (error)
                            return "bsmPart_1." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a V2X message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.V2X
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.V2X} V2X
             */
            V2X.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.V2X)
                    return object;
                var message = new $root.metamoto.messages.V2X();
                if (object.bsmPart_1) {
                    if (!Array.isArray(object.bsmPart_1))
                        throw TypeError(".metamoto.messages.V2X.bsmPart_1: array expected");
                    message.bsmPart_1 = [];
                    for (var i = 0; i < object.bsmPart_1.length; ++i) {
                        if (typeof object.bsmPart_1[i] !== "object")
                            throw TypeError(".metamoto.messages.V2X.bsmPart_1: object expected");
                        message.bsmPart_1[i] = $root.metamoto.messages.V2X.BsmPart1.fromObject(object.bsmPart_1[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a V2X message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.V2X
             * @static
             * @param {metamoto.messages.V2X} message V2X
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            V2X.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.bsmPart_1 = [];
                if (message.bsmPart_1 && message.bsmPart_1.length) {
                    object.bsmPart_1 = [];
                    for (var j = 0; j < message.bsmPart_1.length; ++j)
                        object.bsmPart_1[j] = $root.metamoto.messages.V2X.BsmPart1.toObject(message.bsmPart_1[j], options);
                }
                return object;
            };

            /**
             * Converts this V2X to JSON.
             * @function toJSON
             * @memberof metamoto.messages.V2X
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            V2X.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            V2X.BsmPart1 = (function() {

                /**
                 * Properties of a BsmPart1.
                 * @memberof metamoto.messages.V2X
                 * @interface IBsmPart1
                 * @property {number|null} [objectId] BsmPart1 objectId
                 * @property {number|null} [timeStamp] BsmPart1 timeStamp
                 * @property {metamoto.types.IGeoCoordinates|null} [position] BsmPart1 position
                 * @property {metamoto.messages.V2X.IPositionalAccuracy|null} [accuracy] BsmPart1 accuracy
                 * @property {metamoto.types.Vehicle.GearSelector|null} [transmissionState] BsmPart1 transmissionState
                 * @property {metamoto.types.IVector3|null} [linearVelocity] BsmPart1 linearVelocity
                 * @property {number|null} [steeringWheelAngle] BsmPart1 steeringWheelAngle
                 * @property {metamoto.types.IVector3|null} [linearAcceleration] BsmPart1 linearAcceleration
                 * @property {number|null} [yawRate] BsmPart1 yawRate
                 * @property {metamoto.messages.V2X.IBrakeSystemStatus|null} [brakes] BsmPart1 brakes
                 * @property {metamoto.types.IVector3|null} [vehicleSize] BsmPart1 vehicleSize
                 */

                /**
                 * Constructs a new BsmPart1.
                 * @memberof metamoto.messages.V2X
                 * @classdesc Represents a BsmPart1.
                 * @implements IBsmPart1
                 * @constructor
                 * @param {metamoto.messages.V2X.IBsmPart1=} [properties] Properties to set
                 */
                function BsmPart1(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BsmPart1 objectId.
                 * @member {number} objectId
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.objectId = 0;

                /**
                 * BsmPart1 timeStamp.
                 * @member {number} timeStamp
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.timeStamp = 0;

                /**
                 * BsmPart1 position.
                 * @member {metamoto.types.IGeoCoordinates|null|undefined} position
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.position = null;

                /**
                 * BsmPart1 accuracy.
                 * @member {metamoto.messages.V2X.IPositionalAccuracy|null|undefined} accuracy
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.accuracy = null;

                /**
                 * BsmPart1 transmissionState.
                 * @member {metamoto.types.Vehicle.GearSelector} transmissionState
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.transmissionState = 0;

                /**
                 * BsmPart1 linearVelocity.
                 * @member {metamoto.types.IVector3|null|undefined} linearVelocity
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.linearVelocity = null;

                /**
                 * BsmPart1 steeringWheelAngle.
                 * @member {number} steeringWheelAngle
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.steeringWheelAngle = 0;

                /**
                 * BsmPart1 linearAcceleration.
                 * @member {metamoto.types.IVector3|null|undefined} linearAcceleration
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.linearAcceleration = null;

                /**
                 * BsmPart1 yawRate.
                 * @member {number} yawRate
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.yawRate = 0;

                /**
                 * BsmPart1 brakes.
                 * @member {metamoto.messages.V2X.IBrakeSystemStatus|null|undefined} brakes
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.brakes = null;

                /**
                 * BsmPart1 vehicleSize.
                 * @member {metamoto.types.IVector3|null|undefined} vehicleSize
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 */
                BsmPart1.prototype.vehicleSize = null;

                /**
                 * Creates a new BsmPart1 instance using the specified properties.
                 * @function create
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {metamoto.messages.V2X.IBsmPart1=} [properties] Properties to set
                 * @returns {metamoto.messages.V2X.BsmPart1} BsmPart1 instance
                 */
                BsmPart1.create = function create(properties) {
                    return new BsmPart1(properties);
                };

                /**
                 * Encodes the specified BsmPart1 message. Does not implicitly {@link metamoto.messages.V2X.BsmPart1.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {metamoto.messages.V2X.IBsmPart1} message BsmPart1 message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BsmPart1.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.objectId);
                    if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.timeStamp);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.metamoto.types.GeoCoordinates.encode(message.position, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.accuracy != null && message.hasOwnProperty("accuracy"))
                        $root.metamoto.messages.V2X.PositionalAccuracy.encode(message.accuracy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.transmissionState != null && message.hasOwnProperty("transmissionState"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.transmissionState);
                    if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity"))
                        $root.metamoto.types.Vector3.encode(message.linearVelocity, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.steeringWheelAngle != null && message.hasOwnProperty("steeringWheelAngle"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.steeringWheelAngle);
                    if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                        $root.metamoto.types.Vector3.encode(message.linearAcceleration, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.yawRate != null && message.hasOwnProperty("yawRate"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.yawRate);
                    if (message.brakes != null && message.hasOwnProperty("brakes"))
                        $root.metamoto.messages.V2X.BrakeSystemStatus.encode(message.brakes, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.vehicleSize != null && message.hasOwnProperty("vehicleSize"))
                        $root.metamoto.types.Vector3.encode(message.vehicleSize, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BsmPart1 message, length delimited. Does not implicitly {@link metamoto.messages.V2X.BsmPart1.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {metamoto.messages.V2X.IBsmPart1} message BsmPart1 message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BsmPart1.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BsmPart1 message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.messages.V2X.BsmPart1} BsmPart1
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BsmPart1.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.V2X.BsmPart1();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.objectId = reader.int32();
                            break;
                        case 2:
                            message.timeStamp = reader.double();
                            break;
                        case 3:
                            message.position = $root.metamoto.types.GeoCoordinates.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.accuracy = $root.metamoto.messages.V2X.PositionalAccuracy.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.transmissionState = reader.int32();
                            break;
                        case 6:
                            message.linearVelocity = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.steeringWheelAngle = reader.float();
                            break;
                        case 8:
                            message.linearAcceleration = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.yawRate = reader.float();
                            break;
                        case 10:
                            message.brakes = $root.metamoto.messages.V2X.BrakeSystemStatus.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.vehicleSize = $root.metamoto.types.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BsmPart1 message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.messages.V2X.BsmPart1} BsmPart1
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BsmPart1.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BsmPart1 message.
                 * @function verify
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BsmPart1.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        if (!$util.isInteger(message.objectId))
                            return "objectId: integer expected";
                    if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                        if (typeof message.timeStamp !== "number")
                            return "timeStamp: number expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.metamoto.types.GeoCoordinates.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.accuracy != null && message.hasOwnProperty("accuracy")) {
                        var error = $root.metamoto.messages.V2X.PositionalAccuracy.verify(message.accuracy);
                        if (error)
                            return "accuracy." + error;
                    }
                    if (message.transmissionState != null && message.hasOwnProperty("transmissionState"))
                        switch (message.transmissionState) {
                        default:
                            return "transmissionState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity")) {
                        var error = $root.metamoto.types.Vector3.verify(message.linearVelocity);
                        if (error)
                            return "linearVelocity." + error;
                    }
                    if (message.steeringWheelAngle != null && message.hasOwnProperty("steeringWheelAngle"))
                        if (typeof message.steeringWheelAngle !== "number")
                            return "steeringWheelAngle: number expected";
                    if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration")) {
                        var error = $root.metamoto.types.Vector3.verify(message.linearAcceleration);
                        if (error)
                            return "linearAcceleration." + error;
                    }
                    if (message.yawRate != null && message.hasOwnProperty("yawRate"))
                        if (typeof message.yawRate !== "number")
                            return "yawRate: number expected";
                    if (message.brakes != null && message.hasOwnProperty("brakes")) {
                        var error = $root.metamoto.messages.V2X.BrakeSystemStatus.verify(message.brakes);
                        if (error)
                            return "brakes." + error;
                    }
                    if (message.vehicleSize != null && message.hasOwnProperty("vehicleSize")) {
                        var error = $root.metamoto.types.Vector3.verify(message.vehicleSize);
                        if (error)
                            return "vehicleSize." + error;
                    }
                    return null;
                };

                /**
                 * Creates a BsmPart1 message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.messages.V2X.BsmPart1} BsmPart1
                 */
                BsmPart1.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.messages.V2X.BsmPart1)
                        return object;
                    var message = new $root.metamoto.messages.V2X.BsmPart1();
                    if (object.objectId != null)
                        message.objectId = object.objectId | 0;
                    if (object.timeStamp != null)
                        message.timeStamp = Number(object.timeStamp);
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.position: object expected");
                        message.position = $root.metamoto.types.GeoCoordinates.fromObject(object.position);
                    }
                    if (object.accuracy != null) {
                        if (typeof object.accuracy !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.accuracy: object expected");
                        message.accuracy = $root.metamoto.messages.V2X.PositionalAccuracy.fromObject(object.accuracy);
                    }
                    switch (object.transmissionState) {
                    case "GEAR_UNKNOWN":
                    case 0:
                        message.transmissionState = 0;
                        break;
                    case "GEAR_OTHER":
                    case 1:
                        message.transmissionState = 1;
                        break;
                    case "GEAR_P":
                    case 2:
                        message.transmissionState = 2;
                        break;
                    case "GEAR_R":
                    case 3:
                        message.transmissionState = 3;
                        break;
                    case "GEAR_N":
                    case 4:
                        message.transmissionState = 4;
                        break;
                    case "GEAR_D":
                    case 5:
                        message.transmissionState = 5;
                        break;
                    case "GEAR_L":
                    case 6:
                        message.transmissionState = 6;
                        break;
                    }
                    if (object.linearVelocity != null) {
                        if (typeof object.linearVelocity !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.linearVelocity: object expected");
                        message.linearVelocity = $root.metamoto.types.Vector3.fromObject(object.linearVelocity);
                    }
                    if (object.steeringWheelAngle != null)
                        message.steeringWheelAngle = Number(object.steeringWheelAngle);
                    if (object.linearAcceleration != null) {
                        if (typeof object.linearAcceleration !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.linearAcceleration: object expected");
                        message.linearAcceleration = $root.metamoto.types.Vector3.fromObject(object.linearAcceleration);
                    }
                    if (object.yawRate != null)
                        message.yawRate = Number(object.yawRate);
                    if (object.brakes != null) {
                        if (typeof object.brakes !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.brakes: object expected");
                        message.brakes = $root.metamoto.messages.V2X.BrakeSystemStatus.fromObject(object.brakes);
                    }
                    if (object.vehicleSize != null) {
                        if (typeof object.vehicleSize !== "object")
                            throw TypeError(".metamoto.messages.V2X.BsmPart1.vehicleSize: object expected");
                        message.vehicleSize = $root.metamoto.types.Vector3.fromObject(object.vehicleSize);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BsmPart1 message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @static
                 * @param {metamoto.messages.V2X.BsmPart1} message BsmPart1
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BsmPart1.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.objectId = 0;
                        object.timeStamp = 0;
                        object.position = null;
                        object.accuracy = null;
                        object.transmissionState = options.enums === String ? "GEAR_UNKNOWN" : 0;
                        object.linearVelocity = null;
                        object.steeringWheelAngle = 0;
                        object.linearAcceleration = null;
                        object.yawRate = 0;
                        object.brakes = null;
                        object.vehicleSize = null;
                    }
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        object.objectId = message.objectId;
                    if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                        object.timeStamp = options.json && !isFinite(message.timeStamp) ? String(message.timeStamp) : message.timeStamp;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.metamoto.types.GeoCoordinates.toObject(message.position, options);
                    if (message.accuracy != null && message.hasOwnProperty("accuracy"))
                        object.accuracy = $root.metamoto.messages.V2X.PositionalAccuracy.toObject(message.accuracy, options);
                    if (message.transmissionState != null && message.hasOwnProperty("transmissionState"))
                        object.transmissionState = options.enums === String ? $root.metamoto.types.Vehicle.GearSelector[message.transmissionState] : message.transmissionState;
                    if (message.linearVelocity != null && message.hasOwnProperty("linearVelocity"))
                        object.linearVelocity = $root.metamoto.types.Vector3.toObject(message.linearVelocity, options);
                    if (message.steeringWheelAngle != null && message.hasOwnProperty("steeringWheelAngle"))
                        object.steeringWheelAngle = options.json && !isFinite(message.steeringWheelAngle) ? String(message.steeringWheelAngle) : message.steeringWheelAngle;
                    if (message.linearAcceleration != null && message.hasOwnProperty("linearAcceleration"))
                        object.linearAcceleration = $root.metamoto.types.Vector3.toObject(message.linearAcceleration, options);
                    if (message.yawRate != null && message.hasOwnProperty("yawRate"))
                        object.yawRate = options.json && !isFinite(message.yawRate) ? String(message.yawRate) : message.yawRate;
                    if (message.brakes != null && message.hasOwnProperty("brakes"))
                        object.brakes = $root.metamoto.messages.V2X.BrakeSystemStatus.toObject(message.brakes, options);
                    if (message.vehicleSize != null && message.hasOwnProperty("vehicleSize"))
                        object.vehicleSize = $root.metamoto.types.Vector3.toObject(message.vehicleSize, options);
                    return object;
                };

                /**
                 * Converts this BsmPart1 to JSON.
                 * @function toJSON
                 * @memberof metamoto.messages.V2X.BsmPart1
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BsmPart1.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BsmPart1;
            })();

            V2X.PositionalAccuracy = (function() {

                /**
                 * Properties of a PositionalAccuracy.
                 * @memberof metamoto.messages.V2X
                 * @interface IPositionalAccuracy
                 * @property {number|null} [semiMajor] PositionalAccuracy semiMajor
                 * @property {number|null} [semiMinor] PositionalAccuracy semiMinor
                 * @property {number|null} [orientation] PositionalAccuracy orientation
                 */

                /**
                 * Constructs a new PositionalAccuracy.
                 * @memberof metamoto.messages.V2X
                 * @classdesc Represents a PositionalAccuracy.
                 * @implements IPositionalAccuracy
                 * @constructor
                 * @param {metamoto.messages.V2X.IPositionalAccuracy=} [properties] Properties to set
                 */
                function PositionalAccuracy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PositionalAccuracy semiMajor.
                 * @member {number} semiMajor
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @instance
                 */
                PositionalAccuracy.prototype.semiMajor = 0;

                /**
                 * PositionalAccuracy semiMinor.
                 * @member {number} semiMinor
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @instance
                 */
                PositionalAccuracy.prototype.semiMinor = 0;

                /**
                 * PositionalAccuracy orientation.
                 * @member {number} orientation
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @instance
                 */
                PositionalAccuracy.prototype.orientation = 0;

                /**
                 * Creates a new PositionalAccuracy instance using the specified properties.
                 * @function create
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {metamoto.messages.V2X.IPositionalAccuracy=} [properties] Properties to set
                 * @returns {metamoto.messages.V2X.PositionalAccuracy} PositionalAccuracy instance
                 */
                PositionalAccuracy.create = function create(properties) {
                    return new PositionalAccuracy(properties);
                };

                /**
                 * Encodes the specified PositionalAccuracy message. Does not implicitly {@link metamoto.messages.V2X.PositionalAccuracy.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {metamoto.messages.V2X.IPositionalAccuracy} message PositionalAccuracy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PositionalAccuracy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.semiMajor != null && message.hasOwnProperty("semiMajor"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.semiMajor);
                    if (message.semiMinor != null && message.hasOwnProperty("semiMinor"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.semiMinor);
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.orientation);
                    return writer;
                };

                /**
                 * Encodes the specified PositionalAccuracy message, length delimited. Does not implicitly {@link metamoto.messages.V2X.PositionalAccuracy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {metamoto.messages.V2X.IPositionalAccuracy} message PositionalAccuracy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PositionalAccuracy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PositionalAccuracy message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.messages.V2X.PositionalAccuracy} PositionalAccuracy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PositionalAccuracy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.V2X.PositionalAccuracy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.semiMajor = reader.float();
                            break;
                        case 2:
                            message.semiMinor = reader.float();
                            break;
                        case 3:
                            message.orientation = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PositionalAccuracy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.messages.V2X.PositionalAccuracy} PositionalAccuracy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PositionalAccuracy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PositionalAccuracy message.
                 * @function verify
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PositionalAccuracy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.semiMajor != null && message.hasOwnProperty("semiMajor"))
                        if (typeof message.semiMajor !== "number")
                            return "semiMajor: number expected";
                    if (message.semiMinor != null && message.hasOwnProperty("semiMinor"))
                        if (typeof message.semiMinor !== "number")
                            return "semiMinor: number expected";
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        if (typeof message.orientation !== "number")
                            return "orientation: number expected";
                    return null;
                };

                /**
                 * Creates a PositionalAccuracy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.messages.V2X.PositionalAccuracy} PositionalAccuracy
                 */
                PositionalAccuracy.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.messages.V2X.PositionalAccuracy)
                        return object;
                    var message = new $root.metamoto.messages.V2X.PositionalAccuracy();
                    if (object.semiMajor != null)
                        message.semiMajor = Number(object.semiMajor);
                    if (object.semiMinor != null)
                        message.semiMinor = Number(object.semiMinor);
                    if (object.orientation != null)
                        message.orientation = Number(object.orientation);
                    return message;
                };

                /**
                 * Creates a plain object from a PositionalAccuracy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @static
                 * @param {metamoto.messages.V2X.PositionalAccuracy} message PositionalAccuracy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PositionalAccuracy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.semiMajor = 0;
                        object.semiMinor = 0;
                        object.orientation = 0;
                    }
                    if (message.semiMajor != null && message.hasOwnProperty("semiMajor"))
                        object.semiMajor = options.json && !isFinite(message.semiMajor) ? String(message.semiMajor) : message.semiMajor;
                    if (message.semiMinor != null && message.hasOwnProperty("semiMinor"))
                        object.semiMinor = options.json && !isFinite(message.semiMinor) ? String(message.semiMinor) : message.semiMinor;
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        object.orientation = options.json && !isFinite(message.orientation) ? String(message.orientation) : message.orientation;
                    return object;
                };

                /**
                 * Converts this PositionalAccuracy to JSON.
                 * @function toJSON
                 * @memberof metamoto.messages.V2X.PositionalAccuracy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PositionalAccuracy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PositionalAccuracy;
            })();

            V2X.BrakeSystemStatus = (function() {

                /**
                 * Properties of a BrakeSystemStatus.
                 * @memberof metamoto.messages.V2X
                 * @interface IBrakeSystemStatus
                 * @property {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus|null} [wheelBrakes] BrakeSystemStatus wheelBrakes
                 * @property {metamoto.messages.V2X.BrakeSystemStatus.TractionControlState|null} [traction] BrakeSystemStatus traction
                 * @property {metamoto.messages.V2X.BrakeSystemStatus.AntiLockBrakeStatus|null} [abs] BrakeSystemStatus abs
                 * @property {metamoto.messages.V2X.BrakeSystemStatus.StabilityControlStatus|null} [scs] BrakeSystemStatus scs
                 * @property {metamoto.messages.V2X.BrakeSystemStatus.BrakeBoostApplied|null} [brakeBoost] BrakeSystemStatus brakeBoost
                 */

                /**
                 * Constructs a new BrakeSystemStatus.
                 * @memberof metamoto.messages.V2X
                 * @classdesc Represents a BrakeSystemStatus.
                 * @implements IBrakeSystemStatus
                 * @constructor
                 * @param {metamoto.messages.V2X.IBrakeSystemStatus=} [properties] Properties to set
                 */
                function BrakeSystemStatus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BrakeSystemStatus wheelBrakes.
                 * @member {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus|null|undefined} wheelBrakes
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 */
                BrakeSystemStatus.prototype.wheelBrakes = null;

                /**
                 * BrakeSystemStatus traction.
                 * @member {metamoto.messages.V2X.BrakeSystemStatus.TractionControlState} traction
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 */
                BrakeSystemStatus.prototype.traction = 0;

                /**
                 * BrakeSystemStatus abs.
                 * @member {metamoto.messages.V2X.BrakeSystemStatus.AntiLockBrakeStatus} abs
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 */
                BrakeSystemStatus.prototype.abs = 0;

                /**
                 * BrakeSystemStatus scs.
                 * @member {metamoto.messages.V2X.BrakeSystemStatus.StabilityControlStatus} scs
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 */
                BrakeSystemStatus.prototype.scs = 0;

                /**
                 * BrakeSystemStatus brakeBoost.
                 * @member {metamoto.messages.V2X.BrakeSystemStatus.BrakeBoostApplied} brakeBoost
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 */
                BrakeSystemStatus.prototype.brakeBoost = 0;

                /**
                 * Creates a new BrakeSystemStatus instance using the specified properties.
                 * @function create
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {metamoto.messages.V2X.IBrakeSystemStatus=} [properties] Properties to set
                 * @returns {metamoto.messages.V2X.BrakeSystemStatus} BrakeSystemStatus instance
                 */
                BrakeSystemStatus.create = function create(properties) {
                    return new BrakeSystemStatus(properties);
                };

                /**
                 * Encodes the specified BrakeSystemStatus message. Does not implicitly {@link metamoto.messages.V2X.BrakeSystemStatus.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {metamoto.messages.V2X.IBrakeSystemStatus} message BrakeSystemStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrakeSystemStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.wheelBrakes != null && message.hasOwnProperty("wheelBrakes"))
                        $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.encode(message.wheelBrakes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.traction != null && message.hasOwnProperty("traction"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.traction);
                    if (message.abs != null && message.hasOwnProperty("abs"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.abs);
                    if (message.scs != null && message.hasOwnProperty("scs"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.scs);
                    if (message.brakeBoost != null && message.hasOwnProperty("brakeBoost"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.brakeBoost);
                    return writer;
                };

                /**
                 * Encodes the specified BrakeSystemStatus message, length delimited. Does not implicitly {@link metamoto.messages.V2X.BrakeSystemStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {metamoto.messages.V2X.IBrakeSystemStatus} message BrakeSystemStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrakeSystemStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BrakeSystemStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.messages.V2X.BrakeSystemStatus} BrakeSystemStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrakeSystemStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.V2X.BrakeSystemStatus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.wheelBrakes = $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.traction = reader.int32();
                            break;
                        case 3:
                            message.abs = reader.int32();
                            break;
                        case 4:
                            message.scs = reader.int32();
                            break;
                        case 5:
                            message.brakeBoost = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BrakeSystemStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.messages.V2X.BrakeSystemStatus} BrakeSystemStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrakeSystemStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BrakeSystemStatus message.
                 * @function verify
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BrakeSystemStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wheelBrakes != null && message.hasOwnProperty("wheelBrakes")) {
                        var error = $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.verify(message.wheelBrakes);
                        if (error)
                            return "wheelBrakes." + error;
                    }
                    if (message.traction != null && message.hasOwnProperty("traction"))
                        switch (message.traction) {
                        default:
                            return "traction: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.abs != null && message.hasOwnProperty("abs"))
                        switch (message.abs) {
                        default:
                            return "abs: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.scs != null && message.hasOwnProperty("scs"))
                        switch (message.scs) {
                        default:
                            return "scs: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.brakeBoost != null && message.hasOwnProperty("brakeBoost"))
                        switch (message.brakeBoost) {
                        default:
                            return "brakeBoost: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a BrakeSystemStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.messages.V2X.BrakeSystemStatus} BrakeSystemStatus
                 */
                BrakeSystemStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.messages.V2X.BrakeSystemStatus)
                        return object;
                    var message = new $root.metamoto.messages.V2X.BrakeSystemStatus();
                    if (object.wheelBrakes != null) {
                        if (typeof object.wheelBrakes !== "object")
                            throw TypeError(".metamoto.messages.V2X.BrakeSystemStatus.wheelBrakes: object expected");
                        message.wheelBrakes = $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.fromObject(object.wheelBrakes);
                    }
                    switch (object.traction) {
                    case "TRACTION_UNAVAILABLE":
                    case 0:
                        message.traction = 0;
                        break;
                    case "TRACTION_OFF":
                    case 1:
                        message.traction = 1;
                        break;
                    case "TRACTION_ON":
                    case 2:
                        message.traction = 2;
                        break;
                    case "TRACTION_ENGAGED":
                    case 3:
                        message.traction = 3;
                        break;
                    }
                    switch (object.abs) {
                    case "ABS_UNAVAILABLE":
                    case 0:
                        message.abs = 0;
                        break;
                    case "ABS_OFF":
                    case 1:
                        message.abs = 1;
                        break;
                    case "ABS_ON":
                    case 2:
                        message.abs = 2;
                        break;
                    case "ABS_ENGAGED":
                    case 3:
                        message.abs = 3;
                        break;
                    }
                    switch (object.scs) {
                    case "SC_UNAVAILABLE":
                    case 0:
                        message.scs = 0;
                        break;
                    case "SC_OFF":
                    case 1:
                        message.scs = 1;
                        break;
                    case "SC_ON":
                    case 2:
                        message.scs = 2;
                        break;
                    }
                    switch (object.brakeBoost) {
                    case "BB_UNAVAILABLE":
                    case 0:
                        message.brakeBoost = 0;
                        break;
                    case "BB_OFF":
                    case 1:
                        message.brakeBoost = 1;
                        break;
                    case "BB_ON":
                    case 2:
                        message.brakeBoost = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BrakeSystemStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @static
                 * @param {metamoto.messages.V2X.BrakeSystemStatus} message BrakeSystemStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrakeSystemStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.wheelBrakes = null;
                        object.traction = options.enums === String ? "TRACTION_UNAVAILABLE" : 0;
                        object.abs = options.enums === String ? "ABS_UNAVAILABLE" : 0;
                        object.scs = options.enums === String ? "SC_UNAVAILABLE" : 0;
                        object.brakeBoost = options.enums === String ? "BB_UNAVAILABLE" : 0;
                    }
                    if (message.wheelBrakes != null && message.hasOwnProperty("wheelBrakes"))
                        object.wheelBrakes = $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.toObject(message.wheelBrakes, options);
                    if (message.traction != null && message.hasOwnProperty("traction"))
                        object.traction = options.enums === String ? $root.metamoto.messages.V2X.BrakeSystemStatus.TractionControlState[message.traction] : message.traction;
                    if (message.abs != null && message.hasOwnProperty("abs"))
                        object.abs = options.enums === String ? $root.metamoto.messages.V2X.BrakeSystemStatus.AntiLockBrakeStatus[message.abs] : message.abs;
                    if (message.scs != null && message.hasOwnProperty("scs"))
                        object.scs = options.enums === String ? $root.metamoto.messages.V2X.BrakeSystemStatus.StabilityControlStatus[message.scs] : message.scs;
                    if (message.brakeBoost != null && message.hasOwnProperty("brakeBoost"))
                        object.brakeBoost = options.enums === String ? $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeBoostApplied[message.brakeBoost] : message.brakeBoost;
                    return object;
                };

                /**
                 * Converts this BrakeSystemStatus to JSON.
                 * @function toJSON
                 * @memberof metamoto.messages.V2X.BrakeSystemStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrakeSystemStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                BrakeSystemStatus.BrakeAppliedStatus = (function() {

                    /**
                     * Properties of a BrakeAppliedStatus.
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus
                     * @interface IBrakeAppliedStatus
                     * @property {boolean|null} [leftFront] BrakeAppliedStatus leftFront
                     * @property {boolean|null} [leftRear] BrakeAppliedStatus leftRear
                     * @property {boolean|null} [rightFront] BrakeAppliedStatus rightFront
                     * @property {boolean|null} [rightRear] BrakeAppliedStatus rightRear
                     */

                    /**
                     * Constructs a new BrakeAppliedStatus.
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus
                     * @classdesc Represents a BrakeAppliedStatus.
                     * @implements IBrakeAppliedStatus
                     * @constructor
                     * @param {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus=} [properties] Properties to set
                     */
                    function BrakeAppliedStatus(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * BrakeAppliedStatus leftFront.
                     * @member {boolean} leftFront
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @instance
                     */
                    BrakeAppliedStatus.prototype.leftFront = false;

                    /**
                     * BrakeAppliedStatus leftRear.
                     * @member {boolean} leftRear
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @instance
                     */
                    BrakeAppliedStatus.prototype.leftRear = false;

                    /**
                     * BrakeAppliedStatus rightFront.
                     * @member {boolean} rightFront
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @instance
                     */
                    BrakeAppliedStatus.prototype.rightFront = false;

                    /**
                     * BrakeAppliedStatus rightRear.
                     * @member {boolean} rightRear
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @instance
                     */
                    BrakeAppliedStatus.prototype.rightRear = false;

                    /**
                     * Creates a new BrakeAppliedStatus instance using the specified properties.
                     * @function create
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus=} [properties] Properties to set
                     * @returns {metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus} BrakeAppliedStatus instance
                     */
                    BrakeAppliedStatus.create = function create(properties) {
                        return new BrakeAppliedStatus(properties);
                    };

                    /**
                     * Encodes the specified BrakeAppliedStatus message. Does not implicitly {@link metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.verify|verify} messages.
                     * @function encode
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus} message BrakeAppliedStatus message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BrakeAppliedStatus.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.leftFront != null && message.hasOwnProperty("leftFront"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.leftFront);
                        if (message.leftRear != null && message.hasOwnProperty("leftRear"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.leftRear);
                        if (message.rightFront != null && message.hasOwnProperty("rightFront"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.rightFront);
                        if (message.rightRear != null && message.hasOwnProperty("rightRear"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.rightRear);
                        return writer;
                    };

                    /**
                     * Encodes the specified BrakeAppliedStatus message, length delimited. Does not implicitly {@link metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {metamoto.messages.V2X.BrakeSystemStatus.IBrakeAppliedStatus} message BrakeAppliedStatus message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BrakeAppliedStatus.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BrakeAppliedStatus message from the specified reader or buffer.
                     * @function decode
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus} BrakeAppliedStatus
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BrakeAppliedStatus.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.leftFront = reader.bool();
                                break;
                            case 2:
                                message.leftRear = reader.bool();
                                break;
                            case 3:
                                message.rightFront = reader.bool();
                                break;
                            case 4:
                                message.rightRear = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BrakeAppliedStatus message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus} BrakeAppliedStatus
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BrakeAppliedStatus.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BrakeAppliedStatus message.
                     * @function verify
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BrakeAppliedStatus.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.leftFront != null && message.hasOwnProperty("leftFront"))
                            if (typeof message.leftFront !== "boolean")
                                return "leftFront: boolean expected";
                        if (message.leftRear != null && message.hasOwnProperty("leftRear"))
                            if (typeof message.leftRear !== "boolean")
                                return "leftRear: boolean expected";
                        if (message.rightFront != null && message.hasOwnProperty("rightFront"))
                            if (typeof message.rightFront !== "boolean")
                                return "rightFront: boolean expected";
                        if (message.rightRear != null && message.hasOwnProperty("rightRear"))
                            if (typeof message.rightRear !== "boolean")
                                return "rightRear: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a BrakeAppliedStatus message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus} BrakeAppliedStatus
                     */
                    BrakeAppliedStatus.fromObject = function fromObject(object) {
                        if (object instanceof $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus)
                            return object;
                        var message = new $root.metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus();
                        if (object.leftFront != null)
                            message.leftFront = Boolean(object.leftFront);
                        if (object.leftRear != null)
                            message.leftRear = Boolean(object.leftRear);
                        if (object.rightFront != null)
                            message.rightFront = Boolean(object.rightFront);
                        if (object.rightRear != null)
                            message.rightRear = Boolean(object.rightRear);
                        return message;
                    };

                    /**
                     * Creates a plain object from a BrakeAppliedStatus message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @static
                     * @param {metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus} message BrakeAppliedStatus
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BrakeAppliedStatus.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.leftFront = false;
                            object.leftRear = false;
                            object.rightFront = false;
                            object.rightRear = false;
                        }
                        if (message.leftFront != null && message.hasOwnProperty("leftFront"))
                            object.leftFront = message.leftFront;
                        if (message.leftRear != null && message.hasOwnProperty("leftRear"))
                            object.leftRear = message.leftRear;
                        if (message.rightFront != null && message.hasOwnProperty("rightFront"))
                            object.rightFront = message.rightFront;
                        if (message.rightRear != null && message.hasOwnProperty("rightRear"))
                            object.rightRear = message.rightRear;
                        return object;
                    };

                    /**
                     * Converts this BrakeAppliedStatus to JSON.
                     * @function toJSON
                     * @memberof metamoto.messages.V2X.BrakeSystemStatus.BrakeAppliedStatus
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BrakeAppliedStatus.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return BrakeAppliedStatus;
                })();

                /**
                 * TractionControlState enum.
                 * @name metamoto.messages.V2X.BrakeSystemStatus.TractionControlState
                 * @enum {string}
                 * @property {number} TRACTION_UNAVAILABLE=0 TRACTION_UNAVAILABLE value
                 * @property {number} TRACTION_OFF=1 TRACTION_OFF value
                 * @property {number} TRACTION_ON=2 TRACTION_ON value
                 * @property {number} TRACTION_ENGAGED=3 TRACTION_ENGAGED value
                 */
                BrakeSystemStatus.TractionControlState = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TRACTION_UNAVAILABLE"] = 0;
                    values[valuesById[1] = "TRACTION_OFF"] = 1;
                    values[valuesById[2] = "TRACTION_ON"] = 2;
                    values[valuesById[3] = "TRACTION_ENGAGED"] = 3;
                    return values;
                })();

                /**
                 * AntiLockBrakeStatus enum.
                 * @name metamoto.messages.V2X.BrakeSystemStatus.AntiLockBrakeStatus
                 * @enum {string}
                 * @property {number} ABS_UNAVAILABLE=0 ABS_UNAVAILABLE value
                 * @property {number} ABS_OFF=1 ABS_OFF value
                 * @property {number} ABS_ON=2 ABS_ON value
                 * @property {number} ABS_ENGAGED=3 ABS_ENGAGED value
                 */
                BrakeSystemStatus.AntiLockBrakeStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ABS_UNAVAILABLE"] = 0;
                    values[valuesById[1] = "ABS_OFF"] = 1;
                    values[valuesById[2] = "ABS_ON"] = 2;
                    values[valuesById[3] = "ABS_ENGAGED"] = 3;
                    return values;
                })();

                /**
                 * StabilityControlStatus enum.
                 * @name metamoto.messages.V2X.BrakeSystemStatus.StabilityControlStatus
                 * @enum {string}
                 * @property {number} SC_UNAVAILABLE=0 SC_UNAVAILABLE value
                 * @property {number} SC_OFF=1 SC_OFF value
                 * @property {number} SC_ON=2 SC_ON value
                 */
                BrakeSystemStatus.StabilityControlStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SC_UNAVAILABLE"] = 0;
                    values[valuesById[1] = "SC_OFF"] = 1;
                    values[valuesById[2] = "SC_ON"] = 2;
                    return values;
                })();

                /**
                 * BrakeBoostApplied enum.
                 * @name metamoto.messages.V2X.BrakeSystemStatus.BrakeBoostApplied
                 * @enum {string}
                 * @property {number} BB_UNAVAILABLE=0 BB_UNAVAILABLE value
                 * @property {number} BB_OFF=1 BB_OFF value
                 * @property {number} BB_ON=2 BB_ON value
                 */
                BrakeSystemStatus.BrakeBoostApplied = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BB_UNAVAILABLE"] = 0;
                    values[valuesById[1] = "BB_OFF"] = 1;
                    values[valuesById[2] = "BB_ON"] = 2;
                    return values;
                })();

                return BrakeSystemStatus;
            })();

            return V2X;
        })();

        messages.VehicleControls = (function() {

            /**
             * Properties of a VehicleControls.
             * @memberof metamoto.messages
             * @interface IVehicleControls
             * @property {google.protobuf.IFloatValue|null} [steer] VehicleControls steer
             * @property {google.protobuf.IFloatValue|null} [throttle] VehicleControls throttle
             * @property {google.protobuf.IFloatValue|null} [brake] VehicleControls brake
             * @property {metamoto.types.Vehicle.GearSelector|null} [gearSelector] VehicleControls gearSelector
             * @property {number|null} [gear] VehicleControls gear
             * @property {metamoto.types.Vehicle.SignalLightState|null} [turnSignal] VehicleControls turnSignal
             * @property {metamoto.types.Vehicle.LightState|null} [headLights] VehicleControls headLights
             * @property {google.protobuf.IFloatValue|null} [acceleration] VehicleControls acceleration
             * @property {Array.<metamoto.messages.VehicleControls.IWheelControl>|null} [wheelControls] VehicleControls wheelControls
             */

            /**
             * Constructs a new VehicleControls.
             * @memberof metamoto.messages
             * @classdesc Represents a VehicleControls.
             * @implements IVehicleControls
             * @constructor
             * @param {metamoto.messages.IVehicleControls=} [properties] Properties to set
             */
            function VehicleControls(properties) {
                this.wheelControls = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleControls steer.
             * @member {google.protobuf.IFloatValue|null|undefined} steer
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.steer = null;

            /**
             * VehicleControls throttle.
             * @member {google.protobuf.IFloatValue|null|undefined} throttle
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.throttle = null;

            /**
             * VehicleControls brake.
             * @member {google.protobuf.IFloatValue|null|undefined} brake
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.brake = null;

            /**
             * VehicleControls gearSelector.
             * @member {metamoto.types.Vehicle.GearSelector} gearSelector
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.gearSelector = 0;

            /**
             * VehicleControls gear.
             * @member {number} gear
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.gear = 0;

            /**
             * VehicleControls turnSignal.
             * @member {metamoto.types.Vehicle.SignalLightState} turnSignal
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.turnSignal = 0;

            /**
             * VehicleControls headLights.
             * @member {metamoto.types.Vehicle.LightState} headLights
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.headLights = 0;

            /**
             * VehicleControls acceleration.
             * @member {google.protobuf.IFloatValue|null|undefined} acceleration
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.acceleration = null;

            /**
             * VehicleControls wheelControls.
             * @member {Array.<metamoto.messages.VehicleControls.IWheelControl>} wheelControls
             * @memberof metamoto.messages.VehicleControls
             * @instance
             */
            VehicleControls.prototype.wheelControls = $util.emptyArray;

            /**
             * Creates a new VehicleControls instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {metamoto.messages.IVehicleControls=} [properties] Properties to set
             * @returns {metamoto.messages.VehicleControls} VehicleControls instance
             */
            VehicleControls.create = function create(properties) {
                return new VehicleControls(properties);
            };

            /**
             * Encodes the specified VehicleControls message. Does not implicitly {@link metamoto.messages.VehicleControls.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {metamoto.messages.IVehicleControls} message VehicleControls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleControls.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.steer != null && message.hasOwnProperty("steer"))
                    $root.google.protobuf.FloatValue.encode(message.steer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.throttle != null && message.hasOwnProperty("throttle"))
                    $root.google.protobuf.FloatValue.encode(message.throttle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.brake != null && message.hasOwnProperty("brake"))
                    $root.google.protobuf.FloatValue.encode(message.brake, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.gearSelector);
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.turnSignal);
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.headLights);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.google.protobuf.FloatValue.encode(message.acceleration, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.wheelControls != null && message.wheelControls.length)
                    for (var i = 0; i < message.wheelControls.length; ++i)
                        $root.metamoto.messages.VehicleControls.WheelControl.encode(message.wheelControls[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.gear != null && message.hasOwnProperty("gear"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gear);
                return writer;
            };

            /**
             * Encodes the specified VehicleControls message, length delimited. Does not implicitly {@link metamoto.messages.VehicleControls.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {metamoto.messages.IVehicleControls} message VehicleControls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleControls.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleControls message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.VehicleControls} VehicleControls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleControls.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.VehicleControls();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.steer = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.throttle = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.brake = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.gearSelector = reader.int32();
                        break;
                    case 9:
                        message.gear = reader.int32();
                        break;
                    case 5:
                        message.turnSignal = reader.int32();
                        break;
                    case 6:
                        message.headLights = reader.int32();
                        break;
                    case 7:
                        message.acceleration = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                        break;
                    case 8:
                        if (!(message.wheelControls && message.wheelControls.length))
                            message.wheelControls = [];
                        message.wheelControls.push($root.metamoto.messages.VehicleControls.WheelControl.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleControls message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.VehicleControls} VehicleControls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleControls.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleControls message.
             * @function verify
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleControls.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.steer != null && message.hasOwnProperty("steer")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.steer);
                    if (error)
                        return "steer." + error;
                }
                if (message.throttle != null && message.hasOwnProperty("throttle")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.throttle);
                    if (error)
                        return "throttle." + error;
                }
                if (message.brake != null && message.hasOwnProperty("brake")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.brake);
                    if (error)
                        return "brake." + error;
                }
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    switch (message.gearSelector) {
                    default:
                        return "gearSelector: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.gear != null && message.hasOwnProperty("gear"))
                    if (!$util.isInteger(message.gear))
                        return "gear: integer expected";
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    switch (message.turnSignal) {
                    default:
                        return "turnSignal: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    switch (message.headLights) {
                    default:
                        return "headLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.google.protobuf.FloatValue.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                if (message.wheelControls != null && message.hasOwnProperty("wheelControls")) {
                    if (!Array.isArray(message.wheelControls))
                        return "wheelControls: array expected";
                    for (var i = 0; i < message.wheelControls.length; ++i) {
                        var error = $root.metamoto.messages.VehicleControls.WheelControl.verify(message.wheelControls[i]);
                        if (error)
                            return "wheelControls." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VehicleControls message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.VehicleControls} VehicleControls
             */
            VehicleControls.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.VehicleControls)
                    return object;
                var message = new $root.metamoto.messages.VehicleControls();
                if (object.steer != null) {
                    if (typeof object.steer !== "object")
                        throw TypeError(".metamoto.messages.VehicleControls.steer: object expected");
                    message.steer = $root.google.protobuf.FloatValue.fromObject(object.steer);
                }
                if (object.throttle != null) {
                    if (typeof object.throttle !== "object")
                        throw TypeError(".metamoto.messages.VehicleControls.throttle: object expected");
                    message.throttle = $root.google.protobuf.FloatValue.fromObject(object.throttle);
                }
                if (object.brake != null) {
                    if (typeof object.brake !== "object")
                        throw TypeError(".metamoto.messages.VehicleControls.brake: object expected");
                    message.brake = $root.google.protobuf.FloatValue.fromObject(object.brake);
                }
                switch (object.gearSelector) {
                case "GEAR_UNKNOWN":
                case 0:
                    message.gearSelector = 0;
                    break;
                case "GEAR_OTHER":
                case 1:
                    message.gearSelector = 1;
                    break;
                case "GEAR_P":
                case 2:
                    message.gearSelector = 2;
                    break;
                case "GEAR_R":
                case 3:
                    message.gearSelector = 3;
                    break;
                case "GEAR_N":
                case 4:
                    message.gearSelector = 4;
                    break;
                case "GEAR_D":
                case 5:
                    message.gearSelector = 5;
                    break;
                case "GEAR_L":
                case 6:
                    message.gearSelector = 6;
                    break;
                }
                if (object.gear != null)
                    message.gear = object.gear | 0;
                switch (object.turnSignal) {
                case "SIGNAL_LIGHT_STATE_UNKNOWN":
                case 0:
                    message.turnSignal = 0;
                    break;
                case "SIGNAL_LIGHT_STATE_OTHER":
                case 1:
                    message.turnSignal = 1;
                    break;
                case "SIGNAL_LIGHT_STATE_OFF":
                case 2:
                    message.turnSignal = 2;
                    break;
                case "LEFT":
                case 3:
                    message.turnSignal = 3;
                    break;
                case "RIGHT":
                case 4:
                    message.turnSignal = 4;
                    break;
                case "HAZARD":
                case 5:
                    message.turnSignal = 5;
                    break;
                }
                switch (object.headLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.headLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.headLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.headLights = 2;
                    break;
                case "ON":
                case 3:
                    message.headLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.headLights = 4;
                    break;
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.messages.VehicleControls.acceleration: object expected");
                    message.acceleration = $root.google.protobuf.FloatValue.fromObject(object.acceleration);
                }
                if (object.wheelControls) {
                    if (!Array.isArray(object.wheelControls))
                        throw TypeError(".metamoto.messages.VehicleControls.wheelControls: array expected");
                    message.wheelControls = [];
                    for (var i = 0; i < object.wheelControls.length; ++i) {
                        if (typeof object.wheelControls[i] !== "object")
                            throw TypeError(".metamoto.messages.VehicleControls.wheelControls: object expected");
                        message.wheelControls[i] = $root.metamoto.messages.VehicleControls.WheelControl.fromObject(object.wheelControls[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleControls message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.VehicleControls
             * @static
             * @param {metamoto.messages.VehicleControls} message VehicleControls
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleControls.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.wheelControls = [];
                if (options.defaults) {
                    object.steer = null;
                    object.throttle = null;
                    object.brake = null;
                    object.gearSelector = options.enums === String ? "GEAR_UNKNOWN" : 0;
                    object.turnSignal = options.enums === String ? "SIGNAL_LIGHT_STATE_UNKNOWN" : 0;
                    object.headLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                    object.acceleration = null;
                    object.gear = 0;
                }
                if (message.steer != null && message.hasOwnProperty("steer"))
                    object.steer = $root.google.protobuf.FloatValue.toObject(message.steer, options);
                if (message.throttle != null && message.hasOwnProperty("throttle"))
                    object.throttle = $root.google.protobuf.FloatValue.toObject(message.throttle, options);
                if (message.brake != null && message.hasOwnProperty("brake"))
                    object.brake = $root.google.protobuf.FloatValue.toObject(message.brake, options);
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    object.gearSelector = options.enums === String ? $root.metamoto.types.Vehicle.GearSelector[message.gearSelector] : message.gearSelector;
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    object.turnSignal = options.enums === String ? $root.metamoto.types.Vehicle.SignalLightState[message.turnSignal] : message.turnSignal;
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    object.headLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.headLights] : message.headLights;
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.google.protobuf.FloatValue.toObject(message.acceleration, options);
                if (message.wheelControls && message.wheelControls.length) {
                    object.wheelControls = [];
                    for (var j = 0; j < message.wheelControls.length; ++j)
                        object.wheelControls[j] = $root.metamoto.messages.VehicleControls.WheelControl.toObject(message.wheelControls[j], options);
                }
                if (message.gear != null && message.hasOwnProperty("gear"))
                    object.gear = message.gear;
                return object;
            };

            /**
             * Converts this VehicleControls to JSON.
             * @function toJSON
             * @memberof metamoto.messages.VehicleControls
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleControls.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            VehicleControls.WheelControl = (function() {

                /**
                 * Properties of a WheelControl.
                 * @memberof metamoto.messages.VehicleControls
                 * @interface IWheelControl
                 * @property {google.protobuf.IFloatValue|null} [angularVelocity] WheelControl angularVelocity
                 * @property {google.protobuf.IFloatValue|null} [steerAngle] WheelControl steerAngle
                 */

                /**
                 * Constructs a new WheelControl.
                 * @memberof metamoto.messages.VehicleControls
                 * @classdesc Represents a WheelControl.
                 * @implements IWheelControl
                 * @constructor
                 * @param {metamoto.messages.VehicleControls.IWheelControl=} [properties] Properties to set
                 */
                function WheelControl(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WheelControl angularVelocity.
                 * @member {google.protobuf.IFloatValue|null|undefined} angularVelocity
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @instance
                 */
                WheelControl.prototype.angularVelocity = null;

                /**
                 * WheelControl steerAngle.
                 * @member {google.protobuf.IFloatValue|null|undefined} steerAngle
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @instance
                 */
                WheelControl.prototype.steerAngle = null;

                /**
                 * Creates a new WheelControl instance using the specified properties.
                 * @function create
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {metamoto.messages.VehicleControls.IWheelControl=} [properties] Properties to set
                 * @returns {metamoto.messages.VehicleControls.WheelControl} WheelControl instance
                 */
                WheelControl.create = function create(properties) {
                    return new WheelControl(properties);
                };

                /**
                 * Encodes the specified WheelControl message. Does not implicitly {@link metamoto.messages.VehicleControls.WheelControl.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {metamoto.messages.VehicleControls.IWheelControl} message WheelControl message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelControl.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                        $root.google.protobuf.FloatValue.encode(message.angularVelocity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                        $root.google.protobuf.FloatValue.encode(message.steerAngle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified WheelControl message, length delimited. Does not implicitly {@link metamoto.messages.VehicleControls.WheelControl.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {metamoto.messages.VehicleControls.IWheelControl} message WheelControl message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelControl.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WheelControl message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.messages.VehicleControls.WheelControl} WheelControl
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelControl.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.VehicleControls.WheelControl();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.angularVelocity = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.steerAngle = $root.google.protobuf.FloatValue.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WheelControl message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.messages.VehicleControls.WheelControl} WheelControl
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelControl.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WheelControl message.
                 * @function verify
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WheelControl.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity")) {
                        var error = $root.google.protobuf.FloatValue.verify(message.angularVelocity);
                        if (error)
                            return "angularVelocity." + error;
                    }
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle")) {
                        var error = $root.google.protobuf.FloatValue.verify(message.steerAngle);
                        if (error)
                            return "steerAngle." + error;
                    }
                    return null;
                };

                /**
                 * Creates a WheelControl message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.messages.VehicleControls.WheelControl} WheelControl
                 */
                WheelControl.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.messages.VehicleControls.WheelControl)
                        return object;
                    var message = new $root.metamoto.messages.VehicleControls.WheelControl();
                    if (object.angularVelocity != null) {
                        if (typeof object.angularVelocity !== "object")
                            throw TypeError(".metamoto.messages.VehicleControls.WheelControl.angularVelocity: object expected");
                        message.angularVelocity = $root.google.protobuf.FloatValue.fromObject(object.angularVelocity);
                    }
                    if (object.steerAngle != null) {
                        if (typeof object.steerAngle !== "object")
                            throw TypeError(".metamoto.messages.VehicleControls.WheelControl.steerAngle: object expected");
                        message.steerAngle = $root.google.protobuf.FloatValue.fromObject(object.steerAngle);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a WheelControl message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @static
                 * @param {metamoto.messages.VehicleControls.WheelControl} message WheelControl
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WheelControl.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.angularVelocity = null;
                        object.steerAngle = null;
                    }
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                        object.angularVelocity = $root.google.protobuf.FloatValue.toObject(message.angularVelocity, options);
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                        object.steerAngle = $root.google.protobuf.FloatValue.toObject(message.steerAngle, options);
                    return object;
                };

                /**
                 * Converts this WheelControl to JSON.
                 * @function toJSON
                 * @memberof metamoto.messages.VehicleControls.WheelControl
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WheelControl.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WheelControl;
            })();

            return VehicleControls;
        })();

        messages.VehicleState = (function() {

            /**
             * Properties of a VehicleState.
             * @memberof metamoto.messages
             * @interface IVehicleState
             * @property {metamoto.types.IPose|null} [pose] VehicleState pose
             * @property {metamoto.types.IVelocity|null} [velocity] VehicleState velocity
             * @property {metamoto.types.IAcceleration|null} [acceleration] VehicleState acceleration
             * @property {Array.<metamoto.types.IRoadPoint>|null} [roadPoint] VehicleState roadPoint
             * @property {number|null} [steerAngle] VehicleState steerAngle
             * @property {number|null} [throttle] VehicleState throttle
             * @property {number|null} [brake] VehicleState brake
             * @property {number|null} [speed] VehicleState speed
             * @property {metamoto.types.Vehicle.GearSelector|null} [gearSelector] VehicleState gearSelector
             * @property {number|null} [gear] VehicleState gear
             * @property {number|null} [rpm] VehicleState rpm
             * @property {metamoto.types.Vehicle.SignalLightState|null} [turnSignal] VehicleState turnSignal
             * @property {metamoto.types.Vehicle.LightState|null} [headLights] VehicleState headLights
             * @property {Array.<metamoto.messages.VehicleState.IWheelState>|null} [wheels] VehicleState wheels
             */

            /**
             * Constructs a new VehicleState.
             * @memberof metamoto.messages
             * @classdesc Represents a VehicleState.
             * @implements IVehicleState
             * @constructor
             * @param {metamoto.messages.IVehicleState=} [properties] Properties to set
             */
            function VehicleState(properties) {
                this.roadPoint = [];
                this.wheels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleState pose.
             * @member {metamoto.types.IPose|null|undefined} pose
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.pose = null;

            /**
             * VehicleState velocity.
             * @member {metamoto.types.IVelocity|null|undefined} velocity
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.velocity = null;

            /**
             * VehicleState acceleration.
             * @member {metamoto.types.IAcceleration|null|undefined} acceleration
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.acceleration = null;

            /**
             * VehicleState roadPoint.
             * @member {Array.<metamoto.types.IRoadPoint>} roadPoint
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.roadPoint = $util.emptyArray;

            /**
             * VehicleState steerAngle.
             * @member {number} steerAngle
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.steerAngle = 0;

            /**
             * VehicleState throttle.
             * @member {number} throttle
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.throttle = 0;

            /**
             * VehicleState brake.
             * @member {number} brake
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.brake = 0;

            /**
             * VehicleState speed.
             * @member {number} speed
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.speed = 0;

            /**
             * VehicleState gearSelector.
             * @member {metamoto.types.Vehicle.GearSelector} gearSelector
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.gearSelector = 0;

            /**
             * VehicleState gear.
             * @member {number} gear
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.gear = 0;

            /**
             * VehicleState rpm.
             * @member {number} rpm
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.rpm = 0;

            /**
             * VehicleState turnSignal.
             * @member {metamoto.types.Vehicle.SignalLightState} turnSignal
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.turnSignal = 0;

            /**
             * VehicleState headLights.
             * @member {metamoto.types.Vehicle.LightState} headLights
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.headLights = 0;

            /**
             * VehicleState wheels.
             * @member {Array.<metamoto.messages.VehicleState.IWheelState>} wheels
             * @memberof metamoto.messages.VehicleState
             * @instance
             */
            VehicleState.prototype.wheels = $util.emptyArray;

            /**
             * Creates a new VehicleState instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {metamoto.messages.IVehicleState=} [properties] Properties to set
             * @returns {metamoto.messages.VehicleState} VehicleState instance
             */
            VehicleState.create = function create(properties) {
                return new VehicleState(properties);
            };

            /**
             * Encodes the specified VehicleState message. Does not implicitly {@link metamoto.messages.VehicleState.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {metamoto.messages.IVehicleState} message VehicleState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && message.hasOwnProperty("pose"))
                    $root.metamoto.types.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    $root.metamoto.types.Velocity.encode(message.velocity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    $root.metamoto.types.Acceleration.encode(message.acceleration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.roadPoint != null && message.roadPoint.length)
                    for (var i = 0; i < message.roadPoint.length; ++i)
                        $root.metamoto.types.RoadPoint.encode(message.roadPoint[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.steerAngle);
                if (message.throttle != null && message.hasOwnProperty("throttle"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.throttle);
                if (message.brake != null && message.hasOwnProperty("brake"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.brake);
                if (message.speed != null && message.hasOwnProperty("speed"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.speed);
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gearSelector);
                if (message.gear != null && message.hasOwnProperty("gear"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.gear);
                if (message.rpm != null && message.hasOwnProperty("rpm"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.rpm);
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.turnSignal);
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.headLights);
                if (message.wheels != null && message.wheels.length)
                    for (var i = 0; i < message.wheels.length; ++i)
                        $root.metamoto.messages.VehicleState.WheelState.encode(message.wheels[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VehicleState message, length delimited. Does not implicitly {@link metamoto.messages.VehicleState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {metamoto.messages.IVehicleState} message VehicleState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleState message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.VehicleState} VehicleState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.VehicleState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pose = $root.metamoto.types.Pose.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.velocity = $root.metamoto.types.Velocity.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.acceleration = $root.metamoto.types.Acceleration.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.roadPoint && message.roadPoint.length))
                            message.roadPoint = [];
                        message.roadPoint.push($root.metamoto.types.RoadPoint.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.steerAngle = reader.float();
                        break;
                    case 6:
                        message.throttle = reader.float();
                        break;
                    case 7:
                        message.brake = reader.float();
                        break;
                    case 8:
                        message.speed = reader.float();
                        break;
                    case 9:
                        message.gearSelector = reader.int32();
                        break;
                    case 10:
                        message.gear = reader.int32();
                        break;
                    case 11:
                        message.rpm = reader.float();
                        break;
                    case 12:
                        message.turnSignal = reader.int32();
                        break;
                    case 13:
                        message.headLights = reader.int32();
                        break;
                    case 15:
                        if (!(message.wheels && message.wheels.length))
                            message.wheels = [];
                        message.wheels.push($root.metamoto.messages.VehicleState.WheelState.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.VehicleState} VehicleState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleState message.
             * @function verify
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.metamoto.types.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    var error = $root.metamoto.types.Velocity.verify(message.velocity);
                    if (error)
                        return "velocity." + error;
                }
                if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                    var error = $root.metamoto.types.Acceleration.verify(message.acceleration);
                    if (error)
                        return "acceleration." + error;
                }
                if (message.roadPoint != null && message.hasOwnProperty("roadPoint")) {
                    if (!Array.isArray(message.roadPoint))
                        return "roadPoint: array expected";
                    for (var i = 0; i < message.roadPoint.length; ++i) {
                        var error = $root.metamoto.types.RoadPoint.verify(message.roadPoint[i]);
                        if (error)
                            return "roadPoint." + error;
                    }
                }
                if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                    if (typeof message.steerAngle !== "number")
                        return "steerAngle: number expected";
                if (message.throttle != null && message.hasOwnProperty("throttle"))
                    if (typeof message.throttle !== "number")
                        return "throttle: number expected";
                if (message.brake != null && message.hasOwnProperty("brake"))
                    if (typeof message.brake !== "number")
                        return "brake: number expected";
                if (message.speed != null && message.hasOwnProperty("speed"))
                    if (typeof message.speed !== "number")
                        return "speed: number expected";
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    switch (message.gearSelector) {
                    default:
                        return "gearSelector: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.gear != null && message.hasOwnProperty("gear"))
                    if (!$util.isInteger(message.gear))
                        return "gear: integer expected";
                if (message.rpm != null && message.hasOwnProperty("rpm"))
                    if (typeof message.rpm !== "number")
                        return "rpm: number expected";
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    switch (message.turnSignal) {
                    default:
                        return "turnSignal: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    switch (message.headLights) {
                    default:
                        return "headLights: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.wheels != null && message.hasOwnProperty("wheels")) {
                    if (!Array.isArray(message.wheels))
                        return "wheels: array expected";
                    for (var i = 0; i < message.wheels.length; ++i) {
                        var error = $root.metamoto.messages.VehicleState.WheelState.verify(message.wheels[i]);
                        if (error)
                            return "wheels." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VehicleState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.VehicleState} VehicleState
             */
            VehicleState.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.VehicleState)
                    return object;
                var message = new $root.metamoto.messages.VehicleState();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".metamoto.messages.VehicleState.pose: object expected");
                    message.pose = $root.metamoto.types.Pose.fromObject(object.pose);
                }
                if (object.velocity != null) {
                    if (typeof object.velocity !== "object")
                        throw TypeError(".metamoto.messages.VehicleState.velocity: object expected");
                    message.velocity = $root.metamoto.types.Velocity.fromObject(object.velocity);
                }
                if (object.acceleration != null) {
                    if (typeof object.acceleration !== "object")
                        throw TypeError(".metamoto.messages.VehicleState.acceleration: object expected");
                    message.acceleration = $root.metamoto.types.Acceleration.fromObject(object.acceleration);
                }
                if (object.roadPoint) {
                    if (!Array.isArray(object.roadPoint))
                        throw TypeError(".metamoto.messages.VehicleState.roadPoint: array expected");
                    message.roadPoint = [];
                    for (var i = 0; i < object.roadPoint.length; ++i) {
                        if (typeof object.roadPoint[i] !== "object")
                            throw TypeError(".metamoto.messages.VehicleState.roadPoint: object expected");
                        message.roadPoint[i] = $root.metamoto.types.RoadPoint.fromObject(object.roadPoint[i]);
                    }
                }
                if (object.steerAngle != null)
                    message.steerAngle = Number(object.steerAngle);
                if (object.throttle != null)
                    message.throttle = Number(object.throttle);
                if (object.brake != null)
                    message.brake = Number(object.brake);
                if (object.speed != null)
                    message.speed = Number(object.speed);
                switch (object.gearSelector) {
                case "GEAR_UNKNOWN":
                case 0:
                    message.gearSelector = 0;
                    break;
                case "GEAR_OTHER":
                case 1:
                    message.gearSelector = 1;
                    break;
                case "GEAR_P":
                case 2:
                    message.gearSelector = 2;
                    break;
                case "GEAR_R":
                case 3:
                    message.gearSelector = 3;
                    break;
                case "GEAR_N":
                case 4:
                    message.gearSelector = 4;
                    break;
                case "GEAR_D":
                case 5:
                    message.gearSelector = 5;
                    break;
                case "GEAR_L":
                case 6:
                    message.gearSelector = 6;
                    break;
                }
                if (object.gear != null)
                    message.gear = object.gear | 0;
                if (object.rpm != null)
                    message.rpm = Number(object.rpm);
                switch (object.turnSignal) {
                case "SIGNAL_LIGHT_STATE_UNKNOWN":
                case 0:
                    message.turnSignal = 0;
                    break;
                case "SIGNAL_LIGHT_STATE_OTHER":
                case 1:
                    message.turnSignal = 1;
                    break;
                case "SIGNAL_LIGHT_STATE_OFF":
                case 2:
                    message.turnSignal = 2;
                    break;
                case "LEFT":
                case 3:
                    message.turnSignal = 3;
                    break;
                case "RIGHT":
                case 4:
                    message.turnSignal = 4;
                    break;
                case "HAZARD":
                case 5:
                    message.turnSignal = 5;
                    break;
                }
                switch (object.headLights) {
                case "LIGHT_STATE_UNKNOWN":
                case 0:
                    message.headLights = 0;
                    break;
                case "LIGHT_STATE_OTHER":
                case 1:
                    message.headLights = 1;
                    break;
                case "OFF":
                case 2:
                    message.headLights = 2;
                    break;
                case "ON":
                case 3:
                    message.headLights = 3;
                    break;
                case "STRONG":
                case 4:
                    message.headLights = 4;
                    break;
                }
                if (object.wheels) {
                    if (!Array.isArray(object.wheels))
                        throw TypeError(".metamoto.messages.VehicleState.wheels: array expected");
                    message.wheels = [];
                    for (var i = 0; i < object.wheels.length; ++i) {
                        if (typeof object.wheels[i] !== "object")
                            throw TypeError(".metamoto.messages.VehicleState.wheels: object expected");
                        message.wheels[i] = $root.metamoto.messages.VehicleState.WheelState.fromObject(object.wheels[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.VehicleState
             * @static
             * @param {metamoto.messages.VehicleState} message VehicleState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.roadPoint = [];
                    object.wheels = [];
                }
                if (options.defaults) {
                    object.pose = null;
                    object.velocity = null;
                    object.acceleration = null;
                    object.steerAngle = 0;
                    object.throttle = 0;
                    object.brake = 0;
                    object.speed = 0;
                    object.gearSelector = options.enums === String ? "GEAR_UNKNOWN" : 0;
                    object.gear = 0;
                    object.rpm = 0;
                    object.turnSignal = options.enums === String ? "SIGNAL_LIGHT_STATE_UNKNOWN" : 0;
                    object.headLights = options.enums === String ? "LIGHT_STATE_UNKNOWN" : 0;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.metamoto.types.Pose.toObject(message.pose, options);
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = $root.metamoto.types.Velocity.toObject(message.velocity, options);
                if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                    object.acceleration = $root.metamoto.types.Acceleration.toObject(message.acceleration, options);
                if (message.roadPoint && message.roadPoint.length) {
                    object.roadPoint = [];
                    for (var j = 0; j < message.roadPoint.length; ++j)
                        object.roadPoint[j] = $root.metamoto.types.RoadPoint.toObject(message.roadPoint[j], options);
                }
                if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                    object.steerAngle = options.json && !isFinite(message.steerAngle) ? String(message.steerAngle) : message.steerAngle;
                if (message.throttle != null && message.hasOwnProperty("throttle"))
                    object.throttle = options.json && !isFinite(message.throttle) ? String(message.throttle) : message.throttle;
                if (message.brake != null && message.hasOwnProperty("brake"))
                    object.brake = options.json && !isFinite(message.brake) ? String(message.brake) : message.brake;
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                if (message.gearSelector != null && message.hasOwnProperty("gearSelector"))
                    object.gearSelector = options.enums === String ? $root.metamoto.types.Vehicle.GearSelector[message.gearSelector] : message.gearSelector;
                if (message.gear != null && message.hasOwnProperty("gear"))
                    object.gear = message.gear;
                if (message.rpm != null && message.hasOwnProperty("rpm"))
                    object.rpm = options.json && !isFinite(message.rpm) ? String(message.rpm) : message.rpm;
                if (message.turnSignal != null && message.hasOwnProperty("turnSignal"))
                    object.turnSignal = options.enums === String ? $root.metamoto.types.Vehicle.SignalLightState[message.turnSignal] : message.turnSignal;
                if (message.headLights != null && message.hasOwnProperty("headLights"))
                    object.headLights = options.enums === String ? $root.metamoto.types.Vehicle.LightState[message.headLights] : message.headLights;
                if (message.wheels && message.wheels.length) {
                    object.wheels = [];
                    for (var j = 0; j < message.wheels.length; ++j)
                        object.wheels[j] = $root.metamoto.messages.VehicleState.WheelState.toObject(message.wheels[j], options);
                }
                return object;
            };

            /**
             * Converts this VehicleState to JSON.
             * @function toJSON
             * @memberof metamoto.messages.VehicleState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            VehicleState.WheelState = (function() {

                /**
                 * Properties of a WheelState.
                 * @memberof metamoto.messages.VehicleState
                 * @interface IWheelState
                 * @property {number|null} [angularVelocity] WheelState angularVelocity
                 * @property {number|null} [steerAngle] WheelState steerAngle
                 */

                /**
                 * Constructs a new WheelState.
                 * @memberof metamoto.messages.VehicleState
                 * @classdesc Represents a WheelState.
                 * @implements IWheelState
                 * @constructor
                 * @param {metamoto.messages.VehicleState.IWheelState=} [properties] Properties to set
                 */
                function WheelState(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WheelState angularVelocity.
                 * @member {number} angularVelocity
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @instance
                 */
                WheelState.prototype.angularVelocity = 0;

                /**
                 * WheelState steerAngle.
                 * @member {number} steerAngle
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @instance
                 */
                WheelState.prototype.steerAngle = 0;

                /**
                 * Creates a new WheelState instance using the specified properties.
                 * @function create
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {metamoto.messages.VehicleState.IWheelState=} [properties] Properties to set
                 * @returns {metamoto.messages.VehicleState.WheelState} WheelState instance
                 */
                WheelState.create = function create(properties) {
                    return new WheelState(properties);
                };

                /**
                 * Encodes the specified WheelState message. Does not implicitly {@link metamoto.messages.VehicleState.WheelState.verify|verify} messages.
                 * @function encode
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {metamoto.messages.VehicleState.IWheelState} message WheelState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.angularVelocity);
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.steerAngle);
                    return writer;
                };

                /**
                 * Encodes the specified WheelState message, length delimited. Does not implicitly {@link metamoto.messages.VehicleState.WheelState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {metamoto.messages.VehicleState.IWheelState} message WheelState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WheelState message from the specified reader or buffer.
                 * @function decode
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {metamoto.messages.VehicleState.WheelState} WheelState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.VehicleState.WheelState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.angularVelocity = reader.float();
                            break;
                        case 2:
                            message.steerAngle = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WheelState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {metamoto.messages.VehicleState.WheelState} WheelState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WheelState message.
                 * @function verify
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WheelState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                        if (typeof message.angularVelocity !== "number")
                            return "angularVelocity: number expected";
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                        if (typeof message.steerAngle !== "number")
                            return "steerAngle: number expected";
                    return null;
                };

                /**
                 * Creates a WheelState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {metamoto.messages.VehicleState.WheelState} WheelState
                 */
                WheelState.fromObject = function fromObject(object) {
                    if (object instanceof $root.metamoto.messages.VehicleState.WheelState)
                        return object;
                    var message = new $root.metamoto.messages.VehicleState.WheelState();
                    if (object.angularVelocity != null)
                        message.angularVelocity = Number(object.angularVelocity);
                    if (object.steerAngle != null)
                        message.steerAngle = Number(object.steerAngle);
                    return message;
                };

                /**
                 * Creates a plain object from a WheelState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @static
                 * @param {metamoto.messages.VehicleState.WheelState} message WheelState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WheelState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.angularVelocity = 0;
                        object.steerAngle = 0;
                    }
                    if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                        object.angularVelocity = options.json && !isFinite(message.angularVelocity) ? String(message.angularVelocity) : message.angularVelocity;
                    if (message.steerAngle != null && message.hasOwnProperty("steerAngle"))
                        object.steerAngle = options.json && !isFinite(message.steerAngle) ? String(message.steerAngle) : message.steerAngle;
                    return object;
                };

                /**
                 * Converts this WheelState to JSON.
                 * @function toJSON
                 * @memberof metamoto.messages.VehicleState.WheelState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WheelState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WheelState;
            })();

            return VehicleState;
        })();

        messages.VisualizationList = (function() {

            /**
             * Properties of a VisualizationList.
             * @memberof metamoto.messages
             * @interface IVisualizationList
             * @property {Array.<metamoto.messages.IVisualization>|null} [visualMessages] VisualizationList visualMessages
             */

            /**
             * Constructs a new VisualizationList.
             * @memberof metamoto.messages
             * @classdesc Represents a VisualizationList.
             * @implements IVisualizationList
             * @constructor
             * @param {metamoto.messages.IVisualizationList=} [properties] Properties to set
             */
            function VisualizationList(properties) {
                this.visualMessages = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisualizationList visualMessages.
             * @member {Array.<metamoto.messages.IVisualization>} visualMessages
             * @memberof metamoto.messages.VisualizationList
             * @instance
             */
            VisualizationList.prototype.visualMessages = $util.emptyArray;

            /**
             * Creates a new VisualizationList instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {metamoto.messages.IVisualizationList=} [properties] Properties to set
             * @returns {metamoto.messages.VisualizationList} VisualizationList instance
             */
            VisualizationList.create = function create(properties) {
                return new VisualizationList(properties);
            };

            /**
             * Encodes the specified VisualizationList message. Does not implicitly {@link metamoto.messages.VisualizationList.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {metamoto.messages.IVisualizationList} message VisualizationList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizationList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.visualMessages != null && message.visualMessages.length)
                    for (var i = 0; i < message.visualMessages.length; ++i)
                        $root.metamoto.messages.Visualization.encode(message.visualMessages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VisualizationList message, length delimited. Does not implicitly {@link metamoto.messages.VisualizationList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {metamoto.messages.IVisualizationList} message VisualizationList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizationList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisualizationList message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.VisualizationList} VisualizationList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizationList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.VisualizationList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.visualMessages && message.visualMessages.length))
                            message.visualMessages = [];
                        message.visualMessages.push($root.metamoto.messages.Visualization.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisualizationList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.VisualizationList} VisualizationList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizationList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisualizationList message.
             * @function verify
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VisualizationList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.visualMessages != null && message.hasOwnProperty("visualMessages")) {
                    if (!Array.isArray(message.visualMessages))
                        return "visualMessages: array expected";
                    for (var i = 0; i < message.visualMessages.length; ++i) {
                        var error = $root.metamoto.messages.Visualization.verify(message.visualMessages[i]);
                        if (error)
                            return "visualMessages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VisualizationList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.VisualizationList} VisualizationList
             */
            VisualizationList.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.VisualizationList)
                    return object;
                var message = new $root.metamoto.messages.VisualizationList();
                if (object.visualMessages) {
                    if (!Array.isArray(object.visualMessages))
                        throw TypeError(".metamoto.messages.VisualizationList.visualMessages: array expected");
                    message.visualMessages = [];
                    for (var i = 0; i < object.visualMessages.length; ++i) {
                        if (typeof object.visualMessages[i] !== "object")
                            throw TypeError(".metamoto.messages.VisualizationList.visualMessages: object expected");
                        message.visualMessages[i] = $root.metamoto.messages.Visualization.fromObject(object.visualMessages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VisualizationList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.VisualizationList
             * @static
             * @param {metamoto.messages.VisualizationList} message VisualizationList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisualizationList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.visualMessages = [];
                if (message.visualMessages && message.visualMessages.length) {
                    object.visualMessages = [];
                    for (var j = 0; j < message.visualMessages.length; ++j)
                        object.visualMessages[j] = $root.metamoto.messages.Visualization.toObject(message.visualMessages[j], options);
                }
                return object;
            };

            /**
             * Converts this VisualizationList to JSON.
             * @function toJSON
             * @memberof metamoto.messages.VisualizationList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VisualizationList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VisualizationList;
        })();

        messages.Visualization = (function() {

            /**
             * Properties of a Visualization.
             * @memberof metamoto.messages
             * @interface IVisualization
             * @property {number|null} [time] Visualization time
             * @property {metamoto.types.ReferenceFrame|null} [frame] Visualization frame
             * @property {metamoto.types.IBoundingBox|null} [box] Visualization box
             * @property {metamoto.types.IVisualPath|null} [path] Visualization path
             * @property {string|null} [label] Visualization label
             * @property {string|null} [description] Visualization description
             * @property {number|null} [duration] Visualization duration
             */

            /**
             * Constructs a new Visualization.
             * @memberof metamoto.messages
             * @classdesc Represents a Visualization.
             * @implements IVisualization
             * @constructor
             * @param {metamoto.messages.IVisualization=} [properties] Properties to set
             */
            function Visualization(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Visualization time.
             * @member {number} time
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.time = 0;

            /**
             * Visualization frame.
             * @member {metamoto.types.ReferenceFrame} frame
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.frame = 0;

            /**
             * Visualization box.
             * @member {metamoto.types.IBoundingBox|null|undefined} box
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.box = null;

            /**
             * Visualization path.
             * @member {metamoto.types.IVisualPath|null|undefined} path
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.path = null;

            /**
             * Visualization label.
             * @member {string} label
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.label = "";

            /**
             * Visualization description.
             * @member {string} description
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.description = "";

            /**
             * Visualization duration.
             * @member {number} duration
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Visualization.prototype.duration = 0;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Visualization pathType.
             * @member {"box"|"path"|undefined} pathType
             * @memberof metamoto.messages.Visualization
             * @instance
             */
            Object.defineProperty(Visualization.prototype, "pathType", {
                get: $util.oneOfGetter($oneOfFields = ["box", "path"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Visualization instance using the specified properties.
             * @function create
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {metamoto.messages.IVisualization=} [properties] Properties to set
             * @returns {metamoto.messages.Visualization} Visualization instance
             */
            Visualization.create = function create(properties) {
                return new Visualization(properties);
            };

            /**
             * Encodes the specified Visualization message. Does not implicitly {@link metamoto.messages.Visualization.verify|verify} messages.
             * @function encode
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {metamoto.messages.IVisualization} message Visualization message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Visualization.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && message.hasOwnProperty("time"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                if (message.frame != null && message.hasOwnProperty("frame"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.frame);
                if (message.box != null && message.hasOwnProperty("box"))
                    $root.metamoto.types.BoundingBox.encode(message.box, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    $root.metamoto.types.VisualPath.encode(message.path, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.label);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                if (message.duration != null && message.hasOwnProperty("duration"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.duration);
                return writer;
            };

            /**
             * Encodes the specified Visualization message, length delimited. Does not implicitly {@link metamoto.messages.Visualization.verify|verify} messages.
             * @function encodeDelimited
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {metamoto.messages.IVisualization} message Visualization message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Visualization.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Visualization message from the specified reader or buffer.
             * @function decode
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {metamoto.messages.Visualization} Visualization
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Visualization.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.metamoto.messages.Visualization();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = reader.double();
                        break;
                    case 2:
                        message.frame = reader.int32();
                        break;
                    case 3:
                        message.box = $root.metamoto.types.BoundingBox.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.path = $root.metamoto.types.VisualPath.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.label = reader.string();
                        break;
                    case 7:
                        message.description = reader.string();
                        break;
                    case 8:
                        message.duration = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Visualization message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {metamoto.messages.Visualization} Visualization
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Visualization.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Visualization message.
             * @function verify
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Visualization.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                if (message.frame != null && message.hasOwnProperty("frame"))
                    switch (message.frame) {
                    default:
                        return "frame: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.box != null && message.hasOwnProperty("box")) {
                    properties.pathType = 1;
                    {
                        var error = $root.metamoto.types.BoundingBox.verify(message.box);
                        if (error)
                            return "box." + error;
                    }
                }
                if (message.path != null && message.hasOwnProperty("path")) {
                    if (properties.pathType === 1)
                        return "pathType: multiple values";
                    properties.pathType = 1;
                    {
                        var error = $root.metamoto.types.VisualPath.verify(message.path);
                        if (error)
                            return "path." + error;
                    }
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };

            /**
             * Creates a Visualization message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {metamoto.messages.Visualization} Visualization
             */
            Visualization.fromObject = function fromObject(object) {
                if (object instanceof $root.metamoto.messages.Visualization)
                    return object;
                var message = new $root.metamoto.messages.Visualization();
                if (object.time != null)
                    message.time = Number(object.time);
                switch (object.frame) {
                case "REFERENCE_FRAME_UNKNOWN":
                case 0:
                    message.frame = 0;
                    break;
                case "REFERENCE_FRAME_OTHER":
                case 1:
                    message.frame = 1;
                    break;
                case "REFERENCE_FRAME_WORLD":
                case 2:
                    message.frame = 2;
                    break;
                case "REFERENCE_FRAME_VEHICLE":
                case 3:
                    message.frame = 3;
                    break;
                case "REFERENCE_FRAME_SENSOR":
                case 4:
                    message.frame = 4;
                    break;
                }
                if (object.box != null) {
                    if (typeof object.box !== "object")
                        throw TypeError(".metamoto.messages.Visualization.box: object expected");
                    message.box = $root.metamoto.types.BoundingBox.fromObject(object.box);
                }
                if (object.path != null) {
                    if (typeof object.path !== "object")
                        throw TypeError(".metamoto.messages.Visualization.path: object expected");
                    message.path = $root.metamoto.types.VisualPath.fromObject(object.path);
                }
                if (object.label != null)
                    message.label = String(object.label);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };

            /**
             * Creates a plain object from a Visualization message. Also converts values to other types if specified.
             * @function toObject
             * @memberof metamoto.messages.Visualization
             * @static
             * @param {metamoto.messages.Visualization} message Visualization
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Visualization.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.time = 0;
                    object.frame = options.enums === String ? "REFERENCE_FRAME_UNKNOWN" : 0;
                    object.label = "";
                    object.description = "";
                    object.duration = 0;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                if (message.frame != null && message.hasOwnProperty("frame"))
                    object.frame = options.enums === String ? $root.metamoto.types.ReferenceFrame[message.frame] : message.frame;
                if (message.box != null && message.hasOwnProperty("box")) {
                    object.box = $root.metamoto.types.BoundingBox.toObject(message.box, options);
                    if (options.oneofs)
                        object.pathType = "box";
                }
                if (message.path != null && message.hasOwnProperty("path")) {
                    object.path = $root.metamoto.types.VisualPath.toObject(message.path, options);
                    if (options.oneofs)
                        object.pathType = "path";
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };

            /**
             * Converts this Visualization to JSON.
             * @function toJSON
             * @memberof metamoto.messages.Visualization
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Visualization.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Visualization;
        })();

        return messages;
    })();

    return metamoto;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && message.hasOwnProperty("fields"))
                    for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        key = reader.string();
                        reader.pos++;
                        message.fields[key] = $root.google.protobuf.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = 0;

            /**
             * Value numberValue.
             * @member {number} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = 0;

            /**
             * Value stringValue.
             * @member {string} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = "";

            /**
             * Value boolValue.
             * @member {boolean} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = false;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && message.hasOwnProperty("nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && message.hasOwnProperty("numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && message.hasOwnProperty("structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && message.hasOwnProperty("listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                var message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {string}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             */
            function DoubleValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified DoubleValue message, length delimited. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DoubleValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoubleValue message.
             * @function verify
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoubleValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DoubleValue} DoubleValue
             */
            DoubleValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DoubleValue)
                    return object;
                var message = new $root.google.protobuf.DoubleValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.DoubleValue} message DoubleValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoubleValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this DoubleValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.DoubleValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoubleValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             */
            function FloatValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified FloatValue message, length delimited. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FloatValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FloatValue message.
             * @function verify
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FloatValue} FloatValue
             */
            FloatValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FloatValue)
                    return object;
                var message = new $root.google.protobuf.FloatValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.FloatValue} message FloatValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this FloatValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.FloatValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {number|Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             */
            function Int64Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int64Value message, length delimited. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int64Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int64Value message.
             * @function verify
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int64Value} Int64Value
             */
            Int64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int64Value)
                    return object;
                var message = new $root.google.protobuf.Int64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.Int64Value} message Int64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this Int64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {number|Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             */
            function UInt64Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt64Value message, length delimited. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt64Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt64Value message.
             * @function verify
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt64Value} UInt64Value
             */
            UInt64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt64Value)
                    return object;
                var message = new $root.google.protobuf.UInt64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.UInt64Value} message UInt64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this UInt64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             */
            function Int32Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int32Value message, length delimited. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int32Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int32Value message.
             * @function verify
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int32Value} Int32Value
             */
            Int32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int32Value)
                    return object;
                var message = new $root.google.protobuf.Int32Value();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.Int32Value} message Int32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Int32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             */
            function UInt32Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt32Value message, length delimited. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt32Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt32Value message.
             * @function verify
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt32Value} UInt32Value
             */
            UInt32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt32Value)
                    return object;
                var message = new $root.google.protobuf.UInt32Value();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.UInt32Value} message UInt32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this UInt32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             */
            function BoolValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified BoolValue message, length delimited. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BoolValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoolValue message.
             * @function verify
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BoolValue} BoolValue
             */
            BoolValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BoolValue)
                    return object;
                var message = new $root.google.protobuf.BoolValue();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.BoolValue} message BoolValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this BoolValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BoolValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified StringValue message, length delimited. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.StringValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.StringValue)
                    return object;
                var message = new $root.google.protobuf.StringValue();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             */
            function BytesValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified BytesValue message, length delimited. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BytesValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BytesValue message.
             * @function verify
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BytesValue} BytesValue
             */
            BytesValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BytesValue)
                    return object;
                var message = new $root.google.protobuf.BytesValue();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.BytesValue} message BytesValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this BytesValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BytesValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BytesValue;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    google.rpc = (function() {

        /**
         * Namespace rpc.
         * @memberof google
         * @namespace
         */
        var rpc = {};

        rpc.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof google.rpc
             * @interface IStatus
             * @property {number|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {Array.<google.protobuf.IAny>|null} [details] Status details
             */

            /**
             * Constructs a new Status.
             * @memberof google.rpc
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {google.rpc.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                this.details = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {number} code
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status details.
             * @member {Array.<google.protobuf.IAny>} details
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.details = $util.emptyArray;

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus=} [properties] Properties to set
             * @returns {google.rpc.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link google.rpc.Status.verify|verify} messages.
             * @function encode
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && message.hasOwnProperty("code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.details != null && message.details.length)
                    for (var i = 0; i < message.details.length; ++i)
                        $root.google.protobuf.Any.encode(message.details[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link google.rpc.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof google.rpc.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.rpc.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.rpc.Status();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        if (!(message.details && message.details.length))
                            message.details = [];
                        message.details.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.rpc.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.rpc.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isInteger(message.code))
                        return "code: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (var i = 0; i < message.details.length; ++i) {
                        var error = $root.google.protobuf.Any.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.rpc.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.google.rpc.Status)
                    return object;
                var message = new $root.google.rpc.Status();
                if (object.code != null)
                    message.code = object.code | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".google.rpc.Status.details: array expected");
                    message.details = [];
                    for (var i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".google.rpc.Status.details: object expected");
                        message.details[i] = $root.google.protobuf.Any.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (options.defaults) {
                    object.code = 0;
                    object.message = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.details && message.details.length) {
                    object.details = [];
                    for (var j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.google.protobuf.Any.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof google.rpc.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        return rpc;
    })();

    return google;
})();

module.exports = $root;
